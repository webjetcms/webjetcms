<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="sk"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DatatableRestControllerV2.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">webjetcms</a> &gt; <a href="index.source.html" class="el_package">sk.iway.iwcm.system.datatable</a> &gt; <span class="el_source">DatatableRestControllerV2.java</span></div><h1>DatatableRestControllerV2.java</h1><pre class="source lang-java linenums">package sk.iway.iwcm.system.datatable;

import org.eclipse.persistence.expressions.Expression;
import org.eclipse.persistence.expressions.ExpressionBuilder;
import org.eclipse.persistence.jpa.JpaEntityManager;
import org.eclipse.persistence.queries.ReadAllQuery;
import org.springframework.beans.BeanWrapperImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Example;
import org.springframework.data.domain.ExampleMatcher;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.validation.BeanPropertyBindingResult;
import org.springframework.validation.BindingResult;
import org.springframework.validation.Errors;
import org.springframework.validation.ObjectError;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.annotation.*;

import sk.iway.iwcm.*;
import sk.iway.iwcm.common.CloudToolsForCore;
import sk.iway.iwcm.database.ActiveRecordBase;
import sk.iway.iwcm.i18n.Prop;
import sk.iway.iwcm.system.ConstantsV9;
import sk.iway.iwcm.system.adminlog.AuditEntityListener;
import sk.iway.iwcm.system.datatable.NotifyBean.NotifyType;
import sk.iway.iwcm.system.datatable.annotations.DataTableColumnEditor;
import sk.iway.iwcm.system.datatable.annotations.DataTableColumnEditorAttr;
import sk.iway.iwcm.system.datatable.spring.DomainIdRepository;
import sk.iway.iwcm.system.jpa.JpaTools;
import sk.iway.iwcm.system.spring.NullAwareBeanUtils;
import sk.iway.iwcm.system.stripes.MultipartWrapper;
import sk.iway.iwcm.users.UsersDB;

//import javax.persistence.EntityManagerFactory;
import javax.persistence.Id;
//import javax.persistence.PersistenceUnit;
import javax.persistence.Query;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.Path;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.servlet.http.HttpServletRequest;
import javax.validation.*;

import java.io.Serializable;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.*;

/**
 * Title        webjet8
 * Company      Interway a. s. (www.interway.sk)
 * Copyright    Interway a. s. (c) 2001-2019
 * @author       tmarcinkova $
 * @created      2019/05/10 12:50
 *
 *  Abstraktny univerzalny RestController na pracu s DataTables Editor-om
 *
 */
public abstract class DatatableRestControllerV2&lt;T, ID extends Serializable&gt;
{
	private final JpaRepository&lt;T, Long&gt; repo;

	//pozor: po zmene je potrebne opravit aj prefix v src/main/webapp/admin/v9/src/js/app.js
	private static final String REGEX_PREFIX = &quot;regex:&quot;;

	@Autowired
	private HttpServletRequest request;

	@Autowired
	private Validator validator;

<span class="fc" id="L86">	private static final ThreadLocal&lt;ThreadBean&gt; threadData = new ThreadLocal&lt;&gt;(); //NOSONAR</span>

<span class="fc" id="L88">	boolean checkDomainId = false;</span>

<span class="fc" id="L90">	protected DatatableRestControllerV2() {</span>
<span class="fc" id="L91">		this.repo = null;</span>
<span class="fc" id="L92">	}</span>

<span class="fc" id="L94">	protected DatatableRestControllerV2(JpaRepository&lt;T, Long&gt; repo) {</span>
<span class="fc" id="L95">		this.repo = repo;</span>

		//over, ci maju byt pouzite automaticke podmienky so stlpcom domain_id
<span class="pc bpc" id="L98" title="2 of 4 branches missed.">		if (InitServlet.isTypeCloud() || Constants.getBoolean(&quot;enableStaticFilesExternalDir&quot;)==true) {</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">			if (repo instanceof DomainIdRepository) checkDomainId = true;</span>
		}
<span class="fc" id="L101">	}</span>

	/***************************** CITANIE / ZAPIS DAT *****************************/

	/**
	 * Vlozi NOVU entitu do databazy
	 * @param entity
	 * @return
	 */
	public T insertItem(T entity) {
		//musime z editoFields najskor prepisat hodnoty do entity
<span class="fc" id="L112">		T processed = processToEntity(entity, ProcessItemAction.CREATE);</span>
		//ulozime
<span class="fc" id="L114">		T saved = repo.save(processed);</span>
		//nastavime editorFields atributy
<span class="fc" id="L116">		return processFromEntity(saved, ProcessItemAction.CREATE, 1);</span>
	}

	/**
	 * Ulozi existujucu entitu do databazy
	 * @param entity
	 * @param id
	 * @return
	 */
	public T editItem(T entity, long id) {

		//zachovaj thread bean, lebo volanie getOne ho zmaze a moze to byt nastavene z beforeSave metody
<span class="fc" id="L128">		boolean forceReload = isForceReload();</span>
<span class="fc" id="L129">		List&lt;NotifyBean&gt; notify = getThreadData().getNotify();</span>
<span class="fc" id="L130">		boolean isImporting = isImporting();</span>

		//toto nam zabezpeci aby sa nam nestratili udaje, ktore nemame v editore
<span class="fc" id="L133">		T one = getOne(id);</span>

<span class="pc bpc" id="L135" title="1 of 2 branches missed.">		if (isForceReload()) setForceReload(forceReload);</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">		if (notify!=null) addNotify(notify);</span>
<span class="fc" id="L137">		setImporting(isImporting);</span>

<span class="fc" id="L139">		copyEntityIntoOriginal(entity, one);</span>

		//musime z editoFields najskor prepisat hodnoty do entity
<span class="fc" id="L142">		T processed = processToEntity(one, ProcessItemAction.EDIT);</span>
		//ulozime
<span class="fc" id="L144">		T saved = repo.save(processed);</span>
		//nastavime editorFields atributy
<span class="fc" id="L146">		return processFromEntity(saved, ProcessItemAction.EDIT, 1);</span>
	}

	/**
	 * metoda pre ziskanie entity s rovnakou hodnotou v stlci propertyName ako hodnota v obj
	 * @param propertyName
	 * @param obj
	 * @return
	 * @throws IllegalAccessException
	 * @throws NoSuchMethodException
	 * @throws InvocationTargetException
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public List&lt;T&gt; findItemBy(String propertyName, T original) throws IllegalAccessException, NoSuchMethodException, InvocationTargetException, InstantiationException {

		//musime spravit najskor kopiu obj, aby sme na nej mohli zavolat processToEntity bez posahania povodnej entity
<span class="fc" id="L162">		T obj = (T)original.getClass().getDeclaredConstructor().newInstance();</span>
<span class="fc" id="L163">		NullAwareBeanUtils.copyProperties(original, obj);</span>
<span class="fc" id="L164">		processToEntity(obj, ProcessItemAction.EDIT);</span>

<span class="fc" id="L166">		JpaEntityManager entityManager = JpaTools.getEclipseLinkEntityManager(original.getClass());</span>
<span class="fc" id="L167">		ReadAllQuery raq = new ReadAllQuery(original.getClass());</span>
<span class="fc" id="L168">		ExpressionBuilder builder = new ExpressionBuilder();</span>

<span class="fc" id="L170">		BeanWrapperImpl bw = new BeanWrapperImpl(obj);</span>
<span class="fc" id="L171">		Object value = bw.getPropertyValue(propertyName);</span>
<span class="fc" id="L172">		Expression exp = builder.get(propertyName).equal(value);</span>

		//pridaj domainId podmienku ak entita obsahuje domainId stlpec (aby sa neaktualizovali entity v inej domene)
<span class="pc bpc" id="L175" title="2 of 4 branches missed.">		if (InitServlet.isTypeCloud() || Constants.getBoolean(&quot;enableStaticFilesExternalDir&quot;)==true) {</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">			if (bw.getPropertyType(&quot;domainId&quot;)!=null) {</span>
<span class="fc" id="L177">				exp = exp.and(builder.get(&quot;domainId&quot;).equal(CloudToolsForCore.getDomainId()));</span>
			}
		}

<span class="fc" id="L181">		raq.setSelectionCriteria(exp);</span>

<span class="fc" id="L183">		Query query = entityManager.createQuery(raq);</span>
<span class="fc" id="L184">		List&lt;T&gt; list = query.getResultList();</span>
<span class="fc" id="L185">		int rowCount = 1;</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">		for (T entity : list) {</span>
<span class="fc" id="L187">			processFromEntity(entity, ProcessItemAction.FIND, rowCount);</span>
<span class="fc" id="L188">			rowCount++;</span>
<span class="fc" id="L189">		}</span>
<span class="fc" id="L190">		return list;</span>
	}

	@SuppressWarnings(&quot;rawtypes&quot;)
	private String getIdColumnName(T entity) {
<span class="fc" id="L195">		Class c = entity.getClass();</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">		for (Field field : c.getDeclaredFields()) {</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">			if (field.isAnnotationPresent(Id.class)) {</span>
<span class="fc" id="L198">				return field.getName();</span>
			}
		}

<span class="fc" id="L202">		return null;</span>
	}

	/**
	 * metoda na upravu beanu v DB na zaklade nazvu stlpca v DB @updateByColumn.
	 * @param entity
	 * @param updateByColumn
	 * @return
	 * @throws IllegalAccessException
	 * @throws NoSuchMethodException
	 * @throws InvocationTargetException
	 */
	private List&lt;T&gt; editItemByColumn(T entity, String updateByColumn) throws IllegalAccessException, NoSuchMethodException, InvocationTargetException, InstantiationException {
<span class="fc" id="L215">		beforeSave(entity);</span>

		// ziskame list entit, ktore obsahuju v stlpci updateByColumn rovnaku hodnotu ako entita
<span class="fc" id="L218">		String idColumnName = getIdColumnName(entity);</span>
<span class="fc bfc" id="L219" title="All 4 branches covered.">		if (&quot;id&quot;.equalsIgnoreCase(updateByColumn) &amp;&amp; idColumnName!=null) updateByColumn = idColumnName;</span>

<span class="fc" id="L221">		List&lt;T&gt; itemsBy = findItemBy(updateByColumn, entity);</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">		if (itemsBy.isEmpty()) {</span>
			//zmaz ID column
			try {
<span class="fc bfc" id="L225" title="All 2 branches covered.">				if (idColumnName == null) idColumnName = &quot;id&quot;;</span>
<span class="fc" id="L226">				BeanWrapperImpl bw = new BeanWrapperImpl(entity);</span>
<span class="fc" id="L227">				Long id = null;</span>
<span class="fc" id="L228">				try { bw.setPropertyValue(idColumnName, id); }</span>
<span class="pc" id="L229">				catch (Exception ex) { bw.setPropertyValue(idColumnName, 0); }</span>
<span class="fc" id="L230">			} catch (Exception ex) {</span>
				//failsafe
<span class="fc" id="L232">			}</span>
<span class="fc" id="L233">			T processed = insertItem(entity);</span>
<span class="fc" id="L234">			afterSave(entity, processed);</span>
<span class="fc" id="L235">			return Arrays.asList(processed);</span>
		}

<span class="fc" id="L238">		List&lt;T&gt; savedList = new ArrayList&lt;&gt;();</span>
		// nastavenie dat a ulozenie
<span class="fc bfc" id="L240" title="All 2 branches covered.">		for (T itemBy : itemsBy) {</span>
<span class="fc" id="L241">			long id = 0;</span>
			try {
<span class="fc" id="L243">				BeanWrapperImpl bw = new BeanWrapperImpl(itemBy);</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">				Object value = bw.getPropertyValue(idColumnName != null ? idColumnName : &quot;id&quot;);</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">				if (value instanceof Number) {</span>
<span class="fc" id="L246">					id = ((Number)value).longValue();</span>
				}
<span class="nc" id="L248">			} catch (Exception ex) {</span>
				//failsafe
<span class="fc" id="L250">			}</span>

<span class="fc" id="L252">			BeanWrapperImpl bw = new BeanWrapperImpl(entity);</span>
			//setni ID hodnotu na povodnej entite, aby sa nasledne korektne vykonala processToEntity so spravnym ID
			try {
<span class="fc" id="L255">				bw.setPropertyValue(&quot;id&quot;, Long.valueOf(id));</span>
<span class="nc" id="L256">			} catch (Exception e) {</span>
				//failsafe
<span class="fc" id="L258">			}</span>
<span class="pc bpc" id="L259" title="1 of 4 branches missed.">			if (idColumnName!=null &amp;&amp; &quot;id&quot;.equals(idColumnName)==false) {</span>
				try {
<span class="nc" id="L261">					bw.setPropertyValue(idColumnName, Long.valueOf(id));</span>
<span class="nc" id="L262">				} catch (Exception e) {</span>
					//failsafe
<span class="nc" id="L264">				}</span>
			}

<span class="fc" id="L267">			beforeSave(entity);</span>
<span class="fc" id="L268">			checkItemPermsThrows(entity, id);</span>

<span class="fc" id="L270">			T saved = editItem(entity, id);</span>

<span class="fc" id="L272">			afterSave(entity, saved);</span>

<span class="fc" id="L274">			savedList.add(saved);</span>
<span class="fc" id="L275">		}</span>

<span class="fc" id="L277">		return savedList;</span>
	}

	/**
	 * Zmaze danu entitu z databazy
	 * @param entity
	 * @param id
	 * @return
	 */
	public boolean deleteItem(T entity, long id) {
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">		if (beforeDelete(repo.getById(id))) {</span>
			try {
<span class="fc bfc" id="L289" title="All 2 branches covered.">				if (checkDomainId) {</span>
					//zmazanie pri pouziti domain_id riesime ziskanim zaznamu cez getOneItem ktore overi aj domain_id stlpec a naslednym zmazanim entity
<span class="fc" id="L291">					T fromRepo = getOneItem(id);</span>
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">					if (fromRepo != null) {</span>
<span class="fc" id="L293">						DomainIdRepository&lt;T, ID&gt; domainRepo = getDomainRepo();</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">						if (domainRepo!=null) domainRepo.delete(fromRepo);</span>
					}
<span class="fc" id="L296">				} else {</span>
<span class="fc" id="L297">					T fromRepo = getOneItem(id);</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">					if (fromRepo != null) {</span>
<span class="fc" id="L299">						repo.delete(fromRepo);</span>
					}
				}
<span class="fc" id="L302">				return true;</span>
<span class="nc" id="L303">			} catch (Exception e) {</span>
<span class="nc" id="L304">				Logger.error(DatatableRestControllerV2.class, e);</span>
			}
		}

<span class="nc" id="L308">		return false;</span>
	}

	/**
	 * Ziska z databazy entitu so zadanym id
	 * @param id
	 * @return
	 */
	public T getOneItem(long id) {
<span class="fc" id="L317">		T result = null;</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">		if (repo.existsById(id)) {</span>
<span class="fc" id="L319">			Optional&lt;T&gt; byId = Optional.empty();</span>

<span class="fc bfc" id="L321" title="All 2 branches covered.">			if (checkDomainId) {</span>
<span class="fc" id="L322">				DomainIdRepository&lt;T, ID&gt; domainRepo = getDomainRepo();</span>
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">				if (domainRepo!=null) byId = domainRepo.findFirstByIdAndDomainId(id, CloudToolsForCore.getDomainId());</span>
<span class="fc" id="L324">			} else {</span>
<span class="fc" id="L325">				byId = repo.findById(id);</span>
			}

<span class="fc bfc" id="L328" title="All 2 branches covered.">			if (byId.isPresent()) {</span>
<span class="fc" id="L329">				result = byId.get();</span>
			}
		}
<span class="fc" id="L332">		return processFromEntity(result, ProcessItemAction.GETONE, 1);</span>
	}

	/**
	 * Ziska z databazy vsetky zaznamy
	 * @param pageable
	 * @return
	 */
	public Page&lt;T&gt; getAllItems(Pageable pageable) {
<span class="fc" id="L341">		Page&lt;T&gt; page = null;</span>

<span class="fc bfc" id="L343" title="All 2 branches covered.">		if (checkDomainId) {</span>
			//volame aj s podmienkami domain_id
<span class="fc" id="L345">			DomainIdRepository&lt;T, ID&gt; domainRepo = getDomainRepo();</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">			if (domainRepo!=null) {</span>
				//ak nemame size parameter tak sa jedna o serverSide: false, takze pageable nemame pouzit
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">				if (getRequest().getParameter(&quot;size&quot;)==null) page = new DatatablePageImpl&lt;&gt;(domainRepo.findAllByDomainId(CloudToolsForCore.getDomainId()));</span>
<span class="fc" id="L349">				else page = domainRepo.findAllByDomainId(CloudToolsForCore.getDomainId(), pageable);</span>
			}
<span class="fc" id="L351">		} else {</span>
			//ak nemame size parameter tak sa jedna o serverSide: false, takze pageable nemame pouzit
<span class="fc bfc" id="L353" title="All 2 branches covered.">			if (getRequest().getParameter(&quot;size&quot;)==null) page = new DatatablePageImpl&lt;&gt;(repo.findAll());</span>
<span class="fc" id="L354">			else page = repo.findAll(pageable);</span>
		}

<span class="fc" id="L357">		processFromEntity(page, ProcessItemAction.GETALL);</span>

<span class="fc" id="L359">		return page;</span>
	}

	/**
	 * Vrati vsetky zaznamy, pricom vykona volanie metody addSpecSearch,
	 * cize je mozne pouzit URL parametre na filtrovanie vsetkych zaznamov.
	 * @param empty - prazdny objekt (je potrebny kvoli vytvoreniu instance)
	 * @param pageable
	 * @return
	 */
	public Page&lt;T&gt; getAllItemsIncludeSpecSearch(T empty, Pageable pageable) {

<span class="fc" id="L371">		Map&lt;String, String&gt; params = getParamsMap(getRequest());</span>

<span class="fc" id="L373">		return searchItem(params, pageable, empty);</span>
	}

	/**
	 * Convert URL/request parameters to Map&lt;String paramName, String paramValue&gt;
	 * @param request
	 * @return
	 */
	public static Map&lt;String, String&gt; getParamsMap(HttpServletRequest request) {
<span class="fc" id="L382">		Map&lt;String, String[]&gt; paramsMulti = request.getParameterMap();</span>
<span class="fc" id="L383">		Map&lt;String, String&gt; params = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">		for (Map.Entry&lt;String, String[]&gt; entry : paramsMulti.entrySet()) {</span>
<span class="fc" id="L385">			String[] value = entry.getValue();</span>
<span class="pc bpc" id="L386" title="2 of 4 branches missed.">			if (value != null &amp;&amp; value.length&gt;0) {</span>
<span class="fc" id="L387"> 				params.put(entry.getKey(), value[0]);</span>
			}
<span class="fc" id="L389">		}</span>
<span class="fc" id="L390">		return params;</span>
	}

	/**
	 * Vykona zadanu akciu (napr. rotacia obrazku v galerii)
	 *
	 * @param entity
	 * @param action
	 * @return false ak nastane chyba
	 */
	public boolean processAction(T entity, String action) {
<span class="nc" id="L401">		return true;</span>
	}

	/**
	 * Vykona upravy vo vsetkych entitach v page objekte pred vratenim cez REST rozhranie
	 * napr. vyvola potrebne editorFields nastavenia (from entity to editorFields)
	 * @param page
	 * @param action - typ zmeny - create,edit,getall...
	 */
	public void processFromEntity(Page&lt;T&gt; page, ProcessItemAction action) {
<span class="pc bpc" id="L411" title="1 of 4 branches missed.">		if (page == null || page.getContent()==null) { //NOSONAR</span>
<span class="fc" id="L412">			return;</span>
		}

		//pri exporte potrebujeme vsetky data z editorFields, takze sa tvarime ako rezim GETONE
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">		if (isExporting()) action = ProcessItemAction.GETONE;</span>

<span class="fc" id="L418">		int rowCount = 1;</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">		for (T entity : page.getContent()) {</span>
<span class="fc" id="L420">			processFromEntity(entity, action, rowCount);</span>
<span class="fc" id="L421">			rowCount++;</span>
<span class="fc" id="L422">		}</span>
<span class="fc" id="L423">	}</span>

	/**
	 * Vykona upravy vo vsetkych entitach v page objekte pred vratenim cez REST rozhranie
	 * napr. vyvola potrebne editorFields nastavenia (from entity to editorFields)
	 * @param entities - list entit
	 * @param action - typ zmeny - create,edit,getall...
	 */
	public void processFromEntity(List&lt;T&gt; entities, ProcessItemAction action) {
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">		if(entities == null) return;</span>

		//pri exporte potrebujeme vsetky data z editorFields, takze sa tvarime ako rezim GETONE
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">		if (isExporting()) action = ProcessItemAction.GETONE;</span>

<span class="fc" id="L437">		int rowCount = 1;</span>
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">		for (T entity : entities) {</span>
<span class="nc" id="L439">			processFromEntity(entity, action, rowCount);</span>
<span class="nc" id="L440">			rowCount++;</span>
<span class="nc" id="L441">		}</span>
<span class="fc" id="L442">	}</span>

	/**
	 * Vykona upravy v entite pred vratenim cez REST rozhranie
	 * napr. vyvola potrebne editorFields nastavenia (from entity to editorFields)
	 * @param entity
	 * @param action - typ zmeny - create,edit,getall...
	 * @param rowCount - cislo riadka v tabulke
	 */
	public T processFromEntity(T entity, ProcessItemAction action, int rowCount) {
<span class="fc" id="L452">		return processFromEntity(entity, action);</span>
	}

	/**
	 * Vykona upravy v entite pred vratenim cez REST rozhranie
	 * napr. vyvola potrebne editorFields nastavenia (from entity to editorFields)
	 * @param entity
	 * @param action - typ zmeny - create,edit,getall...
	 */
	public T processFromEntity(T entity, ProcessItemAction action) {
<span class="fc" id="L462">		return entity;</span>
	}

	/**
	 * Vykona upravy v entite pri odpovedi (ulozeni) z REST rozhranie
	 * napr. vyvola potrebne editorFields nastavenia (from editorFields to entity)
	 * @param entity
	 * @param action - typ zmeny - create,edit,getall,
	 */
	public T processToEntity(T entity, ProcessItemAction action) {
<span class="fc" id="L472">		return entity;</span>
	}


	/**
	 * Do objektu searchProperties naplni hladane vyrazy, vrati pripadne upraveny ExampleMatcher
	 * @param params
	 * @param searchProperties - vratena mapa request parametrov pre vyhladavanie
	 * @param searchWrapped
	 * @param matcher - ak sa jedna o exampleMatcher, moze byt null
	 * @param isExampleSearch
	 * @return
	 */
	public ExampleMatcher getSearchProperties(Map&lt;String, String&gt; params, Map&lt;String, String&gt; searchProperties, BeanWrapperImpl searchWrapped, ExampleMatcher matcher, boolean isExampleSearch) {

		//final Map&lt;String, String&gt; searchProperties = new HashMap&lt;&gt;();

<span class="fc bfc" id="L489" title="All 2 branches covered.">		for (Map.Entry&lt;String, String&gt; paramsEntry : params.entrySet()) {</span>
<span class="fc" id="L490">			String key = getCleanKey(paramsEntry.getKey());</span>

<span class="fc bfc" id="L492" title="All 2 branches covered.">			if (!searchWrapped.isReadableProperty(key)) {</span>
<span class="fc" id="L493">				Logger.debug(DatatableRestControllerV2.class, &quot;Property is not readable, key; &quot;+key);</span>
<span class="fc" id="L494">				continue;</span>
			}

<span class="fc" id="L497">			String value = paramsEntry.getValue();</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">			if (Tools.isEmpty(value)) continue;</span>

<span class="fc bfc" id="L500" title="All 4 branches covered.">			if (value.startsWith(&quot;range:&quot;) || value.startsWith(&quot;daterange:&quot;)) {</span>
<span class="fc" id="L501">				searchProperties.put(key, value);</span>
			}
			else {
<span class="fc" id="L504">				String cleanValue = getCleanValue(value);</span>

<span class="pc bpc" id="L506" title="1 of 2 branches missed.">				if (Tools.isEmpty(cleanValue)) {</span>
<span class="nc" id="L507">					Logger.debug(DatatableRestControllerV2.class, &quot;Value empty, key: &quot;+key+&quot;, value: &quot;+value);</span>
<span class="nc" id="L508">					continue;</span>
				}

<span class="fc bfc" id="L511" title="All 2 branches covered.">				if (isExampleSearch) {</span>
<span class="fc" id="L512">					ExampleMatcher.GenericPropertyMatcher genericPropertyMatcherFromValue = getGenericPropertyMatcherFromValue(value);</span>
<span class="fc" id="L513">					matcher = matcher.withMatcher(key, genericPropertyMatcherFromValue);</span>

<span class="fc" id="L515">					searchWrapped.setPropertyValue(key, getCleanValue(value));</span>
<span class="fc" id="L516">				} else {</span>
<span class="fc" id="L517">					searchProperties.put(key, value);</span>
				}
			}
<span class="fc" id="L520">		}</span>

<span class="fc" id="L522">		return matcher;</span>
	}

	/**
	 * Vyhlada objekty podla zadaneho search objektu a pripadnych parametrov z requestu
	 * @param params
	 * @param pageable
	 * @param search
	 * @return
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public Page&lt;T&gt; searchItem(@RequestParam Map&lt;String, String&gt; params, Pageable pageable, T search) {

		//urcenie sposobu hladania - by example alebo pomocou presnych parametrov
<span class="fc" id="L536">		boolean isExampleSearch = true;</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">		if (repo instanceof JpaSpecificationExecutor) {</span>
<span class="fc" id="L538">			isExampleSearch = false;</span>
		}

<span class="fc" id="L541">		ExampleMatcher matcher = ExampleMatcher.matchingAll();</span>

<span class="fc" id="L543">		BeanWrapperImpl searchWrapped = new BeanWrapperImpl(search);</span>

<span class="fc" id="L545">		final Map&lt;String, String&gt; searchProperties = new HashMap&lt;&gt;();</span>
<span class="fc" id="L546">		matcher = getSearchProperties(params, searchProperties, searchWrapped, matcher, isExampleSearch);</span>

		Page&lt;T&gt; page;
<span class="fc bfc" id="L549" title="All 2 branches covered.">		if (isExampleSearch) {</span>
<span class="fc" id="L550">			matcher = matcher.withIgnoreCase().withIgnoreNullValues();</span>
<span class="fc" id="L551">			Example&lt;T&gt; exampleQuery = Example.of(search, matcher);</span>

<span class="pc bpc" id="L553" title="1 of 2 branches missed.">			if (pageable != null) page = repo.findAll(exampleQuery, pageable);</span>
<span class="nc" id="L554">			else page = new DatatablePageImpl&lt;&gt;(repo.findAll(exampleQuery));</span>
<span class="fc" id="L555">		} else {</span>
<span class="fc" id="L556">			Specification&lt;T&gt; spec  = getSearchConditions(searchProperties, params, search);</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">			if (pageable != null) page = ((JpaSpecificationExecutor&lt;T&gt;)repo).findAll(spec, pageable);</span>
<span class="fc" id="L558">			else page = new DatatablePageImpl&lt;&gt;(((JpaSpecificationExecutor&lt;T&gt;)repo).findAll(spec));</span>
		}

<span class="fc" id="L561">		ProcessItemAction action = ProcessItemAction.FIND;</span>
		//pri exporte potrebujeme vsetky data z editorFields, takze sa tvarime ako rezim GETONE
<span class="fc bfc" id="L563" title="All 2 branches covered.">		if (isExporting()) action = ProcessItemAction.GETONE;</span>

<span class="fc" id="L565">		int rowCount = 1;</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">		for (T entity : page.getContent()) {</span>
<span class="fc" id="L567">			processFromEntity(entity, action, rowCount);</span>
<span class="fc" id="L568">			rowCount++;</span>
<span class="fc" id="L569">		}</span>

<span class="fc" id="L571">		return page;</span>
	}

	/**
	 * Doplni pri volani getAllItems options polozky pre vyberove polia
	 * @param page
	 */
	public void getOptions(DatatablePageImpl&lt;T&gt; page) {
		//page.addOptions(field, options, labelProperty, valueProperty, includeOriginalObject);
<span class="fc" id="L580">	}</span>

	/*************************** BEZPECNOST A VALIDACIA ****************************/

	/**
	 * Validate access to this rest controller, this is not per row/entity check
	 * @param request
	 * @return
	 */
	public boolean checkAccessAllowed(HttpServletRequest request) {
<span class="fc" id="L590">		return true;</span>
	}

	/**
	 * Check item perms, it's called with every save/delete/getOne action
	 * @param entity - current entity
	 * @param id - entity ID
	 * @param errors
	 * @return false if permissions is not allowed
	 */
	public boolean checkItemPerms(T entity, Long id) {
<span class="fc" id="L601">		return true;</span>
	}

	/**
	 * Check and throws exception if item is not allowed to edit
	 * @param entity
	 * @param id
	 */
	private void checkItemPermsThrows(T entity, Long id) {
<span class="fc" id="L610">		boolean valid = checkItemPerms(entity, id);</span>
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">		if (valid==false) throwConstraintViolation(getProp().getText(&quot;components.file_archiv.file_rename.nemate_pravo_na_tuto_editaciu&quot;));</span>
<span class="fc" id="L612">	}</span>

	/**
	 * Pripravena metoda, odporucame implementovat v child triede.
	 * Metoda je volana pre kazdy odoslaby objekt.
	 * Chyby pridava do error objeku pomocou {@link Errors}.rejectValue
	 *
	 * @param request
	 * @param user
	 * @param errors
	 * @param id
	 * @param entity
	 */
<span class="fc" id="L625">	public void validateEditor(HttpServletRequest request, DatatableRequest&lt;Long, T&gt; target, Identity user, Errors errors, Long id, T entity) {}</span>

	/**
	 * Metoda volana pred zmazanim enity z DB, moze vykonat dodatocne akcie
	 * napr. zmazanie suborov z disku, ulozenie do archivu,
	 * alebo specialne kontroly prav
	 * @param entity
	 * @return
	 */
	public boolean beforeDelete(T entity) {
<span class="fc" id="L635">		return true;</span>
	}

	/**
	 * Metoda volana pred insert/save danej entity,
	 * da sa pouzit na nastavenie udajov, napr. datum ulozenia, domainId a podobne
	 * @param entity
	 */
	public void beforeSave(T entity) {

<span class="fc" id="L645">	}</span>

	/**
	 * Metoda volana pred duplikovanim danej entity,
	 * da sa pouzit na resetovanie udajov, napr. priradena default stranka adresara a podobne
	 * @param entity
	 */
	public void beforeDuplicate(T entity) {

<span class="fc" id="L654">	}</span>

	/**
	 * Metoda volana po duplikovanim danej entity,
	 * da sa pouzit na dokopirovanie udajov, napr. media web stranky
	 * @param entity - novo ulozena (zduplikovana) entita
	 * @param originalId - ID povodneho zaznamu ktory sa duplikoval
	 */
	public void afterDuplicate(T entity, Long originalId) {

<span class="fc" id="L664">	}</span>

	/**
	 * Metoda volana po ulozeni entity.
	 * POZOR: pre novo vytvaranu entitu bude jej ID ulozene len v saved entite, povodna entity bude mat ID=0
	 * @param entity - povodna odoslana entita
	 * @param saved - uz ulozena verzia entity
	 */
	public void afterSave(T entity, T saved) {

<span class="fc" id="L674">	}</span>

	/**
	 * Metoda volana po zmazanim enity z DB, moze vykonat dodatocne akcie
	 * napr. zmazanie suborov z disku, ulozenie do archivu,
	 * alebo obnovu cache objektov
	 * @param entity
	 * @return
	 */
	public void afterDelete(T entity, long id) {

<span class="fc" id="L685">	}</span>

	/**
	 * Metoda sa vola pri importe po kazdom chunku
	 * @param chunk - aktualny chunk
	 * @param totalChunks - celkovy pocet chunkov
	 */
	public void afterImportChunk(int chunk, int totalChunks) {

<span class="fc" id="L694">	}</span>


	/************************** PRIVATNE / SUPPORT metody***************************/

	private ExampleMatcher.GenericPropertyMatcher getGenericPropertyMatcherFromValue(String value) {
<span class="pc bpc" id="L700" title="3 of 4 branches missed.">		if (value.startsWith(&quot;^&quot;) &amp;&amp; value.endsWith(&quot;$&quot;)) {</span>
<span class="nc" id="L701">			return ExampleMatcher.GenericPropertyMatchers.exact();</span>
<span class="pc bpc" id="L702" title="1 of 2 branches missed.">		} else if (value.startsWith(&quot;^&quot;)) {</span>
<span class="nc" id="L703">			return ExampleMatcher.GenericPropertyMatchers.startsWith();</span>
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">		} else if (value.endsWith(&quot;$&quot;)) {</span>
<span class="nc" id="L705">			return ExampleMatcher.GenericPropertyMatchers.endsWith();</span>
<span class="pc bpc" id="L706" title="1 of 2 branches missed.">		} else if (value.startsWith(REGEX_PREFIX)) {</span>
<span class="nc" id="L707">			return ExampleMatcher.GenericPropertyMatchers.regex();</span>
		}
<span class="fc" id="L709">		return ExampleMatcher.GenericPropertyMatchers.contains();</span>
	}

	public static String getCleanKey(String key) {
<span class="fc" id="L713">		return firstToLower(Tools.replace(key, &quot;search&quot;, &quot;&quot;));</span>
	}

	public static String getCleanValue(String value) {
<span class="fc" id="L717">		String result = value;</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">		if (result.length() &gt;= 2) {</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">			if (result.startsWith(&quot;^&quot;))</span>
<span class="fc" id="L720">				result = result.substring(1);</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">			if (result.endsWith(&quot;$&quot;))</span>
<span class="fc" id="L722">				result = result.substring(0, result.length() - 1);</span>
		}
<span class="pc bpc" id="L724" title="3 of 4 branches missed.">		if (result.startsWith(REGEX_PREFIX) &amp;&amp; result.length() &gt; REGEX_PREFIX.length())</span>
<span class="nc" id="L725">			result = result.substring(REGEX_PREFIX.length());</span>

<span class="fc" id="L727">		return result;</span>
	}

	private static String firstToLower(String value) {
<span class="pc bpc" id="L731" title="2 of 4 branches missed.">		if (value == null || value.length() == 0) {</span>
<span class="nc" id="L732">			return &quot;&quot;;</span>
		}

<span class="fc" id="L735">		char[] chArr = value.toCharArray();</span>
<span class="fc" id="L736">		chArr[0] = Character.toLowerCase(chArr[0]);</span>

<span class="fc" id="L738">		return new String(chArr);</span>
	}

	/**
	 * metoda na validovanie dat z editora, vola metodu validateEditor nejprv ak existuje tak z child objektu, ak nie tak z tohto
	 * validateEditor sa vola pre kazdy objekt v requeste.
	 * @param request
	 * @param binder
	 * @throws IllegalAccessException
	 */
	@InitBinder
	protected void initBinder(HttpServletRequest request, WebDataBinder binder)
	{
<span class="fc" id="L751">		String requestURI = request.getRequestURI();</span>
<span class="fc bfc" id="L752" title="All 2 branches covered.">		if (requestURI.endsWith(&quot;/editor&quot;)) {</span>
			@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L754">			DatatableRequest&lt;Long, T&gt; target = (DatatableRequest&lt;Long, T&gt;) binder.getTarget();</span>
<span class="fc bfc" id="L755" title="All 2 branches covered.">			if (target != null) {</span>
				//clear thread data
<span class="fc" id="L757">				getThreadData().setInvalidImportedRows(null);</span>
<span class="fc" id="L758">				getThreadData().setInvalidImportedRowsErrors(null);</span>
<span class="fc" id="L759">				getThreadData().clearNotifyList();</span>

<span class="fc" id="L761">				Map&lt;Long, T&gt; data = target.getData();</span>
<span class="fc" id="L762">				BindingResult bindingResult = binder.getBindingResult();</span>
<span class="fc" id="L763">				Identity currentUser = UsersDB.getCurrentUser(request);</span>
<span class="pc bpc" id="L764" title="1 of 2 branches missed.">				if (data != null) {</span>
<span class="fc" id="L765">					Set&lt;Long&gt; invalidImportedRows = new HashSet&lt;&gt;();</span>
<span class="fc" id="L766">					setSkipWrongData( target.isSkipWrongData() );</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">					for (Map.Entry&lt;Long, T&gt; galleryEntityEntry : data.entrySet()) {</span>
<span class="fc" id="L768">						Long key = galleryEntityEntry.getKey();</span>
<span class="fc" id="L769">						T value = galleryEntityEntry.getValue();</span>

						//zial, nefunguje inak nastavovanie errorov ako na konkretny field, takze to fejkujeme takymto objektom
						//moze to robit haluze pri editacii viacerych objektov naraz, u nas ale pouzivame len spolocne atributy, takze by to mohlo fungovat aj tam
<span class="fc" id="L773">						target.setErrorField(value);</span>

<span class="fc bfc" id="L775" title="All 2 branches covered.">						if (target.getDztotalchunkcount()&gt;0) {</span>
<span class="fc" id="L776">							setImporting(true);</span>
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">							if (target.getDzchunkindex()&gt;0) setLastImportedRow(target.getDzchunkindex()*Constants.getInt(&quot;chunksQuantity&quot;));</span>
<span class="fc" id="L778">							else setLastImportedRow(null);</span>
						} else {
<span class="fc" id="L780">							setImporting(false);</span>
						}

<span class="fc" id="L783">						setImportedColumns(target.getImportedColumns());</span>

						//Use separe binding result
<span class="fc" id="L786">						BeanPropertyBindingResult entityBindingResult = new BeanPropertyBindingResult(binder.getTarget(), binder.getObjectName());</span>
<span class="fc" id="L787">						validateEditor(request, target, currentUser, entityBindingResult, key, value);</span>

						//If we DON'T WANT skip wrong data, push error back into main binding result
<span class="fc bfc" id="L790" title="All 2 branches covered.">						if(isSkipWrongData() == false) {</span>
<span class="fc" id="L791">							bindingResult.addAllErrors(entityBindingResult);</span>
						} else {
							//We skipped wrong data, but use errors for user notification
<span class="fc bfc" id="L794" title="All 2 branches covered.">							if(entityBindingResult.getErrorCount() &gt; 0) {</span>
<span class="fc" id="L795">								invalidImportedRows.add(key);</span>

<span class="fc" id="L797">								addImportedColumnError( entityBindingResult.getFieldErrors().get(0), key.intValue() );</span>
							}
						}
<span class="fc" id="L800">					}</span>

					//Set which rows are invalid
<span class="fc bfc" id="L803" title="All 2 branches covered.">					if(isSkipWrongData() == true) {</span>
<span class="fc" id="L804">						setInvalidImportedRows(invalidImportedRows);</span>
					}
				}

<span class="fc bfc" id="L808" title="All 2 branches covered.">				if (bindingResult.hasFieldErrors()) {</span>
					//vyhod este globalnu error hlasku, aby sa zobrazila aj pri tlacitkach a user si preklikal taby na konkretne chyby
<span class="fc" id="L810">					bindingResult.addError(new ObjectError(&quot;global&quot;, Prop.getInstance(request).getText(&quot;datatable.error.fieldErrorMessage&quot;)));</span>
				}
			}
		}
<span class="fc" id="L814">	}</span>


    private static java.lang.reflect.Field getDeclaredFiledRecursive(Class&lt;?&gt; initialClass, String fieldName) throws NoSuchFieldException {
<span class="fc" id="L818">        java.lang.reflect.Field field = null;</span>
<span class="fc" id="L819">        int failsafe=0;</span>
<span class="fc" id="L820">        Class&lt;?&gt; targetClass = initialClass;</span>
<span class="pc bpc" id="L821" title="2 of 4 branches missed.">        while (targetClass != null &amp;&amp; failsafe++&lt;15) {</span>
            try {
<span class="fc" id="L823">                field = targetClass.getDeclaredField(fieldName);</span>
<span class="pc bpc" id="L824" title="1 of 2 branches missed.">                if(field != null) return field;</span>
<span class="pc" id="L825">            } catch (NoSuchFieldException e) {}</span>
            // Field not found in current class, continue to superclass
<span class="fc" id="L827">            targetClass = targetClass.getSuperclass();</span>
        }

<span class="nc" id="L830">       throw new NoSuchFieldException(&quot;Field &quot; + fieldName + &quot; not found in class &quot; + initialClass + &quot; or in super classes&quot;);</span>
    }

	private static boolean isFieldType(Class&lt;?&gt; initialClass, String fieldNam, DataTableColumnType type) {
<span class="fc" id="L834">		boolean isProvidedType = false;</span>
		try {
<span class="fc" id="L836">			java.lang.reflect.Field field = getDeclaredFiledRecursive(initialClass, fieldNam);</span>
<span class="pc bpc" id="L837" title="1 of 2 branches missed.">			if (field.isAnnotationPresent(sk.iway.iwcm.system.datatable.annotations.DataTableColumn.class)) {</span>
<span class="fc" id="L838">				DataTableColumnType[] inputType = field.getAnnotation(sk.iway.iwcm.system.datatable.annotations.DataTableColumn.class).inputType();</span>

				//Check if field inputType is equal with provided inputType
<span class="pc bpc" id="L841" title="2 of 4 branches missed.">				if(inputType != null &amp;&amp; inputType.length &gt; 0)</span>
<span class="fc" id="L842">					isProvidedType = inputType[0].equals(type);</span>
			}
<span class="nc" id="L844">		} catch(Exception e) {</span>
			//Do nothing
<span class="fc" id="L846">		}</span>

<span class="fc" id="L848">		return isProvidedType;</span>
	}

	/**
	 * Vytvori zoznam predikatov pre vyhladavanie
	 * @param properties - ocisteny zoznam params o atributy, ktore sa nechachadzaju v T
	 * @param example - kompletny zoznam request parametrov, vratane pagingu
	 * @return
	 */
	protected Specification&lt;T&gt; getSearchConditions(Map&lt;String, String&gt; properties, Map&lt;String, String&gt; params, T entity) {
<span class="fc" id="L858">		return (Specification&lt;T&gt;) (root, query, builder) -&gt; {</span>
<span class="fc" id="L859">			final List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L861" title="All 2 branches covered.">			for (Map.Entry&lt;String, String&gt; paramsEntry : properties.entrySet()) {</span>
<span class="fc" id="L862">				String field = paramsEntry.getKey();</span>
<span class="fc" id="L863">				String value = paramsEntry.getValue();</span>

				//toto sa hlada v addSpecSearch
<span class="fc bfc" id="L866" title="All 2 branches covered.">				if (&quot;perexGroups&quot;.equals(field)) continue;</span>

<span class="fc bfc" id="L868" title="All 2 branches covered.">				if (value.startsWith(&quot;daterange:&quot;)) {</span>
<span class="fc" id="L869">					Timestamp from = null;</span>
<span class="fc" id="L870">					Timestamp to = null;</span>
<span class="fc" id="L871">					String[] values = Tools.getTokens(value.substring(value.indexOf(&quot;:&quot;)+1), &quot;-&quot;);</span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">					if (values.length==2) {</span>
<span class="fc" id="L873">						from = new Timestamp(Tools.getLongValue(values[0], 0));</span>
<span class="fc" id="L874">						to = new Timestamp(Tools.getLongValue(values[1], 0));</span>
<span class="pc bpc" id="L875" title="1 of 2 branches missed.">					} else if (values.length==1) {</span>
						//ked nemame from pride to ako: daterange:-1589666400000
<span class="pc bpc" id="L877" title="1 of 2 branches missed.">						if (value.contains(&quot;range:-&quot;)) to = new Timestamp(Tools.getLongValue(values[0], 0));</span>
<span class="fc" id="L878">						else from = new Timestamp(Tools.getLongValue(values[0], 0));</span>
					}

					//Ak sa jedna o DATETIME, ta žiadnu úpravu nespravíme (používateľ nech si časovú zložku nastaví sám)
					//Ak sa jedná o DATE, tak nastavíme časovú zložku FROM na 00:00:00 a TO na 23:59:59
<span class="fc" id="L883">					boolean isDate = isFieldType(entity.getClass(), field, DataTableColumnType.DATE);</span>

<span class="pc bpc" id="L885" title="1 of 4 branches missed.">					if(isDate &amp;&amp; from != null) {</span>
<span class="fc" id="L886">						Calendar cal = Calendar.getInstance();</span>
<span class="fc" id="L887">						cal.setTime(from);</span>
<span class="fc" id="L888">						cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="fc" id="L889">						cal.set(Calendar.MINUTE, 0);</span>
<span class="fc" id="L890">						cal.set(Calendar.SECOND, 0);</span>
<span class="fc" id="L891">						from = new Timestamp( cal.getTimeInMillis() );</span>
					}

<span class="fc bfc" id="L894" title="All 4 branches covered.">					if(isDate &amp;&amp; to != null) {</span>
<span class="fc" id="L895">						Calendar cal = Calendar.getInstance();</span>
<span class="fc" id="L896">						cal.setTime(to);</span>
						//set to begining of next day because we will use lessThan
<span class="fc" id="L898">						cal.add(Calendar.DATE, 1);</span>
<span class="fc" id="L899">						cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="fc" id="L900">						cal.set(Calendar.MINUTE, 0);</span>
<span class="fc" id="L901">						cal.set(Calendar.SECOND, 0);</span>
<span class="fc" id="L902">						to = new Timestamp( cal.getTimeInMillis() );</span>
					}

<span class="fc" id="L905">					sk.iway.iwcm.Logger.debug(DatatableRestControllerV2.class, &quot;Daterange from=&quot;+Tools.formatDateTimeSeconds(from)+&quot; to=&quot;+Tools.formatDateTimeSeconds(to)+&quot; original=&quot;+value);</span>

<span class="pc bpc" id="L907" title="1 of 2 branches missed.">					if (from != null) predicates.add(builder.greaterThanOrEqualTo(root.get(field), from));</span>
<span class="fc bfc" id="L908" title="All 2 branches covered.">					if (to != null) predicates.add(builder.lessThan(root.get(field), to));</span>
<span class="fc bfc" id="L909" title="All 2 branches covered.">				} else if (value.startsWith(&quot;range:&quot;)) {</span>
<span class="fc" id="L910">					BigDecimal from = null;</span>
<span class="fc" id="L911">					BigDecimal to = null;</span>
<span class="fc" id="L912">					String[] values = Tools.getTokens(value.substring(value.indexOf(&quot;:&quot;)+1), &quot;-&quot;);</span>
<span class="pc bpc" id="L913" title="1 of 2 branches missed.">					if (values.length==2) {</span>
<span class="nc" id="L914">						from = Tools.getBigDecimalValue(values[0], &quot;0&quot;);</span>
<span class="nc" id="L915">						to = Tools.getBigDecimalValue(values[1], &quot;0&quot;);</span>
<span class="pc bpc" id="L916" title="1 of 2 branches missed.">					} else if (values.length==1) {</span>
						//ked nemame from pride to ako: daterange:-1589666400000
<span class="pc bpc" id="L918" title="1 of 2 branches missed.">						if (value.contains(&quot;range:-&quot;)) to = Tools.getBigDecimalValue(values[0], &quot;0&quot;);</span>
<span class="fc" id="L919">						else from = Tools.getBigDecimalValue(values[0], &quot;0&quot;);</span>
					}

<span class="fc" id="L922">					sk.iway.iwcm.Logger.debug(DatatableRestControllerV2.class, &quot;Range from=&quot;+from+&quot; to=&quot;+to+&quot; original=&quot;+value);</span>

<span class="pc bpc" id="L924" title="1 of 2 branches missed.">					if (from != null) predicates.add(builder.greaterThanOrEqualTo(root.get(field), from));</span>
<span class="pc bpc" id="L925" title="1 of 2 branches missed.">					if (to != null) predicates.add(builder.lessThanOrEqualTo(root.get(field), to));</span>
<span class="fc" id="L926">				} else {</span>
					try {
						//skus ziskat field, ak to padne na IllegalArgumentException tak neexistuje, nevadi, ignorujeme
						@SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L930">						Path path = root.get(field);</span>

						//toto nefunguje dobre
						//path.getJavaType().isInstance(Boolean.class) - aj ked je Boolean vrati false
						//toto funguje
						//path.getJavaType().isAssignableFrom(Boolean.class)

<span class="fc" id="L937">						String simpleName = path.getJavaType().getSimpleName();</span>

<span class="pc bpc" id="L939" title="1 of 2 branches missed.">						if (&quot;null&quot;.equals(value)) {</span>
<span class="nc" id="L940">							predicates.add(builder.isNull(root.get(field)));</span>
<span class="fc bfc" id="L941" title="All 2 branches covered.">						} else if (simpleName.equalsIgnoreCase(&quot;Boolean&quot;)) {</span>
<span class="fc" id="L942">							predicates.add(builder.equal(root.get(field), Boolean.valueOf(value)));</span>
<span class="fc bfc" id="L943" title="All 4 branches covered.">						} else if (simpleName.equalsIgnoreCase(&quot;Integer&quot;) || simpleName.equalsIgnoreCase(&quot;int&quot;)) {</span>
<span class="fc" id="L944">							predicates.add(builder.equal(root.get(field), Integer.valueOf(value)));</span>
<span class="fc bfc" id="L945" title="All 2 branches covered.">						} else if (simpleName.equalsIgnoreCase(&quot;Long&quot;)) {</span>
<span class="fc" id="L946">							predicates.add(builder.equal(root.get(field), Long.valueOf(value)));</span>
<span class="pc bpc" id="L947" title="1 of 2 branches missed.">						} else if (simpleName.equalsIgnoreCase(&quot;Double&quot;)) {</span>
<span class="nc" id="L948">							predicates.add(builder.equal(root.get(field), Double.valueOf(value)));</span>
						} else {

<span class="fc bfc" id="L951" title="All 4 branches covered.">							if (value.startsWith(&quot;^&quot;) &amp;&amp; value.endsWith(&quot;$&quot;)) predicates.add(builder.equal(root.get(field), value.substring(1, value.length()-1)));</span>
							else {
<span class="fc bfc" id="L953" title="All 2 branches covered.">								if (value.startsWith(&quot;^&quot;)) value = value.substring(1)+&quot;%&quot;;</span>
<span class="fc bfc" id="L954" title="All 2 branches covered.">								else if (value.endsWith(&quot;$&quot;)) value = &quot;%&quot;+value.substring(0, value.length()-1);</span>
<span class="fc" id="L955">								else value = &quot;%&quot;+value+&quot;%&quot;;</span>

<span class="pc bpc" id="L957" title="3 of 4 branches missed.">								if (Constants.DB_TYPE==Constants.DB_ORACLE &amp;&amp; isJpaLowerField(field)) {</span>
<span class="nc" id="L958">									predicates.add(builder.like(builder.lower(root.get(field)), value.toLowerCase()));</span>
<span class="pc bpc" id="L959" title="1 of 2 branches missed.">								} else if (Constants.DB_TYPE==Constants.DB_PGSQL) {</span>
<span class="nc" id="L960">									predicates.add(builder.like(builder.lower(builder.function(&quot;unaccent&quot;, String.class, root.get(field))), DB.internationalToEnglish(value).toLowerCase()));</span>
								} else {
<span class="fc" id="L962">									predicates.add(builder.like(root.get(field), value));</span>
								}
							}
						}
<span class="fc" id="L966">					} catch (IllegalArgumentException e) {</span>
						//failsafe
<span class="fc" id="L968">					}</span>
				}
<span class="fc" id="L970">			}</span>

			//pridaj do vyhladavania automaticky podmienku podla domain_id ak je potrebna
<span class="fc bfc" id="L973" title="All 2 branches covered.">			if (checkDomainId) predicates.add(builder.equal(root.get(&quot;domainId&quot;), CloudToolsForCore.getDomainId()));</span>

<span class="fc" id="L975">			addSpecSearch(params, predicates, root, builder);</span>

<span class="fc" id="L977">			return builder.and(predicates.toArray(new Predicate[predicates.size()]));</span>
		};
	}

	/**
	 * Doplnenie pecialneho vyhladavanie, interne vola:
	 * - addSpecSearchUserFullName(searchUserFullName, &quot;userId&quot;, predicates, root, builder);
	 * @param params
	 * @param predicates
	 */
	public void addSpecSearch(Map&lt;String, String&gt; params, List&lt;Predicate&gt; predicates, Root&lt;T&gt; root, CriteriaBuilder builder) {

		//v DB entite mame bezne len userId a pridavame tam entitu userFullName, defaultne ked existuje parameter searchUserFullName tak hladaj podla userId
<span class="fc" id="L990">		String searchUserFullName = params.get(&quot;searchUserFullName&quot;);</span>
<span class="fc bfc" id="L991" title="All 2 branches covered.">		if (Tools.isNotEmpty(searchUserFullName)) {</span>
<span class="fc" id="L992">			SpecSearch&lt;T&gt; specSearch = new SpecSearch&lt;&gt;();</span>
			//ziskaj zoznam IDecok userov, ktory maju dane meno
<span class="fc" id="L994">			specSearch.addSpecSearchUserFullName(searchUserFullName, &quot;userId&quot;, predicates, root, builder);</span>

		}

		//vyhladavanie na zaklade stavu
<span class="fc" id="L999">		String statusSearch = params.get(&quot;searchEditorFields.statusIcons&quot;);</span>
<span class="fc bfc" id="L1000" title="All 2 branches covered.">		if (Tools.isNotEmpty(statusSearch)) {</span>
<span class="fc" id="L1001">			SpecSearch&lt;T&gt; specSearch = new SpecSearch&lt;&gt;();</span>
<span class="fc" id="L1002">			specSearch.addSpecSearchStatusIcons(statusSearch, predicates, root, builder);</span>
		}

		//vyhladavanie podla perexSkupiny
<span class="fc" id="L1006">		String searchPerexGroups = params.get(&quot;searchPerexGroups&quot;);</span>
<span class="fc bfc" id="L1007" title="All 2 branches covered.">		if (Tools.isNotEmpty(searchPerexGroups)) {</span>
<span class="fc" id="L1008">			SpecSearch&lt;T&gt; specSearch = new SpecSearch&lt;&gt;();</span>
			//ziskaj zoznam IDecok userov, ktory maju dane meno
<span class="fc" id="L1010">			specSearch.addSpecSearchPerexGroup(searchPerexGroups, &quot;perexGroups&quot;, predicates, root, builder);</span>

		}
<span class="fc" id="L1013">	}</span>

	/********************************* REST METODY *********************************/

	/**
	 * Vrati vsetky zaznamy v datatabaze (serverovo strankovane a sortovane)
	 */
	@PreAuthorize(value = &quot;@WebjetSecurityService.checkAccessAllowedOnController(this)&quot;)
	@GetMapping(&quot;/all&quot;)
	public Page&lt;T&gt; getAll(Pageable pageable) {
<span class="fc" id="L1023">		clearThreadData();</span>
<span class="fc bfc" id="L1024" title="All 2 branches covered.">		if (&quot;true&quot;.equals(request.getParameter(&quot;export&quot;))) {</span>
<span class="fc" id="L1025">			setExporting(true);</span>
<span class="fc" id="L1026">			Adminlog.add(Adminlog.TYPE_FORM_EXPORT, request.getRequestURI(),-1, -1);</span>
		}
		else {
<span class="fc" id="L1029">			setExporting(false);</span>
		}

<span class="fc" id="L1032">		Page&lt;T&gt; page = this.getAllItems(pageable);</span>

		//napln options
		DatatablePageImpl&lt;T&gt; pageImpl;
<span class="fc bfc" id="L1036" title="All 2 branches covered.">		if (page instanceof DatatablePageImpl) {</span>
			//uz je to impl, moze mat nejake options uz setnute
<span class="fc" id="L1038">			pageImpl = (DatatablePageImpl&lt;T&gt;)page;</span>
		} else {
<span class="fc" id="L1040">			pageImpl = new DatatablePageImpl&lt;&gt;(page);</span>
		}
<span class="fc" id="L1042">		this.getOptions(pageImpl);</span>

<span class="fc" id="L1044">		pageImpl.setNotify(getThreadData().getNotify());</span>

<span class="fc" id="L1046">		return pageImpl;</span>
	}

	/**
	 * Vyhlada zaznamy v databaze podla zadanych kriterii (serverovo strankovane a sortovane).
	 * Pouziva EampleMatcher, v Beane NESMU BYT pouzite primitivne typy (vsetko musia byt Objekty)
	 */
	@PreAuthorize(value = &quot;@WebjetSecurityService.checkAccessAllowedOnController(this)&quot;)
	@GetMapping(&quot;/search/findByColumns&quot;)
	public Page&lt;T&gt; findByColumns(@RequestParam Map&lt;String, String&gt; params, Pageable pageable, T search) {
<span class="fc" id="L1056">		clearThreadData();</span>
<span class="fc bfc" id="L1057" title="All 2 branches covered.">		if (&quot;true&quot;.equals(request.getParameter(&quot;export&quot;))) {</span>
<span class="fc" id="L1058">			setExporting(true);</span>
<span class="fc" id="L1059">			Adminlog.add(Adminlog.TYPE_FORM_EXPORT, request.getRequestURI(),-1, -1);</span>
		}
		else {
<span class="fc" id="L1062">			setExporting(false);</span>
		}
<span class="fc" id="L1064">		return searchItem(params, pageable, search);</span>
	}

	/**
	 * Edit import data. For example, set id to -1 if you want to change update to create.
	 *
	 * @param request
	 * @param data
	 * @param importMode
	 * @return
	 */
	public Map&lt;Long, T&gt; preImportDataEdit(HttpServletRequest request, Map&lt;Long, T&gt; data, String importMode) {
<span class="fc" id="L1076">		return data;</span>
	}

	/**
	 * Ulozenie zaznamu do DB vo formate posielanom Datatables Editor, moze naraz zapisat viac zaznamov
	 */
	@PreAuthorize(value = &quot;@WebjetSecurityService.checkAccessAllowedOnController(this)&quot;)
	@PostMapping(value = &quot;/editor&quot;, consumes = MediaType.APPLICATION_JSON_VALUE)
	public ResponseEntity&lt;DatatableResponse&lt;T&gt;&gt; handleEditor(HttpServletRequest request, @RequestBody DatatableRequest&lt;Long, T&gt; datatableRequest) {
<span class="fc" id="L1085">		boolean isImporting = isImporting();</span>
<span class="fc" id="L1086">		Integer lastImportedRow = getLastImportedRow();</span>
<span class="fc" id="L1087">		List&lt;NotifyBean&gt; notifyListBeforeClear = getThreadData().getNotify();</span>

		//SKIP wrong data support variables
<span class="fc" id="L1090">		boolean skipWrongData = datatableRequest.isSkipWrongData();</span>
<span class="fc" id="L1091">		Set&lt;Long&gt; invalidImportedRows = getInvalidImportedRows();</span>
<span class="fc" id="L1092">		TreeMap&lt;Integer, String&gt; invalidImportedRowsErrors = getThreadData().getInvalidImportedRowsErrors();</span>

<span class="fc" id="L1094">		clearThreadData();</span>
<span class="fc bfc" id="L1095" title="All 2 branches covered.">		if (isImporting) {</span>
<span class="fc" id="L1096">			setImporting(true);</span>
<span class="fc" id="L1097">			setSkipWrongData(skipWrongData);</span>
			//pri importe moze vykonat converter nastavenie nejakych notifikacii, pre istotu takto zachovame
<span class="pc bpc" id="L1099" title="3 of 4 branches missed.">			if (notifyListBeforeClear!=null &amp;&amp; notifyListBeforeClear.isEmpty()==false) addNotify(notifyListBeforeClear);</span>
		}

<span class="fc" id="L1102">		DatatableResponse&lt;T&gt; response = new DatatableResponse&lt;&gt;();</span>

<span class="pc bpc" id="L1104" title="1 of 2 branches missed.">		if (datatableRequest.isDeleteOldData()) {</span>
			//je potrebne sa zamysliet nad bezpecnostou, zatial schovane aj v UI
			//repo.deleteAll();
		}

<span class="fc" id="L1109">		setForceReload(false);</span>
<span class="fc" id="L1110">		setImportedColumns(datatableRequest.getImportedColumns());</span>

<span class="fc" id="L1112">		String updateByColumn = datatableRequest.getUpdateByColumn();</span>
<span class="fc" id="L1113">		getThreadData().setUpdateByColumn(updateByColumn);</span>

<span class="fc" id="L1115">		String importMode = datatableRequest.getImportMode();</span>
<span class="fc" id="L1116">		getThreadData().setImportMode(importMode);</span>

<span class="fc bfc" id="L1118" title="All 2 branches covered.">		if(isImporting == true) datatableRequest.setData( preImportDataEdit(request, datatableRequest.getData(), importMode) );</span>

<span class="fc" id="L1120">		int rowCounter = 0;</span>
<span class="pc bpc" id="L1121" title="1 of 4 branches missed.">		if (isImporting &amp;&amp; lastImportedRow!=null) rowCounter = lastImportedRow.intValue();</span>
<span class="fc bfc" id="L1122" title="All 2 branches covered.">		for (Long id : datatableRequest.getData().keySet()) {</span>
<span class="fc" id="L1123">			rowCounter++;</span>

			//This row was marked as invalid, skip it
<span class="pc bpc" id="L1126" title="1 of 6 branches missed.">			if(isImporting() &amp;&amp; skipWrongData == true &amp;&amp; invalidImportedRows.contains(id)) {</span>
				//Mark row
<span class="fc" id="L1128">				setLastImportedRow(rowCounter);</span>
<span class="fc" id="L1129">				continue;</span>
			}

<span class="fc" id="L1132">			T entity = datatableRequest.getData().get(id);</span>

<span class="fc bfc" id="L1134" title="All 2 branches covered.">			if (entity instanceof ActiveRecordBase) {</span>
<span class="fc" id="L1135">				Integer rowNum = ((ActiveRecordBase)entity).get__rowNum__();</span>
<span class="fc" id="L1136">				setLastImportedRow(rowNum);</span>
<span class="fc" id="L1137">			} else {</span>
<span class="fc bfc" id="L1138" title="All 2 branches covered.">				if (isImporting()) setLastImportedRow(rowCounter);</span>
<span class="fc" id="L1139">				else setLastImportedRow(null);</span>
			}

			//tu nepouzijeme podmienku checkDomainId, aby sa domainId nastavilo vzdy a nezostalo NULL/0 aj ked je aktualne enableStaticFilesExternalDir vypnute (napr. na produkcii)
<span class="fc bfc" id="L1143" title="All 2 branches covered.">			if (repo instanceof DomainIdRepository) {</span>
				//over, ci entita ma property domainId a ci sedi voci aktualnemu CloudToolsForCore.getDomainId()
<span class="fc" id="L1145">				BeanWrapperImpl bw = new BeanWrapperImpl(entity);</span>
<span class="fc" id="L1146">				Integer domainId = (Integer)bw.getPropertyValue(&quot;domainId&quot;);</span>
<span class="fc bfc" id="L1147" title="All 6 branches covered.">				if (domainId == null || domainId.intValue()&lt;1 || datatableRequest.isInsert()) {</span>
					//domainId nie je nastavene, setni na aktualnu hodnotu
<span class="fc" id="L1149">					domainId = CloudToolsForCore.getDomainId();</span>
<span class="fc" id="L1150">					bw.setPropertyValue(&quot;domainId&quot;, domainId);</span>
				} else {
<span class="pc bpc" id="L1152" title="1 of 2 branches missed.">					if (CloudToolsForCore.getDomainId() != domainId.intValue()) {</span>
						//domainId nesedi, je to nejaka manipulacia s datami, vyhod chybu
<span class="nc" id="L1154">						throwError(&quot;datatables.error.domainId&quot;);</span>
					}
				}
			}

<span class="fc" id="L1159">			boolean isDuplicate = false;</span>
<span class="fc bfc" id="L1160" title="All 2 branches covered.">			if (datatableRequest.isInsert()) {</span>
				try {
<span class="fc bfc" id="L1162" title="All 2 branches covered.">					if (id&gt;0) {</span>
						//jedna sa o duplikovanie, musime zrusit hodnotu ID property
<span class="fc" id="L1164">						String propertyName = &quot;id&quot;;</span>
<span class="fc bfc" id="L1165" title="All 2 branches covered.">						for (Field field : entity.getClass().getDeclaredFields()) {</span>
<span class="fc bfc" id="L1166" title="All 2 branches covered.">							if (field.isAnnotationPresent(sk.iway.iwcm.system.datatable.annotations.DataTableColumn.class)) {</span>
<span class="fc" id="L1167">								DataTableColumnType[] inputType = field.getAnnotation(sk.iway.iwcm.system.datatable.annotations.DataTableColumn.class).inputType();</span>
<span class="pc bpc" id="L1168" title="1 of 4 branches missed.">								if (inputType.length&gt;0 &amp;&amp; inputType[0]==DataTableColumnType.ID) {</span>
<span class="fc" id="L1169">									propertyName = field.getName();</span>
<span class="fc" id="L1170">									break;</span>
								}
							}
						}

<span class="fc" id="L1175">						Long lnull = null;</span>
<span class="fc" id="L1176">						Long inull = null;</span>
						try {
							//musime ist takto, pretoze na lombok triedach BeanUtils nic nespravi
<span class="fc" id="L1179">							String methodName = &quot;set&quot;+propertyName.substring(0,1).toUpperCase()+propertyName.substring(1);</span>
<span class="fc" id="L1180">							Method setId = entity.getClass().getMethod(methodName, Long.class);</span>
<span class="fc" id="L1181">							setId.invoke(entity, lnull);</span>
<span class="fc" id="L1182">						} catch (Exception e) {</span>
							try {
								//na starych WJ triedach je potrebne nastavit integer hodnotu, napr. setTempId(0)
<span class="fc" id="L1185">								String methodName = &quot;set&quot;+propertyName.substring(0,1).toUpperCase()+propertyName.substring(1);</span>
<span class="fc" id="L1186">								Method setId = entity.getClass().getMethod(methodName, Integer.class);</span>
<span class="fc" id="L1187">								setId.invoke(entity, 0);</span>
<span class="fc" id="L1188">							} catch (Exception e2) {</span>
								try {
									//na starych WJ triedach je potrebne nastavit int hodnotu, napr. setTempId(0)
<span class="fc" id="L1191">									String methodName = &quot;set&quot;+propertyName.substring(0,1).toUpperCase()+propertyName.substring(1);</span>
<span class="fc" id="L1192">									Method setId = entity.getClass().getMethod(methodName, int.class);</span>
<span class="fc" id="L1193">									setId.invoke(entity, 0);</span>
<span class="fc" id="L1194">								} catch (Exception e21) {</span>
<span class="fc" id="L1195">									BeanWrapperImpl bw = new BeanWrapperImpl(entity);</span>
									//setni ID hodnotu na povodnej entite, aby sa nasledne korektne vykonala processToEntity so spravnym ID
									try {
<span class="nc" id="L1198">										bw.setPropertyValue(propertyName, lnull);</span>
<span class="fc" id="L1199">									} catch (Exception e3) {</span>
										try {
<span class="nc" id="L1201">											bw.setPropertyValue(propertyName, inull);</span>
<span class="fc" id="L1202">										} catch (Exception e4) {</span>
											try {
<span class="fc" id="L1204">												bw.setPropertyValue(propertyName, 0);</span>
<span class="nc" id="L1205">											} catch (Exception e5) {</span>

<span class="fc" id="L1207">											}</span>
<span class="nc" id="L1208">										}</span>
<span class="nc" id="L1209">									}</span>
<span class="fc" id="L1210">								}</span>
<span class="fc" id="L1211">							}</span>
<span class="fc" id="L1212">						}</span>

<span class="fc" id="L1214">						isDuplicate = true;</span>
<span class="fc" id="L1215">						beforeDuplicate(entity);</span>
					}

<span class="nc" id="L1218">				} catch (Exception ex) {</span>
<span class="nc" id="L1219">					Logger.error(DatatableRestControllerV2.class, ex);</span>
<span class="nc" id="L1220">					throwError(&quot;datatables.error.system.js&quot;);</span>
<span class="fc" id="L1221">				}</span>

<span class="pc bpc" id="L1223" title="1 of 6 branches missed.">				if (isImporting &amp;&amp; &quot;onlyNew&quot;.equals(importMode) &amp;&amp; Tools.isNotEmpty(updateByColumn)) {</span>
					try {
<span class="fc" id="L1225">						List&lt;T&gt; itemsBy = findItemBy(updateByColumn, entity);</span>
<span class="fc bfc" id="L1226" title="All 2 branches covered.">						if (itemsBy.isEmpty()==false) {</span>
							//SKIP import, entity allready exists
<span class="fc" id="L1228">							Logger.debug(DatatableRestControllerV2.class, &quot;import SKIP entity - allready exists, entity=&quot;+entity+&quot;, &quot;+updateByColumn+&quot;=&quot;+updateByColumn);</span>
<span class="fc" id="L1229">							response.setForceReload(Boolean.TRUE);</span>
<span class="fc" id="L1230">							continue;</span>
						}
<span class="nc" id="L1232">					} catch (IllegalAccessException | NoSuchMethodException | InvocationTargetException | InstantiationException e) {</span>
<span class="nc" id="L1233">						response.setError(String.format(&quot;Field: %s not found&quot;, updateByColumn));</span>
<span class="nc" id="L1234">						Logger.error(DatatableRestControllerV2.class, e);</span>
<span class="nc" id="L1235">						return ResponseEntity.ok(response);</span>
<span class="nc" id="L1236">					} catch(RuntimeException ex) {</span>
						//Ignore error if skipWrongData is true
<span class="nc bnc" id="L1238" title="All 2 branches missed.">						if(skipWrongData == true) {</span>
<span class="nc" id="L1239">							addImportedColumnError(ex);</span>
<span class="nc" id="L1240">							continue;</span>
						}
<span class="nc" id="L1242">						throw ex;</span>
<span class="fc" id="L1243">					}</span>
				}

				try {
<span class="fc" id="L1247">					ResponseEntity&lt;T&gt; re = add(entity); //This method throws ConstraintViolationException</span>
<span class="fc" id="L1248">					response.add(re.getBody());</span>

<span class="fc bfc" id="L1250" title="All 2 branches covered.">					if (isDuplicate) afterDuplicate(entity, id);</span>
<span class="fc" id="L1251">				} catch (ConstraintViolationException ex) {</span>
					//Ignore error if skipWrongData is true
<span class="fc bfc" id="L1253" title="All 2 branches covered.">					if(skipWrongData == true) {</span>
<span class="fc" id="L1254">						List&lt;ConstraintViolation&lt;?&gt;&gt; violations = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1255" title="All 2 branches covered.">						for (ConstraintViolation&lt;?&gt; violation : ex.getConstraintViolations()) {</span>
<span class="fc" id="L1256">							violations.add(violation);</span>
<span class="fc" id="L1257">						}</span>
<span class="fc" id="L1258">						addImportedColumnError(violations);</span>
<span class="fc" id="L1259">						continue;</span>
					}
<span class="fc" id="L1261">					throw ex;</span>
<span class="fc" id="L1262">				} catch(RuntimeException ex) {</span>
					//Ignore error if skipWrongData is true
<span class="pc bpc" id="L1264" title="1 of 2 branches missed.">					if(skipWrongData == true) {</span>
<span class="nc" id="L1265">						addImportedColumnError(ex);</span>
<span class="nc" id="L1266">						continue;</span>
					}
<span class="fc" id="L1268">					throw ex;</span>
<span class="fc" id="L1269">				}</span>

<span class="fc bfc" id="L1271" title="All 2 branches covered.">			} else if (datatableRequest.isUpdate()) {</span>

<span class="fc bfc" id="L1273" title="All 2 branches covered.">				if (isImporting) {</span>
<span class="fc" id="L1274">					setImporting(true);</span>
				}

<span class="fc" id="L1277">				ResponseEntity&lt;T&gt; re=null;</span>
				// Ak updatujeme na zaklade stlpca v DB
<span class="fc bfc" id="L1279" title="All 2 branches covered.">				if (Tools.isNotEmpty(updateByColumn)) {</span>
					try {
<span class="fc" id="L1281">						response.setData(editItemByColumn(entity, updateByColumn));</span>
<span class="nc" id="L1282">					} catch (IllegalAccessException | NoSuchMethodException | InvocationTargetException | InstantiationException e) {</span>
<span class="nc" id="L1283">						response.setError(String.format(&quot;Field: %s not found&quot;, updateByColumn));</span>
<span class="nc" id="L1284">						Logger.error(DatatableRestControllerV2.class, e);</span>
<span class="nc" id="L1285">						return ResponseEntity.ok(response);</span>
<span class="nc" id="L1286">					} catch(RuntimeException ex) {</span>
						//Ignore error if skipWrongData is true
<span class="nc bnc" id="L1288" title="All 2 branches missed.">						if(skipWrongData == true) {</span>
<span class="nc" id="L1289">							addImportedColumnError(ex);</span>
<span class="nc" id="L1290">							continue;</span>
						}
<span class="nc" id="L1292">						throw ex;</span>
<span class="fc" id="L1293">					}</span>
				}
				else {
<span class="fc" id="L1296">					re = edit(id, entity);</span>
<span class="fc" id="L1297">					response.add(re.getBody());</span>
				}
<span class="pc bpc" id="L1299" title="1 of 2 branches missed.">			} else if (datatableRequest.isDelete()) {</span>

<span class="fc" id="L1301">				ResponseEntity&lt;Map&lt;String, Object&gt;&gt; re = delete(id, entity);</span>

				//delete(id, datatableRequest.getData().get(id));
<span class="fc" id="L1304">				Map&lt;String, Object&gt; body = re.getBody();</span>
<span class="pc bpc" id="L1305" title="2 of 6 branches missed.">				if (body == null || body.get(&quot;result&quot;) == null || body.get(&quot;result&quot;).equals(Boolean.TRUE)==false) {</span>
<span class="nc" id="L1306">					throwError(&quot;editor.delete_error&quot;);</span>
				}
			}
<span class="fc" id="L1309">		}</span>

		//We skipped worng data, prepare and show errors notification
<span class="fc bfc" id="L1312" title="All 2 branches covered.">		if(skipWrongData == true) {</span>

<span class="fc bfc" id="L1314" title="All 2 branches covered.">			if(invalidImportedRowsErrors == null) {</span>
<span class="fc" id="L1315">				invalidImportedRowsErrors = new TreeMap&lt;&gt;();</span>
			}

<span class="fc bfc" id="L1318" title="All 2 branches covered.">			if(getThreadData().getInvalidImportedRowsErrors() != null) {</span>
<span class="fc" id="L1319">				invalidImportedRowsErrors.putAll( getThreadData().getInvalidImportedRowsErrors() );</span>
			}

<span class="fc bfc" id="L1322" title="All 2 branches covered.">			if(invalidImportedRowsErrors.size() &gt; 0) {</span>
<span class="fc" id="L1323">				StringBuilder allInsertErrors = new StringBuilder(&quot;&quot;);</span>

<span class="fc bfc" id="L1325" title="All 2 branches covered.">				for (Map.Entry&lt;Integer, String&gt; set : invalidImportedRowsErrors.entrySet()) {</span>
<span class="fc" id="L1326">					allInsertErrors.append(set.getValue()).append(&quot;&lt;br&gt; &lt;br&gt;&quot;);</span>
<span class="fc" id="L1327">				}</span>

<span class="fc" id="L1329">				NotifyBean error = new NotifyBean(Prop.getInstance().getText(&quot;datatables.error.title.js&quot;), allInsertErrors.toString(), NotifyType.ERROR);</span>
<span class="fc" id="L1330">				getThreadData().addNotify(error);</span>
			}
		}

		//!! CLear SKIP wrong data support variables
<span class="fc" id="L1335">		getThreadData().setInvalidImportedRows(null);</span>
<span class="fc" id="L1336">		getThreadData().setInvalidImportedRowsErrors(null);</span>

<span class="fc bfc" id="L1338" title="All 2 branches covered.">		if (isForceReload()) {</span>
<span class="fc" id="L1339">			response.setForceReload(Boolean.TRUE);</span>
		}

<span class="fc bfc" id="L1342" title="All 2 branches covered.">		if (isImporting) {</span>
<span class="fc" id="L1343">			afterImportChunk(datatableRequest.getDzchunkindex(), datatableRequest.getDztotalchunkcount());</span>
		}

		//If thread notify list != null, set list into response
<span class="fc bfc" id="L1347" title="All 2 branches covered.">		if(hasNotify()) response.setNotify(getThreadData().getNotify());</span>

<span class="fc bfc" id="L1349" title="All 2 branches covered.">		if (datatableRequest.getData().size()&gt;5) {</span>
			//aby nenastala chyba 429 pri importe musime spomalit download
<span class="fc" id="L1351">			MultipartWrapper.slowdownUpload();</span>
		}

<span class="fc" id="L1354">		return ResponseEntity.ok(response);</span>
	}

	/**
	 * Volanie specialnej akcie (napr. otocenie obrazku v galerii).
	 * V pug subore sa vola ako galleryTable.executeAction(&quot;rotate&quot;);
	 * @param action
	 * @param ids
	 * @return
	 */
	@PreAuthorize(value = &quot;@WebjetSecurityService.checkAccessAllowedOnController(this)&quot;)
	@PostMapping(value = &quot;/action/{action}&quot;)
	public ResponseEntity&lt;DatatableResponse&lt;T&gt;&gt; action(@PathVariable String action, @RequestParam(value = &quot;ids[]&quot;) Long[] ids) {
<span class="fc" id="L1367">		clearThreadData();</span>
<span class="fc" id="L1368">		DatatableResponse&lt;T&gt; response = new DatatableResponse&lt;&gt;();</span>

<span class="fc bfc" id="L1370" title="All 2 branches covered.">		for (Long id : ids) {</span>
<span class="fc" id="L1371">			Logger.debug(DatatableRestControllerV2.class, &quot;action=&quot; + action + &quot;, id=&quot; + id);</span>

<span class="fc" id="L1373">			T entity = null;</span>
			//id==-1 je v situacii ked sa nic neselectne, napr. pre refresh akciu
<span class="fc bfc" id="L1375" title="All 2 branches covered.">			if (id != -1) entity = getOneItem(id);</span>
<span class="pc bpc" id="L1376" title="1 of 4 branches missed.">			if (entity != null || id==-1) {</span>
<span class="fc" id="L1377">				checkItemPermsThrows(entity, id);</span>
<span class="fc" id="L1378">				boolean success = processAction(entity, action);</span>
<span class="pc bpc" id="L1379" title="1 of 2 branches missed.">				if (success == false) {</span>
<span class="nc" id="L1380">					response.setError(getProp().getText(&quot;datatable.error.unknown&quot;) + &quot;: id=&quot; + id);</span>
				}
			}
		}

		//If thread notify list != null, set list into response
<span class="fc bfc" id="L1386" title="All 2 branches covered.">		if(hasNotify()) response.setNotify(getThreadData().getNotify());</span>
<span class="fc" id="L1387">		response.setForceReload(isForceReload());</span>

<span class="fc" id="L1389">		return ResponseEntity.ok(response);</span>
	}

	@PreAuthorize(value = &quot;@WebjetSecurityService.checkAccessAllowedOnController(this)&quot;)
	@GetMapping(&quot;/{id}&quot;)
	public T getOne(@PathVariable(&quot;id&quot;) long id) {
<span class="fc" id="L1395">		clearThreadData();</span>
<span class="fc" id="L1396">		T result = getOneItem(id);</span>
<span class="fc" id="L1397">		checkItemPermsThrows(result, id);</span>
<span class="fc" id="L1398">		addNotifyToEditorFields(result);</span>
<span class="fc" id="L1399">		return result;</span>
	}

	@PreAuthorize(value = &quot;@WebjetSecurityService.checkAccessAllowedOnController(this)&quot;)
	@PostMapping(&quot;/add&quot;)
	public ResponseEntity&lt;T&gt; add(@Valid @RequestBody T entity) {
<span class="fc" id="L1405">		beforeSave(entity);</span>

		// validacia
<span class="fc" id="L1408">		Set&lt;ConstraintViolation&lt;T&gt;&gt; violations = validator.validate(entity);</span>

		//Error will be always thrown, but prepare error message for user is we skipping wrong data
<span class="fc bfc" id="L1411" title="All 2 branches covered.">		if (!violations.isEmpty()) {</span>
			//convert violations to List&lt;ConstraintViolation&lt;?&gt;&gt;
<span class="fc" id="L1413">			List&lt;ConstraintViolation&lt;?&gt;&gt; violationsList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1414" title="All 2 branches covered.">			for (ConstraintViolation&lt;T&gt; violation : violations) {</span>
<span class="fc" id="L1415">				violationsList.add(violation);</span>
<span class="fc" id="L1416">			}</span>
<span class="fc" id="L1417">			addImportedColumnError(violationsList);</span>
<span class="fc" id="L1418">			throw new ConstraintViolationException(&quot;Invalid data&quot;, violations);</span>
		} else {
<span class="fc" id="L1420">			checkItemPermsThrows(entity, -1L);</span>
<span class="fc" id="L1421">			T newT = this.insertItem(entity);</span>
<span class="fc" id="L1422">			afterSave(entity, newT);</span>
<span class="fc" id="L1423">			return new ResponseEntity&lt;&gt;(newT, null, HttpStatus.CREATED);</span>
		}
	}

	@PreAuthorize(value = &quot;@WebjetSecurityService.checkAccessAllowedOnController(this)&quot;)
	@PostMapping(&quot;/edit/{id}&quot;)
	public ResponseEntity&lt;T&gt; edit(@PathVariable(&quot;id&quot;) long id, @Valid @RequestBody T entity) {
<span class="fc" id="L1430">		beforeSave(entity);</span>

		// validacia
<span class="fc" id="L1433">		Set&lt;ConstraintViolation&lt;T&gt;&gt; violations = validator.validate(entity);</span>
<span class="fc bfc" id="L1434" title="All 2 branches covered.">		if (!violations.isEmpty()) {</span>
<span class="fc" id="L1435">			throw new ConstraintViolationException(&quot;Invalid data&quot;, violations);</span>
		} else {
<span class="fc" id="L1437">			checkItemPermsThrows(entity, id);</span>
<span class="fc" id="L1438">			T one = this.editItem(entity, id);</span>
<span class="fc" id="L1439">			afterSave(entity, one);</span>
<span class="fc" id="L1440">			return ResponseEntity.ok(one);</span>
		}
	}

	@PreAuthorize(value = &quot;@WebjetSecurityService.checkAccessAllowedOnController(this)&quot;)
	@DeleteMapping(&quot;/{id}&quot;)
	public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; delete(@PathVariable(&quot;id&quot;) long id, @RequestBody T entity) {
<span class="fc" id="L1447">		clearThreadData();</span>
<span class="fc" id="L1448">		Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1449">		checkItemPermsThrows(entity, id);</span>

<span class="fc" id="L1451">		boolean deleted = false;</span>
<span class="pc bpc" id="L1452" title="1 of 2 branches missed.">		if (beforeDelete(entity)) {</span>
<span class="fc" id="L1453">			deleted = this.deleteItem(entity, id);</span>
		}
<span class="fc" id="L1455">		result.put(&quot;result&quot;, deleted);</span>
<span class="fc bfc" id="L1456" title="All 2 branches covered.">		if (deleted) {</span>
<span class="fc" id="L1457">			afterDelete(entity, id);</span>
		}

<span class="fc" id="L1460">		return new ResponseEntity&lt;&gt;(result, HttpStatus.OK);</span>
	}

	public JpaRepository&lt;T, Long&gt; getRepo() {
<span class="fc" id="L1464">		return repo;</span>
	}

	public HttpServletRequest getRequest(){
<span class="fc" id="L1468">		return this.request;</span>
	}

	public Identity getUser(){
<span class="fc" id="L1472">		return UsersDB.getCurrentUser(getRequest());</span>
	}

	public Prop getProp() {
		//kedze nie sme thread safe vraciame takto, request je autowired, cize ten je OK
<span class="fc" id="L1477">		return Prop.getInstance(getRequest());</span>
	}

	/**
	 * Vyvola vseobecnu vynimku ulozenia (ked napr. v editItem nastane nejaka vseobecna chyba)
	 * Chybove hlasenie sa zobrazi v editore pri tlacitku odoslat
	 * @param errors
	 */
	@SuppressWarnings(&quot;all&quot;)
	public void throwError(String errorKey) {
<span class="fc" id="L1487">		String message = getProp().getText(errorKey);</span>
<span class="fc" id="L1488">		throw new RuntimeException(message);</span>
	}

	/**
	 * Vyvola vynimku platnosti typu pola (napr. kontrola email adresy)
	 * @param errorKey - prekladovy kluc chybovej spravy
	 */
	@SuppressWarnings(&quot;all&quot;)
	public void throwConstraintViolation(String errorKey) {
<span class="nc" id="L1497">		String message = getProp().getText(errorKey);</span>
<span class="nc" id="L1498">		throw new ConstraintViolationException(message, null);</span>
	}

	/**
	 * Vyvola vseobecnu vynimku ulozenia (ked napr. v editItem nastane nejaka vseobecna chyba)
	 * Chybove hlasenie sa zobrazi v editore pri tlacitku odoslat
	 * @param errorKeys
	 */
	@SuppressWarnings(&quot;all&quot;)
	public void throwError(List&lt;String&gt; errorKeys) {
		//preved z klucov na texy
<span class="fc" id="L1509">		Prop prop = Prop.getInstance();</span>
<span class="fc" id="L1510">		StringBuilder message = new StringBuilder();</span>
<span class="fc bfc" id="L1511" title="All 2 branches covered.">		for (String key : errorKeys) {</span>
<span class="pc bpc" id="L1512" title="1 of 2 branches missed.">			if (message.length()&gt;0) message.append(&quot;;\n&quot;);</span>
<span class="fc" id="L1513">			message.append(prop.getText(key));</span>
<span class="fc" id="L1514">		}</span>

<span class="fc" id="L1516">		throw new RuntimeException(message.toString());</span>
	}

	private static ThreadBean getThreadData() {
<span class="fc" id="L1520">		ThreadBean data = threadData.get();</span>
<span class="fc bfc" id="L1521" title="All 2 branches covered.">		if (data == null) {</span>
<span class="fc" id="L1522">			Logger.debug(DatatableRestControllerV2.class, &quot;ThreadData.creating, id=&quot;+Thread.currentThread().getId());</span>
<span class="fc" id="L1523">			data = new ThreadBean();</span>
<span class="fc" id="L1524">			threadData.set(data);</span>
		}
		//Logger.debug(DatatableRestControllerV2.class, &quot;ThreadData.get, id=&quot;+Thread.currentThread().getId()+&quot; data=&quot;+data.toString());
<span class="fc" id="L1527">		return data;</span>
	}

	private void clearThreadData() {
<span class="fc" id="L1531">		getThreadData().clear();</span>
<span class="fc" id="L1532">	}</span>

	/**
	 * Indikuje, ze dane volanie je pre export dat
	 * @return
	 */
	public boolean isExporting() {
<span class="fc" id="L1539">		boolean exporting = getThreadData().isExporting();</span>
		//Logger.debug(DatatableRestControllerV2.class, &quot;isExporting, thread=&quot;+Thread.currentThread().getId()+&quot; exporting=&quot;+exporting);
<span class="fc" id="L1541">		return exporting;</span>
	}

	private void setExporting(boolean exporting) {
<span class="fc" id="L1545">		getThreadData().setExporting(exporting);</span>
<span class="fc" id="L1546">	}</span>

	/**
	 * Indikuje, ze dane volanie je pre import dat
	 * @return
	 */
	public boolean isImporting() {
<span class="fc" id="L1553">		return getThreadData().isImporting();</span>
	}

	private void setImporting(boolean importing) {
<span class="fc" id="L1557">		getThreadData().setImporting(importing);</span>
<span class="fc" id="L1558">	}</span>

	/**
	 * Indikuje, ze sa ma vykonat reload tabulky
	 * @return
	 */
	public boolean isForceReload() {
<span class="fc" id="L1565">		return getThreadData().isForceReload();</span>
	}

	public void setForceReload(boolean forceReload) {
<span class="fc" id="L1569">		getThreadData().setForceReload(forceReload);</span>
<span class="fc" id="L1570">	}</span>

	public boolean hasNotify() {
<span class="fc bfc" id="L1573" title="All 2 branches covered.">		return getThreadData().getNotify() != null ? true : false;</span>
	}

	/**
	 * Prida notifikaciu pre zobrazenie po odoslani dat
	 * @param notify
	 */
	public static void addNotify(NotifyBean notify) {
<span class="fc" id="L1581">		getThreadData().addNotify(notify);</span>
<span class="fc" id="L1582">	}</span>

	/**
	 * Prida zoznam notifikacii pre zobrazenie po odoslani dat
	 * @param notifyList
	 */
	public static void addNotify(List&lt;NotifyBean&gt; notifyList) {
<span class="pc bpc" id="L1589" title="1 of 4 branches missed.">		if (notifyList != null &amp;&amp; notifyList.isEmpty()==false) {</span>
<span class="fc bfc" id="L1590" title="All 2 branches covered.">			for (NotifyBean notify : notifyList) {</span>
<span class="fc" id="L1591">				getThreadData().addNotify(notify);</span>
<span class="fc" id="L1592">			}</span>
		}
<span class="fc" id="L1594">	}</span>

	/**
	 * Nastavi cislo importovaneho riadku (ak sa nachadza v datach)
	 * @param lastImportedRow
	 * @return
	 */
	private void setLastImportedRow(Integer lastImportedRow) {
<span class="fc" id="L1602">		getThreadData().setLastImportedRow(lastImportedRow);</span>
<span class="fc" id="L1603">	}</span>

	/**
	 * Vrati cislo posledne importovaneho riadku
	 * @return
	 */
	public static Integer getLastImportedRow() {
<span class="fc" id="L1610">		return getThreadData().getLastImportedRow();</span>
	}

	private void setImportedColumns(Set&lt;String&gt; importedColumns) {
<span class="fc" id="L1614">		getThreadData().setImportedColumns(importedColumns);</span>
<span class="fc" id="L1615">	}</span>

	/**
	 * Returns Set&lt;String&gt; of imported columns from xlsx file.
	 * You can check which columns were in Excel file during import process.
	 * @return
	 */
	public static Set&lt;String&gt; getImportedColumns() {
<span class="fc" id="L1623">		return getThreadData().getImportedColumns();</span>
	}

	/**
	 * Vrati repo pretypovane na DomainIdRepository pre jednoduchsie pouzitie
	 * @return
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	private DomainIdRepository&lt;T, ID&gt; getDomainRepo() {
<span class="pc bpc" id="L1632" title="1 of 2 branches missed.">		if (repo instanceof DomainIdRepository) {</span>
<span class="fc" id="L1633">			return (DomainIdRepository&lt;T, ID&gt;)repo;</span>
		}
<span class="nc" id="L1635">		return null;</span>
	}

	/**
	 * Prida notify list do BaseEditorFields objektu (ak existuje)
	 * Toto je potrebne pri REST volaniach, kedy sa posiela nazad len zakladna entita
	 * @param entity
	 */
	private void addNotifyToEditorFields(T entity) {
		try {
<span class="fc" id="L1645">			List&lt;NotifyBean&gt; notifyList = getThreadData().getNotify();</span>
<span class="pc bpc" id="L1646" title="1 of 4 branches missed.">			if (notifyList!=null &amp;&amp; notifyList.isEmpty()==false) {</span>
<span class="fc" id="L1647">				BeanWrapperImpl bw = new BeanWrapperImpl(entity);</span>
<span class="pc bpc" id="L1648" title="1 of 2 branches missed.">				if (bw.getPropertyType(&quot;editorFields.notify&quot;)!=null) {</span>
<span class="fc" id="L1649">					bw.setPropertyValue(&quot;editorFields.notify&quot;, getThreadData().getNotify());</span>
				}
			}
<span class="nc" id="L1652">		} catch (Exception e) {</span>
<span class="nc" id="L1653">			Logger.error(DatatableRestControllerV2.class, e);</span>
<span class="fc" id="L1654">		}</span>
<span class="fc" id="L1655">	}</span>

	/**
	 * There is problem to return single Boolean from JPA query,
	 * it's returned as Boolean in MariaDB/MSSQL and Number (0 or 1) on Oracle
	 * there we cast it correctly to boolean
	 * @param value
	 * @return
	 */
	public static boolean jpaToBoolean(Object value) {
<span class="pc bpc" id="L1665" title="1 of 2 branches missed.">		if (value == null) return false;</span>
<span class="pc bpc" id="L1666" title="1 of 2 branches missed.">		if (value instanceof Boolean) return (Boolean)value;</span>
<span class="nc bnc" id="L1667" title="All 2 branches missed.">		if (value instanceof Number) {</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">			return ((Number)value).intValue() == 1 ? true : false;</span>
		}
<span class="nc" id="L1670">		return false;</span>
	}

	/**
	 * Test if field value should be lower cased
	 * @param field
	 * @return
	 */
	private boolean isJpaLowerField(String field)
    {
<span class="nc" id="L1680">		String[] jpaToLowerFields = ConstantsV9.getArrayCached(&quot;jpaToLowerFields&quot;, 120);</span>
<span class="nc bnc" id="L1681" title="All 6 branches missed.">        if (jpaToLowerFields==null || jpaToLowerFields.length==0 || field==null) return false;</span>

<span class="nc bnc" id="L1683" title="All 2 branches missed.">        for (String one : jpaToLowerFields)</span>
        {
<span class="nc bnc" id="L1685" title="All 2 branches missed.">           if (one.equals(field)) return true;</span>
		   //support for descriptionLong* so we don't need to write all language codes
<span class="nc bnc" id="L1687" title="All 4 branches missed.">		   if (one.endsWith(&quot;*&quot;) &amp;&amp; one.substring(0, one.length()-1) .equals(field)) return true;</span>
        }
<span class="nc" id="L1689">        return false;</span>
    }

	/**
	 * column name which is used to update the row with import
	 * @return
	 */
	public String getUpdateByColumn() {
<span class="nc" id="L1697">		return getThreadData().getUpdateByColumn();</span>
	}

	/**
	 * mode of import (append, update, onlyNew)
	 * @return
	 */
	public String getImportMode() {
<span class="fc" id="L1705">		return getThreadData().getImportMode();</span>
	}

	/**
	 * Set invalid imported rows
	 * @param invalidImportedRows
	 */
	private void setInvalidImportedRows(Set&lt;Long&gt; invalidImportedRows) {
<span class="fc" id="L1713">		getThreadData().setInvalidImportedRows(invalidImportedRows);</span>
<span class="fc" id="L1714">	}</span>

	/**
	 * Get invalid imported rows
	 * @return
	 */
	public Set&lt;Long&gt; getInvalidImportedRows() {
<span class="fc" id="L1721">		return getThreadData().getInvalidImportedRows();</span>
	}

	/**
	 * Set skip wrong data.
	 * TRUE - wrong data during import will be skipped and process will continue
	 * @param skipWrongData
	 */
	private void setSkipWrongData(boolean skipWrongData) {
<span class="fc" id="L1730">		getThreadData().setSkipWrongData(skipWrongData);</span>
<span class="fc" id="L1731">	}</span>

	/**
	 * Get skip wrong data.
	 * TRUE - wrong data during import will be skipped and process will continue
	 * @return
	 */
	public boolean isSkipWrongData() {
<span class="fc" id="L1739">		return getThreadData().isSkipWrongData();</span>
	}

	/**
	 * List of violated constraints during import (invalid rows during import) will be prepared and ADDED inside of threadData.InvalidImportedRowsErrors
	 * This set of processed error's are used for Warning notification (FOR user). So user can by notified which rows are invalid and WHY.
	 * @param violations - Set of ConstraintViolations
	 */
	private void addImportedColumnError(List&lt;ConstraintViolation&lt;?&gt;&gt; violations) {
<span class="pc bpc" id="L1748" title="2 of 4 branches missed.">		if(violations == null || violations.size() &lt; 1) return;</span>
<span class="fc" id="L1749">		ConstraintViolation&lt;?&gt; firstViolation = violations.iterator().next();</span>
<span class="fc" id="L1750">		String propertyName = firstViolation.getPropertyPath().toString();</span>
<span class="fc" id="L1751">		int dot = propertyName.indexOf(&quot;.&quot;);</span>
<span class="pc bpc" id="L1752" title="3 of 4 branches missed.">		if (dot &gt; 0 &amp;&amp; propertyName.startsWith(&quot;editorFields&quot;) == false) propertyName = propertyName.substring(0, dot);</span>

<span class="fc" id="L1754">		String errCause = firstViolation.getMessageTemplate();</span>
<span class="pc bpc" id="L1755" title="2 of 6 branches missed.">		if(Tools.isNotEmpty(errCause) &amp;&amp; errCause.startsWith(&quot;{&quot;) &amp;&amp; errCause.endsWith(&quot;}&quot;)) {</span>
			//For example {javax.validation.constraints.NotBlank.message}
<span class="fc" id="L1757">			errCause = errCause.substring(1, errCause.length() - 1);</span>
<span class="fc" id="L1758">			errCause = Prop.getInstance().getText( errCause );</span>
		} else {
<span class="fc" id="L1760">			errCause = firstViolation.getMessage();</span>
		}

<span class="fc" id="L1763">		StringBuilder errExplanation = new StringBuilder(propertyName);</span>
<span class="fc bfc" id="L1764" title="All 2 branches covered.">		int lastImportedRow = getLastImportedRow() == null ? 0 : getLastImportedRow().intValue();</span>

<span class="fc bfc" id="L1766" title="All 2 branches covered.">		errExplanation.append(&quot; - &quot;).append(firstViolation.getInvalidValue() == null ? &quot;EMPTY&quot; : firstViolation.getInvalidValue().toString()).append(&quot; - &quot;).append(errCause);</span>
<span class="fc" id="L1767">		String errMsg = Prop.getInstance().getText(&quot;datatable.error.importRow&quot;, String.valueOf(lastImportedRow) , errExplanation.toString());</span>

<span class="fc" id="L1769">		TreeMap&lt;Integer, String&gt; rowsErrors = getThreadData().getInvalidImportedRowsErrors();</span>
<span class="fc bfc" id="L1770" title="All 2 branches covered.">		if(rowsErrors == null) rowsErrors = new TreeMap&lt;&gt;();</span>
<span class="fc" id="L1771">		rowsErrors.put(lastImportedRow, errMsg);</span>
<span class="fc" id="L1772">		getThreadData().setInvalidImportedRowsErrors(rowsErrors);</span>
<span class="fc" id="L1773">	}</span>

	private void addImportedColumnError(RuntimeException ex) {
<span class="nc" id="L1776">		String errExplanation = ex.getMessage();</span>
<span class="nc bnc" id="L1777" title="All 2 branches missed.">		int lastImportedRow = getLastImportedRow() == null ? 0 : getLastImportedRow().intValue();</span>

<span class="nc" id="L1779">		String errMsg = Prop.getInstance().getText(&quot;datatable.error.importRow&quot;, String.valueOf(lastImportedRow) , errExplanation);</span>

<span class="nc" id="L1781">		TreeMap&lt;Integer, String&gt; rowsErrors = getThreadData().getInvalidImportedRowsErrors();</span>
<span class="nc bnc" id="L1782" title="All 2 branches missed.">		if(rowsErrors == null) rowsErrors = new TreeMap&lt;&gt;();</span>
<span class="nc" id="L1783">		rowsErrors.put(lastImportedRow, errMsg);</span>
<span class="nc" id="L1784">		getThreadData().setInvalidImportedRowsErrors(rowsErrors);</span>
<span class="nc" id="L1785">	}</span>


	/**
	 * This error will be prepared and ADDED inside of threadData.InvalidImportedRowsErrors.
	 * This set of processed error's are used for Warning notification (FOR user). So user can by notified which rows are invalid and WHY.
	 * @param err - FieldError
	 * @param rowNumber - imported row number
	 */
	private void addImportedColumnError(org.springframework.validation.FieldError err, Integer rowNumber) {
<span class="fc" id="L1795">		String propertyName = err.getField();</span>
<span class="pc bpc" id="L1796" title="1 of 2 branches missed.">		if(propertyName.startsWith(&quot;errorField.&quot;)) propertyName = propertyName.replace(&quot;errorField.&quot;, &quot;&quot;);</span>
<span class="fc" id="L1797">		int dot = propertyName.indexOf(&quot;.&quot;);</span>
<span class="pc bpc" id="L1798" title="3 of 4 branches missed.">		if (dot &gt; 0 &amp;&amp; propertyName.startsWith(&quot;editorFields&quot;) == false) propertyName = propertyName.substring(0, dot);</span>

<span class="fc" id="L1800">		StringBuilder errExplanation = new StringBuilder();</span>
<span class="fc" id="L1801">		errExplanation.append(propertyName);</span>
<span class="pc bpc" id="L1802" title="1 of 2 branches missed.">		errExplanation.append(&quot; - &quot;).append( err.getRejectedValue() == null ? &quot;EMPTY&quot; : err.getRejectedValue().toString() );</span>
<span class="fc" id="L1803">		errExplanation.append(&quot; - &quot;).append( err.getDefaultMessage() );</span>

<span class="pc bpc" id="L1805" title="1 of 2 branches missed.">		int lastImportedRow = getLastImportedRow() == null ? 0 : getLastImportedRow().intValue();</span>
<span class="fc" id="L1806">		String errMsg = Prop.getInstance().getText(&quot;datatable.error.importRow&quot;, String.valueOf(lastImportedRow + rowNumber + 1) , errExplanation.toString());</span>

<span class="fc" id="L1808">		TreeMap&lt;Integer, String&gt; rowsErrors = getThreadData().getInvalidImportedRowsErrors();</span>
<span class="fc bfc" id="L1809" title="All 2 branches covered.">		if(rowsErrors == null) rowsErrors = new TreeMap&lt;&gt;();</span>
<span class="fc" id="L1810">		rowsErrors.put(lastImportedRow + rowNumber + 1, errMsg);</span>
<span class="fc" id="L1811">		getThreadData().setInvalidImportedRowsErrors(rowsErrors);</span>
<span class="fc" id="L1812">	}</span>

	/**
	 * Copy fields from provided entity into original entity
	 * @param entity
	 * @param one
	 */
	private void copyEntityIntoOriginal(T entity, T one) {
<span class="fc" id="L1820">		List&lt;String&gt; alwaysCopyProperties = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1821">		List&lt;String&gt; ignoreProperties = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L1823">		Field[] declaredFields = AuditEntityListener.getDeclaredFieldsTwoLevels(entity.getClass());</span>
<span class="fc bfc" id="L1824" title="All 2 branches covered.">		for (Field field : declaredFields) {</span>
<span class="fc bfc" id="L1825" title="All 2 branches covered.">			if (field.isAnnotationPresent(sk.iway.iwcm.system.datatable.annotations.DataTableColumn.class)) {</span>
<span class="fc" id="L1826">				sk.iway.iwcm.system.datatable.annotations.DataTableColumn annotation = field.getAnnotation(sk.iway.iwcm.system.datatable.annotations.DataTableColumn.class);</span>
<span class="fc" id="L1827">				boolean[] hiddenEditor = annotation.hiddenEditor();</span>
<span class="fc bfc" id="L1828" title="All 2 branches covered.">				if (hiddenEditor.length &gt; 0) {</span>
					//ak je hiddenEditor preskoc
<span class="pc bpc" id="L1830" title="1 of 2 branches missed.">					if (hiddenEditor[0]==true) {</span>
<span class="fc" id="L1831">						ignoreProperties.add(field.getName());</span>
<span class="fc" id="L1832">						continue;</span>
					}
				}

				//also skip if editor.attr.disabled=disabled
<span class="fc" id="L1837">				DataTableColumnEditor editor[] = annotation.editor();</span>
<span class="fc bfc" id="L1838" title="All 2 branches covered.">				if (editor.length &gt; 0) {</span>
<span class="fc" id="L1839">					boolean isDisabled = false;</span>
<span class="fc" id="L1840">					DataTableColumnEditorAttr attrs[] = editor[0].attr();</span>
<span class="fc bfc" id="L1841" title="All 2 branches covered.">					if (attrs.length &gt; 0) {</span>
<span class="fc bfc" id="L1842" title="All 2 branches covered.">						for (DataTableColumnEditorAttr attr : attrs) {</span>
<span class="fc bfc" id="L1843" title="All 2 branches covered.">							if (&quot;disabled&quot;.equals(attr.key())) {</span>
<span class="fc" id="L1844">								isDisabled = true;</span>
<span class="fc" id="L1845">								break;</span>
							}
						}
					}
<span class="fc bfc" id="L1849" title="All 2 branches covered.">					if (isDisabled) {</span>
<span class="fc" id="L1850">						ignoreProperties.add(field.getName());</span>
<span class="fc" id="L1851">						continue;</span>
					}
				}

<span class="fc" id="L1855">				boolean alwaysCopy = false;</span>
<span class="pc bpc" id="L1856" title="1 of 2 branches missed.">				if (annotation.alwaysCopyProperties().length&gt;0) {</span>
<span class="nc" id="L1857">					alwaysCopy = annotation.alwaysCopyProperties()[0];</span>
					//implicit false value
<span class="nc bnc" id="L1859" title="All 2 branches missed.">					if (alwaysCopy==false) continue;</span>
				}
<span class="pc bpc" id="L1861" title="4 of 10 branches missed.">				if (alwaysCopy || field.getType().isAssignableFrom(Date.class) || field.getType().isAssignableFrom(java.sql.Date.class) || field.getType().isAssignableFrom(LocalDate.class) || field.getType().isAssignableFrom(LocalDateTime.class)) {</span>
					//ak je to datum tak ho dajme do ignore, aby isiel zadat v GUI prazdny datum
<span class="fc" id="L1863">					alwaysCopyProperties.add(field.getName());</span>
				}
			}
		}

<span class="fc" id="L1868">		NullAwareBeanUtils.copyProperties(entity, one, alwaysCopyProperties, ignoreProperties.toArray(new String[0]));</span>
<span class="fc" id="L1869">	}</span>

	public void setValidator(Validator validator) {
<span class="fc" id="L1872">		this.validator = validator;</span>
<span class="fc" id="L1873">	}</span>

	public void setRequest(HttpServletRequest request) {
<span class="fc" id="L1876">		this.request = request;</span>
<span class="fc" id="L1877">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>