<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="sk"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EditorService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">webjetcms</a> &gt; <a href="index.source.html" class="el_package">sk.iway.iwcm.editor.service</a> &gt; <span class="el_source">EditorService.java</span></div><h1>EditorService.java</h1><pre class="source lang-java linenums">package sk.iway.iwcm.editor.service;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.StringTokenizer;
import java.util.stream.Collectors;

import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import org.springframework.web.context.annotation.RequestScope;

import sk.iway.iwcm.Adminlog;
import sk.iway.iwcm.Constants;
import sk.iway.iwcm.DB;
import sk.iway.iwcm.FileTools;
import sk.iway.iwcm.Identity;
import sk.iway.iwcm.Logger;
import sk.iway.iwcm.PathFilter;
import sk.iway.iwcm.RequestBean;
import sk.iway.iwcm.Tools;
import sk.iway.iwcm.common.CloudToolsForCore;
import sk.iway.iwcm.common.DocTools;
import sk.iway.iwcm.database.SimpleQuery;
import sk.iway.iwcm.doc.DebugTimer;
import sk.iway.iwcm.doc.DocBasic;
import sk.iway.iwcm.doc.DocDB;
import sk.iway.iwcm.doc.DocDetails;
import sk.iway.iwcm.doc.DocDetailsRepository;
import sk.iway.iwcm.doc.DocEditorFields;
import sk.iway.iwcm.doc.DocHistory;
import sk.iway.iwcm.doc.DocHistoryRepository;
import sk.iway.iwcm.doc.GroupDetails;
import sk.iway.iwcm.doc.GroupsDB;
import sk.iway.iwcm.doc.MultigroupMapping;
import sk.iway.iwcm.doc.MultigroupMappingDB;
import sk.iway.iwcm.doc.TemplateDetails;
import sk.iway.iwcm.doc.TemplatesDB;
import sk.iway.iwcm.doc.attributes.jpa.DocAtrDefEntity;
import sk.iway.iwcm.doc.attributes.jpa.DocAtrEntity;
import sk.iway.iwcm.doc.attributes.jpa.DocAtrRepository;
import sk.iway.iwcm.editor.DocNoteBean;
import sk.iway.iwcm.editor.DocNoteDB;
import sk.iway.iwcm.editor.EditorDB;
import sk.iway.iwcm.editor.rest.DocDetailsToDocHistoryMapper;
import sk.iway.iwcm.editor.util.EditorUtils;
import sk.iway.iwcm.i18n.Prop;
import sk.iway.iwcm.io.IwcmFile;
import sk.iway.iwcm.system.UrlRedirectDB;
import sk.iway.iwcm.system.context.ContextFilter;
import sk.iway.iwcm.system.datatable.NotifyBean;
import sk.iway.iwcm.system.datatable.NotifyBean.NotifyType;
import sk.iway.iwcm.system.datatable.ProcessItemAction;
import sk.iway.iwcm.system.multidomain.MultiDomainFilter;
import sk.iway.iwcm.system.spring.events.WebjetEvent;
import sk.iway.iwcm.system.spring.events.WebjetEventType;
import sk.iway.iwcm.users.UserDetails;
import sk.iway.iwcm.users.UsersDB;
import sk.iway.iwcm.utils.Pair;

/**
 * Servis pre ukladanie web stranok (tabulka documents a documents_history).
 *
 * NEPOUZIVAT standardne je potrebne pouzit EditorFacade, ktora zapuzdruje dalsie operacie pri ulozeni
 *
 * Servis je RequestScope aby pre kazdy request boli objeky oddelene (thread safe)
 */
@Service
@RequestScope
public class EditorService {

	//repozitare
	private DocDetailsRepository docRepo;
	private DocHistoryRepository historyRepo;
	private DocAtrRepository docAtrRepository;

	//service
	private MediaService mediaService;
	private ApproveService approveService;

	//autowired
	private HttpServletRequest request;

	//privatne objekty
	private Identity currentUser;
	private Prop prop;
	private GroupsDB groupsDB;
	private DocDB docDB;
	private DocNoteDB docNoteDB;
	private long now;

	//list upozorneni
    private List&lt;NotifyBean&gt; notify;

	/** atributy nastavene pocas ukladania **/

	//nastavene na true ak je potrebne vyvolat obnovenie stromovej struktury/datatabulky po ulozeni
<span class="pc" id="L105">	private boolean forceReload = false;</span>
	//ak je nastavene casove publikovanie tu bude po ulozeni hodnota zaciatku publikovania
<span class="pc" id="L107">	private Long publihStart = null;</span>
	//po ulozeni nastavene na true, ak sa stranka vypublikovala pre zobrazenie navstevnikmi web sidla
<span class="pc" id="L109">	private boolean pageSavedToPublic = false;</span>
	//po ulozeni nastavene na true, ak sa stranka ulozila ako pracovna kopia
<span class="pc" id="L111">	private boolean pageSavedAsWorkVersion = false;</span>

	@Autowired
    public EditorService(DocDetailsRepository docRepo, DocHistoryRepository historyRepo, DocAtrRepository docAtrRepository,
<span class="fc" id="L115">			MediaService mediaService, ApproveService approveService, HttpServletRequest request) {</span>
<span class="fc" id="L116">		this.request = request;</span>

<span class="fc" id="L118">		this.docRepo = docRepo;</span>
<span class="fc" id="L119">		this.historyRepo = historyRepo;</span>
<span class="fc" id="L120">		this.docAtrRepository = docAtrRepository;</span>

<span class="fc" id="L122">		this.mediaService = mediaService;</span>
<span class="fc" id="L123">		this.approveService = approveService;</span>

<span class="fc" id="L125">		this.currentUser = UsersDB.getCurrentUser(request);</span>
<span class="fc" id="L126">		this.prop = Prop.getInstance(request);</span>
<span class="fc" id="L127">		this.groupsDB = GroupsDB.getInstance();</span>
<span class="fc" id="L128">		this.docDB = DocDB.getInstance();</span>
<span class="fc" id="L129">		this.docNoteDB = DocNoteDB.getInstance();</span>
<span class="fc" id="L130">		this.now = Tools.getNow();</span>
<span class="fc" id="L131">		this.forceReload = false;</span>

<span class="fc" id="L133">		this.notify = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L134">	}</span>

<span class="nc" id="L136">	public EditorService() {}</span>

	/**
	 * Vrati DocDetails objekt podla zadaneho docId alebo historyId (ak je zadane)
	 *
	 * @param docId
	 * @param historyId
	 * @return
	 */
    public DocDetails getDoc(int docId, int historyId) {

<span class="fc" id="L147">        DocDetails doc = null;</span>
<span class="fc" id="L148">        DocHistory history = null;</span>

<span class="fc bfc" id="L150" title="All 2 branches covered.">        if (historyId &lt;= 0) {</span>
<span class="fc" id="L151">			doc = docRepo.findById(docId);</span>
        } else {
<span class="fc" id="L153">            Optional&lt;DocHistory&gt; historyOptional = historyRepo.findById(Long.valueOf(historyId));</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">			if (historyOptional.isPresent()) {</span>
<span class="fc" id="L155">				history = historyOptional.get();</span>
<span class="fc" id="L156">				doc = DocDetailsToDocHistoryMapper.INSTANCE.docHistoryToDocDetails(history);</span>
			}
        }

<span class="pc bpc" id="L160" title="2 of 6 branches missed.">        if (historyId &gt; 0 &amp;&amp; history != null &amp;&amp; doc != null) {</span>
			//prenes hodnoty do DocDetails objektu z History (je to takto kvoli spatnej kompatibilite)
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">            if (history.getApprovedBy()!=null) doc.setHistoryApprovedBy(history.getApprovedBy());</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">            if (history.getDisapprovedBy()!=null) doc.setHistoryDisapprovedBy(history.getDisapprovedBy());</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">            if (history.getActual()!=null) doc.setHistoryActual(history.getActual());</span>
        }

<span class="pc bpc" id="L167" title="2 of 6 branches missed.">        if (historyId &gt; -1 &amp;&amp; history != null &amp;&amp; doc != null) {</span>
<span class="fc" id="L168">            doc.setPublicable(Boolean.TRUE.equals(history.getPublicable()));</span>
<span class="fc" id="L169">			DocEditorFields def = doc.getEditorFields();</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">			if (def == null) {</span>
<span class="fc" id="L171">				def = new DocEditorFields();</span>
<span class="fc" id="L172">				doc.setEditorFields(def);</span>
			}
<span class="fc" id="L174">			def.setPublishAfterStart(doc.isPublicable());</span>
<span class="fc" id="L175">			def.setDisableAfterEnd(history.isDisableAfterEnd());</span>
        }

<span class="fc" id="L178">        return doc;</span>
    }

	/**
	 * Ulozi DocDetials do databazy vratane vsetkych akcii spojenych s ulozenim web stranky (schvalovanie, nastavenie adresara...)
	 * @param editedDoc
	 * @return historyId alebo hodnotu &lt; 1 ak nastala chyba
	 */
	public int saveEditedDoc(DocDetails editedDoc) {
<span class="fc" id="L187">		DebugTimer dt = new DebugTimer(&quot;EditorService.saveEditedDoc&quot;);</span>

		//first update savedate and author, check permissions need this
<span class="fc" id="L190">		editedDoc.setDateCreated(now);</span>
<span class="fc" id="L191">		editedDoc.setAuthorId(currentUser.getUserId());</span>

<span class="fc" id="L193">		boolean isNewPage = false;</span>
<span class="fc" id="L194">		int historyId = -1;</span>
<span class="fc" id="L195">		boolean wasApproved = false;</span>

<span class="fc" id="L197">		(new WebjetEvent&lt;&gt;(editedDoc, WebjetEventType.ON_START)).publishEvent();</span>

		//check that data are loaded
<span class="pc bpc" id="L200" title="3 of 6 branches missed.">		if (editedDoc.getData()==null || WebpagesService.DATA_NOT_LOADED.equals(editedDoc.getData().trim()) || (&quot;&lt;p&gt;&quot;+WebpagesService.DATA_NOT_LOADED+&quot;&lt;/p&gt;&quot;).equals(editedDoc.getData().trim())) {</span>
<span class="nc" id="L201">			throw new RuntimeException(prop.getText(&quot;components.docman.errorLoadingData&quot;)+&quot; &quot;+editedDoc.getDocId());</span>
		}

		//over, ci sa nezmenil adresar, ak ano, musis spravit reload stromu
<span class="fc bfc" id="L205" title="All 2 branches covered.">		if(editedDoc.getDocId() &gt; 0) {</span>
<span class="fc" id="L206">			int oldGroupId = docRepo.getGroupId(editedDoc.getDocId()).intValue();</span>
<span class="pc bpc" id="L207" title="1 of 4 branches missed.">			if (oldGroupId &gt; 0 &amp;&amp; oldGroupId != editedDoc.getGroupId()) forceReload = true;</span>
		}

		//kontrola prav
<span class="fc" id="L211">		checkPermissions(currentUser, editedDoc, false);</span>

<span class="pc bpc" id="L213" title="1 of 2 branches missed.">		if(Constants.getBoolean(&quot;editorEscapeInvalidCharacters&quot;)) {</span>
<span class="nc" id="L214">			editedDoc.setTitle(EditorUtils.escapeInvalidCharacters(editedDoc.getTitle(), prop, notify));</span>
<span class="nc" id="L215">			editedDoc.setData(EditorUtils.escapeInvalidCharacters(editedDoc.getData(), prop, notify));</span>
<span class="nc" id="L216">			editedDoc.setHtmlData(EditorUtils.escapeInvalidCharacters(editedDoc.getHtmlData(), prop, notify));</span>
		}

		//cloud - aby nebolo mozne premenovat Header / Footer
<span class="fc" id="L220">		DocDetails existing = CloudToolsForCore.isPossibleToChangeDoc(editedDoc.getDocId());</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">		if (existing != null) {</span>
			//nemozeme menit title ani groupid
<span class="nc" id="L223">			editedDoc.setTitle(existing.getTitle());</span>
<span class="nc" id="L224">			editedDoc.setGroupId(existing.getGroupId());</span>
		}

		//kvoli Oracle, on nedokaze mat v DB prazdny string a potom to padalo
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">		if (Tools.isEmpty(editedDoc.getTitle())) editedDoc.setTitle(&quot;new web page&quot;);</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">		if (Tools.isEmpty(editedDoc.getNavbar())) editedDoc.setNavbar(editedDoc.getTitle());</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">		if (Tools.isEmpty(editedDoc.getData())) editedDoc.setData(&quot;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&quot;);</span>

		//nastav virtual path
<span class="fc" id="L233">		setVirtualPath(editedDoc);</span>
<span class="fc" id="L234">		dt.diff(&quot;after virtual path&quot;);</span>

<span class="fc" id="L236">		EditorUtils.nonBreakingSpaceReplacement(editedDoc);</span>

		//data nechceme mat ulozene s context linkami (tie nam prida filter, ak treba)
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">		if (ContextFilter.isRunning(request))</span>
<span class="nc" id="L240">			editedDoc.setData(ContextFilter.removeContextPath(request.getContextPath(), editedDoc.getData()));</span>

<span class="fc" id="L242">		String data = EditorUtils.getCleanBody(editedDoc.getData().trim());</span>
<span class="fc" id="L243">		dt.diff(&quot;after getCleanBody&quot;);</span>

<span class="fc" id="L245">		String dataAsc = EditorUtils.getDataAsc(data, editedDoc, false, request);</span>
<span class="fc" id="L246">		dt.diff(&quot;after getDataAsc&quot;);</span>

<span class="fc" id="L248">		editedDoc.setData(data);</span>
<span class="fc" id="L249">		editedDoc.setDataAsc(dataAsc);</span>

		//It's new page ?
<span class="fc bfc" id="L252" title="All 2 branches covered.">		if (editedDoc.getDocId() &lt; 1) {</span>
<span class="fc" id="L253">			isNewPage = true;</span>

			//If new page do not request publish, disable page
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">			if(!editedDoc.getEditorFields().isRequestPublish()) editedDoc.setAvailable(false);</span>
		}

		// Load approve hash table data
		// If current user is approver, set selfApprover = true
<span class="fc bfc" id="L261" title="All 2 branches covered.">		if (editedDoc.getEditorFields().isRequestPublish()) {</span>
<span class="fc" id="L262">			approveService.loadApproveTables(editedDoc.getGroupId());</span>

			//If approver is needed BUT it's not selfApprove (currentUser isn't approver),
			//publish is NOT allowed (set publish as false) -&gt; because it's gonna waiting for approve
<span class="pc bpc" id="L266" title="1 of 4 branches missed.">			if(approveService.needApprove() &amp;&amp; !approveService.isSelfApproved())</span>
<span class="fc" id="L267">				editedDoc.getEditorFields().setRequestPublish(false);</span>
		}
<span class="fc" id="L269">		dt.diff(&quot;after requestPublish&quot;);</span>

<span class="fc" id="L271">		DocHistory editedHistory = DocDetailsToDocHistoryMapper.INSTANCE.docDetailsToDocHistory(editedDoc);</span>

<span class="fc bfc" id="L273" title="All 2 branches covered.">		if (isNewPage) {</span>
			//Save (insert) new webpage
<span class="fc" id="L275">			insertWebpage(editedDoc, dt);</span>
<span class="fc" id="L276">			editedHistory.setDocId(editedDoc.getDocId());</span>
		} else {
			//Update exist webpage
<span class="fc" id="L279">			updateWebpage(editedDoc, dt);</span>
		}

<span class="fc" id="L282">		dt.diff(&quot;after savedata, webpage Insert/Update&quot;);</span>

<span class="fc bfc" id="L284" title="All 2 branches covered.">		if (editedDoc.getEditorFields().isRequestPublish()) {</span>
<span class="fc" id="L285">				pageSavedToPublic = true;</span>
		} else {
<span class="fc bfc" id="L287" title="All 2 branches covered.">			if (editedDoc.isPublishAfterStart()){</span>
<span class="fc" id="L288">				publihStart = Long.valueOf(editedDoc.getPublishStart());</span>
			} else {
<span class="fc" id="L290">				pageSavedAsWorkVersion = true;</span>
			}
		}
<span class="fc" id="L293">		dt.diff(&quot;after session set&quot;);</span>

		//vypne zapisovanie zaznamov do documents_history tabulky. true - nezapise zaznam do documents_history
<span class="fc" id="L296">		boolean disableHistory = Constants.getBoolean(&quot;editorDisableHistory&quot;);</span>
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">		if(disableHistory) {</span>
<span class="nc" id="L298">			Logger.debug(EditorService.class, &quot;Write into documents_history is disabled&quot;);</span>
<span class="nc" id="L299">			historyId = 1;</span>
		}

		// If history is not disabled
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">		if (!disableHistory) {</span>
			// zisti, ci v historii na ten isty datum a cas nema byt nieco vypublikovane
<span class="fc bfc" id="L305" title="All 4 branches covered.">			if (editedDoc.getPublishStartDate() != null &amp;&amp; (editedDoc.getPublishStartDate().getTime()+60000)&gt;Tools.getNow()) {</span>
<span class="fc" id="L306">				List&lt;DocHistory&gt; waitingForPublish = historyRepo.findByDocIdAndPublishStartDate(editedDoc.getDocId(), editedDoc.getPublishStartDate());</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">				if (waitingForPublish != null) {</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">					for (DocHistory waiting : waitingForPublish) {</span>
<span class="fc" id="L309">						waiting.setPublicable(false);</span>
<span class="fc" id="L310">						waiting.setSyncStatus(1);</span>
<span class="fc" id="L311">						historyRepo.save(waiting);</span>
<span class="fc" id="L312">					}</span>
				}
			}
<span class="fc" id="L315">			dt.diff(&quot;after dochist is publicable&quot;);</span>

			// DocHistory entity, that represent change of original webpage (DocDetails entity)
<span class="fc" id="L318">			editedHistory.setPublicable(Boolean.valueOf(editedDoc.isPublishAfterStart()));</span>
<span class="fc" id="L319">			editedHistory.setData(data);</span>
<span class="fc" id="L320">			editedHistory.setDataAsc(dataAsc);</span>
<span class="fc" id="L321">			editedHistory.setSaveDate(new Date(now));</span>
<span class="fc" id="L322">			editedHistory.setActual(editedDoc.getEditorFields().isRequestPublish());</span>

			//Set ApprovedBy value, that indicate approve status
<span class="fc bfc" id="L325" title="All 2 branches covered.">			if (approveService.needApprove()) {</span>
				//Need approve
<span class="fc" id="L327">				editedHistory.setApprovedBy(-1);</span>
			} else {
				// Do not need approve
<span class="fc bfc" id="L330" title="All 2 branches covered.">				if(approveService.isSelfApproved()) {</span>
					//Page created by approver (automatic self approved), set approver id
<span class="fc" id="L332">					editedHistory.setApprovedBy(currentUser.getUserId());</span>
<span class="fc" id="L333">					wasApproved = true;</span>
				} else {
					//Not self approved, but do not need approve (probably folder that do not require approve)
<span class="fc bfc" id="L336" title="All 2 branches covered.">					if (editedDoc.getEditorFields().isRequestPublish()) {</span>
						//Publish without approver, soo approver is 0
<span class="fc" id="L338">						editedHistory.setApprovedBy(0);</span>
<span class="fc" id="L339">						wasApproved = true;</span>
					} else {
						//Do not publish, approver is -1
<span class="fc" id="L342">						editedHistory.setApprovedBy(-1);</span>
					}
				}
			}

<span class="fc bfc" id="L347" title="All 4 branches covered.">			if (!editedHistory.getEditorFields().isRequestPublish() &amp;&amp; approveService.needApprove())</span>
<span class="fc" id="L348">				editedHistory.setAwaitingApprove(&quot;,&quot; + approveService.getApproveUserIds() + &quot;,&quot;);</span>
			else
<span class="fc" id="L350">				editedHistory.setAwaitingApprove(null);</span>


			//Save edited history
<span class="fc" id="L354">			historyRepo.save(editedHistory);</span>
<span class="fc" id="L355">			dt.diff(&quot;after dochistory insert&quot;);</span>

			//ziskaj history_id
<span class="fc" id="L358">			historyId = editedHistory.getHistoryId();</span>
<span class="fc" id="L359">			dt.diff(&quot;after dochistory get id&quot;);</span>

<span class="fc" id="L361">			RequestBean.addAuditValue(&quot;historyId&quot;, String.valueOf(historyId));</span>

			//Publishing
<span class="fc bfc" id="L364" title="All 2 branches covered.">			if(wasApproved) deleteHistorySaveRecords(editedDoc, editedHistory, historyId, dt);</span>
		}

		/*Odoslanie schvalovani a notifikacii*/
<span class="fc" id="L368">		approveService.sendEmails(editedDoc, historyId);</span>
<span class="fc" id="L369">		dt.diff(&quot;after sendApproveNotifyEmail&quot;);</span>

<span class="pc bpc" id="L371" title="1 of 6 branches missed.">		if(isNewPage || wasApproved || disableHistory) {</span>
			//In case of insert, actions are needed because page was saved, even when isn't approved
			// !! without this actions, insert page return 404
<span class="fc" id="L374">			renameVirtualPath(editedDoc, dt);</span>
<span class="fc" id="L375">			refreshCacheObjects(editedDoc, dt);</span>
<span class="fc" id="L376">			refreshTemplates(editedDoc, dt);</span>
<span class="pc bpc" id="L377" title="1 of 4 branches missed.">		} else if(editedDoc.isPublishAfterStart() || editedDoc.isDisableAfterEnd()) {</span>
			//reload awaiting pages for DocDB
<span class="fc" id="L379">			docDB.readPagesToPublic();</span>
		}

		/*Ulozenie poznamky*/
<span class="fc" id="L383">		saveRedactorNote(editedDoc, historyId);</span>
<span class="fc" id="L384">		dt.diff(&quot;after instances&quot;);</span>

		/*Finish*/
<span class="fc" id="L387">		dt.diff(&quot;done&quot;);</span>

		//Publikovanie eventov
<span class="fc" id="L390">		(new WebjetEvent&lt;&gt;(editedDoc, WebjetEventType.AFTER_SAVE)).publishEvent();</span>

<span class="fc" id="L392">		return(historyId);</span>
 	}

	/**
	 * Vrati instanciu noveho DocDetails
	 * @param docId - -1 alebo -DOCID sablony prazdnej stranky
	 * @param group - adresar kde ma vzniknut (podla toho sa nastavi sablona, sort priority...)
	 * @return
	 */
	public DocDetails prepareNewDocForEditor(int docId, GroupDetails group) {
		//ak je to admin
<span class="fc" id="L403">		DocDetails editedDoc = null;</span>
		//-1 je cisty dokument
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">		if (docId &lt; -1) {</span>
<span class="nc" id="L406">			editedDoc = getDoc(-docId, -1);</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">			if (editedDoc != null) {</span>
<span class="nc" id="L408">				editedDoc.setDocId(-1);</span>
			}
		}

<span class="pc bpc" id="L412" title="1 of 2 branches missed.">		if (editedDoc == null) {</span>
<span class="fc" id="L413">			editedDoc = new DocDetails();</span>
<span class="fc" id="L414">			editedDoc.setDocId(-1);</span>
<span class="fc" id="L415">			editedDoc.setGroupId(group.getGroupId());</span>
<span class="fc" id="L416">			editedDoc.setData(&quot;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&quot;);</span>
<span class="fc" id="L417">			editedDoc.setTitle(prop.getText(&quot;editor.newDocumentName&quot;));</span>
<span class="fc" id="L418">			editedDoc.setSearchable(true);</span>
<span class="fc" id="L419">			editedDoc.setAvailable(Constants.getBoolean(&quot;editorNewDocDefaultAvailableChecked&quot;));</span>
<span class="fc" id="L420">			editedDoc.setShowInMenu(true);</span>
<span class="fc" id="L421">			editedDoc.setSortPriority(10);</span>
		} else {
			//nastav grupu na aktualne vybratu
<span class="nc" id="L424">			editedDoc.setDocId(-1);</span>
<span class="nc" id="L425">			editedDoc.setGroupId(group.getGroupId());</span>
<span class="nc" id="L426">			editedDoc.setTitle(prop.getText(&quot;editor.newDocumentName&quot;));</span>
<span class="nc" id="L427">			editedDoc.setNavbar(&quot;&quot;);</span>
<span class="nc" id="L428">			editedDoc.setVirtualPath(&quot;&quot;);</span>
<span class="nc" id="L429">			editedDoc.setExternalLink(&quot;&quot;);</span>
<span class="nc" id="L430">			editedDoc.setEventDateString(&quot;&quot;);</span>
<span class="nc" id="L431">			editedDoc.setEventTimeString(&quot;&quot;);</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">			if (Constants.getBoolean(&quot;editorNewDocDefaultAvailableChecked&quot;) == false) editedDoc.setAvailable(false);</span>
		}

<span class="fc" id="L435">		editedDoc.setTempId(group.getTempId());</span>
		/*zisti maximalnu prioritu a zvys o 10*/
<span class="fc" id="L437">		editedDoc.setSortPriority(0);</span>
<span class="fc" id="L438">		boolean dirIsEmpty = setSortPriority(editedDoc, group);</span>

<span class="fc bfc" id="L440" title="All 2 branches covered.">		if (dirIsEmpty) {</span>
<span class="fc" id="L441">			editedDoc.setTitle(group.getGroupName());</span>
<span class="fc" id="L442">			editedDoc.setNavbar(group.getNavbarName());</span>
		}

<span class="fc" id="L445">		WebpagesService.processFromEntity(editedDoc, ProcessItemAction.GETONE, request, true);</span>

<span class="fc" id="L447">		return editedDoc;</span>
	}

	/**
	 * Set next available sort priority for doc
	 * @param editedDoc
	 * @param group
	 * @return
	 */
	public boolean setSortPriority(DocDetails editedDoc, GroupDetails group) {
<span class="fc" id="L457">		boolean dirIsEmpty = true;</span>
<span class="fc" id="L458">		int maxPriority = DocDB.getMaxSortPriorityInGroup(group.getGroupId());</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">		if(maxPriority &gt; 0) {</span>
<span class="fc" id="L460">			editedDoc.setSortPriority(maxPriority);</span>
<span class="fc" id="L461">			dirIsEmpty = false;</span>
		}

<span class="fc" id="L464">		int sortPriorityIncrementDoc = Constants.getInt(&quot;sortPriorityIncrementDoc&quot;);</span>
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">		if (Constants.getBoolean(&quot;sortPriorityIncremental&quot;)) {</span>
<span class="fc" id="L466">			GroupDetails parentGroup = groupsDB.getGroup(group.getParentGroupId());</span>
<span class="fc bfc" id="L467" title="All 4 branches covered.">			if (parentGroup != null &amp;&amp; maxPriority &lt; parentGroup.getSortPriority()) {</span>
				//-10 lebo sa nam to o par riadkov nizsie navysi o 10
<span class="fc" id="L469">				maxPriority = parentGroup.getSortPriority() - sortPriorityIncrementDoc;</span>
<span class="fc" id="L470">				editedDoc.setSortPriority(maxPriority);</span>
			}
		}

<span class="fc" id="L474">		editedDoc.setSortPriority(editedDoc.getSortPriority() + sortPriorityIncrementDoc);</span>
<span class="fc" id="L475">		return dirIsEmpty;</span>
	}

	/**
	 * Vrati existujuci DocDetails objekt podla zadaneho historyId/docId.
	 *
	 * Riesi aj problem s MultigroupMaping, kedy nacita udaje master dokumentu.
	 *
	 * @param docId
	 * @param historyId
	 * @return
	 */
	public DocDetails prepareDocForEditor(int docId, int historyId) {
<span class="nc" id="L488">		return prepareDocForEditor(docId, historyId, false);</span>
	}

	/**
	 * Vrati existujuci DocDetails objekt podla zadaneho historyId/docId.
	 * ak je ignoreMultigroupMapping=false Riesi aj problem s MultigroupMaping, kedy nacita udaje master dokumentu.
	 *
	 * @param docId
	 * @param historyId
	 * @param ignoreMultigroupMapping
	 * @return
	 */
	public DocDetails prepareDocForEditor(int docId, int historyId, boolean ignoreMultigroupMapping) {
<span class="fc" id="L501">		int docIdOriginal = docId;</span>

		//moznost nacitat slave data
		//int masterId = (request.getAttribute(&quot;keepSlave&quot;) != null &amp;&amp; &quot;true&quot;.equals(request.getAttribute(&quot;keepSlave&quot;))) ? 0 : MultigroupMappingDB.getMasterDocId(docId);
<span class="fc" id="L505">		int masterId = MultigroupMappingDB.getMasterDocId(docId);</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">        if(masterId &gt; 0) docId = masterId;</span>


<span class="fc" id="L509">		DocDetails editedDoc = null;</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">		if (historyId &gt; 0) {</span>
<span class="fc" id="L511">			editedDoc = getDoc(-1, historyId);</span>
		} else {
<span class="fc" id="L513">			editedDoc = getDoc(docId, -1);</span>
		}

<span class="pc bpc" id="L516" title="1 of 2 branches missed.">		if (editedDoc == null) {</span>
<span class="nc" id="L517">			return(null);</span>
		} else {
<span class="fc" id="L519">			WebpagesService.processFromEntity(editedDoc, ProcessItemAction.GETONE, request, true);</span>

			//ak nacitavam slave clanok a chcem zachovat sort priority, tak NEnacitavam sort priority mastra
<span class="fc" id="L522">			boolean multiGroupkeepSortPriority = Constants.getBoolean(&quot;multiGroupKeepSortPriority&quot;);</span>
<span class="pc bpc" id="L523" title="1 of 4 branches missed.">			if(multiGroupkeepSortPriority &amp;&amp; masterId &gt; 0) {</span>
<span class="fc" id="L524">				DocDetails slave = docDB.getBasicDocDetails(docIdOriginal, false);</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">				if(slave != null) editedDoc.setSortPriority(slave.getSortPriority());</span>
			}
		}

		//ak sa nacital slave dokument, nastav povodne ID, aby to v editore korektne nacitalo
<span class="fc bfc" id="L530" title="All 2 branches covered.">		if (masterId &gt; 0) {</span>
<span class="fc" id="L531">			editedDoc.setDocId(docIdOriginal);</span>

			//keep virtual path
<span class="fc" id="L534">			DocDetails slave = docDB.getBasicDocDetails(docIdOriginal, false);</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">			if (slave != null) editedDoc.setVirtualPath(slave.getVirtualPath());</span>
		}

<span class="fc" id="L538">		return editedDoc;</span>
	}

	/**
	 * Ulozi novo vytvorenu web stranku do databazy
	 * @param editedDoc
	 * @param requestPublish
	 * @param dt
	 * @param data
	 * @param dataAsc
	 */
	private void insertWebpage(DocDetails editedDoc, DebugTimer dt) {
		//Request publish could be set as false during loadApproveTables action (when author has no right to do this, and approve is needed)
<span class="fc bfc" id="L551" title="All 2 branches covered.">		if (editedDoc.getEditorFields().isRequestPublish() == false) {</span>
<span class="fc" id="L552">			editedDoc.setAvailable(false);</span>
		} else {
			//If user has right, check if publish is in the future
<span class="fc bfc" id="L555" title="All 2 branches covered.">			if (editedDoc.isPublishAfterStart()) {</span>
				//When to publish
<span class="fc" id="L557">				long publishStart = editedDoc.getPublishStart();</span>
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">				if(publishStart != 0) {</span>
					//Is publish in the future ?
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">					if (publishStart &gt; now) {</span>
						//For now, cancel publish and availability
<span class="fc" id="L562">						editedDoc.getEditorFields().setRequestPublish(false);</span>
<span class="fc" id="L563">						editedDoc.setAvailable(false);</span>

						//Add note when this is gonna be publish
						//Change data
<span class="fc" id="L567">						String publishDocData = prop.getText(&quot;editor.publish.note&quot;) + &quot; &quot; + editedDoc.getPublishStartString() + &quot; &quot; + editedDoc.getPublishStartTimeString();</span>
<span class="fc" id="L568">						editedDoc.setData(publishDocData);</span>
<span class="fc" id="L569">						editedDoc.setDataAsc(EditorUtils.getDataAsc(publishDocData, editedDoc, false, request));</span>
					}
				}
			}
		}

		//Unlike update, insert is gonna happen even if user have no rights
		//Reason is to show webpage to user, but page still need to be approve and is marked as red (waiting for approve)
<span class="fc" id="L577">		docSave(editedDoc, true, dt);</span>
<span class="fc" id="L578">	}</span>

	/**
	 * Ulozi do databazy existujucu web stranku
	 * @param editedDoc
	 * @param requestPublish
	 * @param dt
	 */
	private void updateWebpage(DocDetails editedDoc, DebugTimer dt) {
		//premenovanie Groupy ak je stranka defaultna pre Grupu.
<span class="fc bfc" id="L588" title="All 2 branches covered.">		if(GroupsService.canSyncTitle(editedDoc.getDocId(), editedDoc.getGroupId())) {</span>
<span class="fc" id="L589">			DocDB.changeGroupTitle(editedDoc.getGroupId(), editedDoc.getDocId(), editedDoc.getTitle());</span>
<span class="fc" id="L590">			forceReload = true;</span>
		}

		//Request publish could be set as false during loadApproveTables action (when author has no right to do this, and approve is needed)
<span class="fc bfc" id="L594" title="All 2 branches covered.">		if (editedDoc.getEditorFields().isRequestPublish() == false) {</span>
<span class="fc" id="L595">			editedDoc.setAvailable(false);</span>
		} else {
			//If user has right, check if publish is in the future
<span class="fc bfc" id="L598" title="All 2 branches covered.">			if (editedDoc.isPublishAfterStart()) {</span>
				//When to publish
<span class="fc" id="L600">				long publishStart = editedDoc.getPublishStart();</span>
<span class="pc bpc" id="L601" title="1 of 2 branches missed.">				if(publishStart != 0) {</span>
					//Is publish in the future ?
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">					if (publishStart &gt; now) {</span>
						//For now, cancel publish and availability
<span class="fc" id="L605">						editedDoc.getEditorFields().setRequestPublish(false);</span>
<span class="fc" id="L606">						editedDoc.setAvailable(false);</span>
					}
				}
			}
		}

		//Unlike insert, update is gonna happen only IF requestPublish = true (sooo user have rights to do that)
<span class="fc bfc" id="L613" title="All 2 branches covered.">		if (editedDoc.getEditorFields().isRequestPublish()) docSave(editedDoc, false, dt);</span>
<span class="fc" id="L614">	}</span>

	/**
	 * Zmazanie web stranky, kontroluje prava pouzivatela, ak nema prava throwne RuntimeException
	 * @param doc
	 * @param publishEvents - true to publish WebjetEvents (default true)
	 * @return
	 */
	@SuppressWarnings(&quot;java:S3516&quot;)
	public boolean deleteWebpage(DocDetails doc, boolean publishEvents) {
<span class="fc" id="L624">		String result = deleteWebpageLogic(doc.getDocId(), approveService, publishEvents);</span>

		//All good
<span class="fc bfc" id="L627" title="All 2 branches covered.">		if(&quot;success&quot;.equals(result)) return true;</span>

		//Delete needs to be approved
<span class="pc bpc" id="L630" title="1 of 2 branches missed.">		if(prop.getText(&quot;approveAction.err.cantApprove&quot;).equals(result)) {</span>
<span class="fc" id="L631">			StringBuilder approversString = new StringBuilder();</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">			for(UserDetails approver : approveService.getApprovers()) {</span>
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">				if(!approversString.isEmpty()) approversString.append(&quot;, &quot;);</span>
<span class="fc" id="L634">				approversString.append(approver.getFullName());</span>
<span class="fc" id="L635">			}</span>
<span class="fc" id="L636">			NotifyBean info = new NotifyBean(prop.getText(&quot;editor.approve.notifyTitle&quot;), prop.getText(&quot;editor.approveDeleteRequestGet&quot;)+&quot;: &quot;+approversString.toString(), NotifyBean.NotifyType.INFO, 60000);</span>
<span class="fc" id="L637">            addNotify(info);</span>

<span class="fc" id="L639">			return true;</span>
		}

		//Something wrong
<span class="nc" id="L643">		throw new RuntimeException(result);</span>
	}

	/**
	 * Pri funkcii Ulozit rozprazovanu verziu sa v history tabulke kopia pracovne zaznamy, tie pri publikovani zmazeme, ponechame len podla approveHistoryId
	 * @param editedDoc
	 * @param editedHistory
	 * @param historyId
	 * @param dt
	 */
	private void deleteHistorySaveRecords(DocDetails editedDoc, DocHistory editedHistory, int historyId, DebugTimer dt) {
		// zmaz stare dokumenty, ktore nie su schvalene
		List&lt;Integer&gt; historyIds;

<span class="fc" id="L657">		historyIds = historyRepo.findOldHistoryIds(editedHistory.getDocId(), Long.valueOf(historyId), false, currentUser.getUserId());</span>
<span class="fc" id="L658">		dt.diff(&quot;after was_approved history_id list&quot;);</span>

<span class="fc bfc" id="L660" title="All 2 branches covered.">		if (historyIds.isEmpty()==false) {</span>
<span class="fc" id="L661">			historyRepo.deleteHistoryOnPublish(historyIds, currentUser.getUserId());</span>
<span class="fc" id="L662">			dt.diff(&quot;after was_approved delete&quot;);</span>
		}

		//nastav aktualne na actual=false
<span class="fc" id="L666">		historyIds = historyRepo.findOldHistoryIds(editedDoc.getDocId(), historyId);</span>

<span class="fc bfc" id="L668" title="All 2 branches covered.">		if (historyIds.isEmpty()==false) historyRepo.updateActualHistory(false, &quot;&quot;, historyIds);</span>
<span class="fc" id="L669">		dt.diff(&quot;after was_approved&quot;);</span>
<span class="fc" id="L670">	}</span>

	/**
	 * Nastavi databazove stlpce root_group_lX s hodnotami ID adresarov na 1-3 urovni
	 * @param groupId
	 * @param editedDoc
	 */
	private void setRootGroupL(int groupId, DocDetails editedDoc) {
<span class="fc" id="L678">		List&lt;GroupDetails&gt; parentGroups = groupsDB.getParentGroups(groupId);</span>
<span class="fc" id="L679">		int[] rootGroupL = new int[3];</span>
<span class="fc" id="L680">		Arrays.fill(rootGroupL, 0);</span>
<span class="fc" id="L681">		int ind = 0;</span>

<span class="fc bfc" id="L683" title="All 2 branches covered.">		for(int i=parentGroups.size()-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L684">			rootGroupL[ind++] = parentGroups.get(i).getGroupId();</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">			if(ind == 3) break;</span>
		}

<span class="pc bpc" id="L688" title="1 of 2 branches missed.">		if(editedDoc != null) {</span>
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">			if(rootGroupL[0] &gt; 0) editedDoc.setRootGroupL1(rootGroupL[0]);</span>
<span class="nc" id="L690">			else editedDoc.setRootGroupL1(null);</span>

<span class="fc bfc" id="L692" title="All 2 branches covered.">			if(rootGroupL[1] &gt; 0) editedDoc.setRootGroupL2(rootGroupL[1]);</span>
<span class="fc" id="L693">			else editedDoc.setRootGroupL2(null);</span>

<span class="fc bfc" id="L695" title="All 2 branches covered.">			if(rootGroupL[2] &gt; 0) editedDoc.setRootGroupL3(rootGroupL[2]);</span>
<span class="fc" id="L696">			else editedDoc.setRootGroupL3(null);</span>
		}
<span class="fc" id="L698">	}</span>

	/**
	 * Ulozi poznamku redaktora (alebo zmaze, ak je prazdna)
	 * @param editedDoc
	 * @param historyId
	 */
	private void saveRedactorNote(DocDetails editedDoc, int historyId) {
		//ulozenie poznamky pre redaktorov k webstranke
<span class="fc" id="L707">		DocNoteBean note = docNoteDB.getDocNote(editedDoc.getDocId(), -1);</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">		if(Tools.isNotEmpty(editedDoc.getEditorFields().getRedactorNote())) {</span>
			//ak je my_form.getEditorFields().isPublishAfterStart()==true, tak sa stranka publikuje v buducnosti. Poznamka sa nastavy v DocDB.copyDHistory(List&lt;PublicableForm&gt; copyDHtoD) a nie tu
<span class="pc bpc" id="L710" title="2 of 4 branches missed.">			if(editedDoc.getEditorFields().isRequestPublish() &amp;&amp; !editedDoc.getEditorFields().isPublishAfterStart()) {</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">				if(note == null) note = new DocNoteBean();</span>
<span class="fc" id="L712">				note.setDocId(editedDoc.getDocId());</span>
<span class="fc" id="L713">				note.setHistoryId(-1);</span>
<span class="fc" id="L714">				note.setNote(editedDoc.getEditorFields().getRedactorNote());</span>
<span class="fc" id="L715">				note.setUserId(editedDoc.getAuthorId());</span>
<span class="fc" id="L716">				note.setCreated(new Date());</span>
<span class="fc" id="L717">				note.save();</span>
			}

			//historia sa ulozi stale
<span class="fc" id="L721">			DocNoteBean noteHistory = docNoteDB.getDocNote(-1, historyId);</span>
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">			if(noteHistory == null) noteHistory = new DocNoteBean();</span>
<span class="fc" id="L723">			noteHistory.setDocId(-1);</span>
<span class="fc" id="L724">			noteHistory.setHistoryId(historyId);</span>
<span class="fc" id="L725">			noteHistory.setNote(editedDoc.getEditorFields().getRedactorNote());</span>
<span class="fc" id="L726">			noteHistory.setUserId(editedDoc.getAuthorId());</span>
<span class="fc" id="L727">			noteHistory.setCreated(new Date());</span>
<span class="fc" id="L728">			noteHistory.save();</span>
<span class="pc bpc" id="L729" title="1 of 2 branches missed.">		} else if(note != null) {</span>
			//ak je zadana poznamka z formulara prazdna, tak existujucu note k stranke vymazeme
<span class="nc" id="L731">			note.delete();</span>
		}
<span class="fc" id="L733">	}</span>

	/**
	 * Nastavi stranke URL adresu (virtual_path), ak uz nejaka ina stranka takuto URL ma, tak prida cislo 1,2,3... na koniec URL adresy
	 * @param editedDoc
	 */
	protected void setVirtualPath(DocDetails editedDoc) {
<span class="fc" id="L740">		String domain = groupsDB.getDomain(editedDoc.getGroupId());</span>
<span class="fc" id="L741">		int virtualPathConflictDocId = -1;</span>
<span class="pc bpc" id="L742" title="2 of 4 branches missed.">		if (Constants.getInt(&quot;linkType&quot;) == Constants.LINK_TYPE_HTML &amp;&amp; editedDoc.getVirtualPath().startsWith(&quot;javascript:&quot;) == false) {</span>
<span class="fc" id="L743">			boolean mustGenerateVirtualPath = false;</span>
<span class="fc bfc" id="L744" title="All 2 branches covered.">			if (Tools.isNotEmpty(editedDoc.getVirtualPath())) {</span>
<span class="fc" id="L745">				int actualDocId = DocDB.getDocIdFromURL(editedDoc.getVirtualPath(), domain);</span>
<span class="fc bfc" id="L746" title="All 4 branches covered.">				if (actualDocId &gt; 0 &amp;&amp; actualDocId != editedDoc.getDocId()) {</span>
<span class="fc" id="L747">					mustGenerateVirtualPath = true;</span>
<span class="fc" id="L748">					virtualPathConflictDocId = actualDocId;</span>
				}
			}

<span class="pc bpc" id="L752" title="1 of 6 branches missed.">			if (mustGenerateVirtualPath || Tools.isEmpty(editedDoc.getVirtualPath()) || editedDoc.getVirtualPath().indexOf('/') == -1) {</span>
				//nastavime ako treba
<span class="fc" id="L754">				String groupDiskPath = DocDB.getGroupDiskPath(groupsDB.getGroupsAll(), editedDoc.getGroupId());</span>
<span class="fc" id="L755">				DocDetails doc = new DocDetails();</span>
<span class="fc" id="L756">				doc.setDocId(editedDoc.getDocId());</span>
<span class="fc" id="L757">				doc.setTitle(editedDoc.getTitle());</span>
<span class="fc" id="L758">				doc.setNavbar(DB.prepareString(editedDoc.getNavbar(), 128));</span>
<span class="fc" id="L759">				doc.setVirtualPath(editedDoc.getVirtualPath());</span>
<span class="fc" id="L760">				doc.setGroupId(editedDoc.getGroupId());</span>
<span class="fc" id="L761">				String virtualPath = DocDB.getURL(doc, groupDiskPath);</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">				String ending = virtualPath.endsWith(&quot;/&quot;) ? &quot;/&quot; : &quot;.html&quot;;</span>
<span class="fc" id="L763">				String editorPageExtension = Constants.getString(&quot;editorPageExtension&quot;);</span>

<span class="fc" id="L765">				String lastVirtualPath = null;</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">				for (long i = 2; i &lt; 1000; i++) {</span>

<span class="fc bfc" id="L768" title="All 2 branches covered.">					if (i&gt;990) i = Tools.getNow();</span>

<span class="pc bpc" id="L770" title="2 of 4 branches missed.">					if(virtualPath != null &amp;&amp; virtualPath.length() &gt; 255) {</span>
<span class="nc" id="L771">						String vpTmp = virtualPath.substring(0, virtualPath.length() - ending.length());</span>
<span class="nc" id="L772">						vpTmp = DB.prepareString(vpTmp, 255 - ending.length()) + ending;</span>
<span class="nc" id="L773">						virtualPath = vpTmp;</span>
					}

<span class="fc" id="L776">					int allreadyDocId = DocDB.getDocIdFromURL(virtualPath, domain);</span>
<span class="fc" id="L777">					Logger.debug(EditorService.class, &quot;setVirtualPath: allreadyDocId for virtualPath: &quot; + virtualPath + &quot; ,docid: &quot; + allreadyDocId);</span>

<span class="fc bfc" id="L779" title="All 4 branches covered.">					if (allreadyDocId &lt;= 0 || allreadyDocId == editedDoc.getDocId()) { break; }</span>

					//lebo moze kolidovat uz z hora
<span class="fc bfc" id="L782" title="All 2 branches covered.">					if (virtualPathConflictDocId &lt; 1) virtualPathConflictDocId = allreadyDocId;</span>

<span class="fc" id="L784">					doc.setTitle(editedDoc.getTitle() + &quot; &quot; + i);</span>
<span class="fc" id="L785">					doc.setNavbar(DB.prepareString(editedDoc.getNavbar(), 128) + &quot; &quot; + i);</span>

<span class="fc bfc" id="L787" title="All 2 branches covered.">					if (&quot;/&quot;.equals(editorPageExtension)) {</span>
						//nastav cistu, handluje sa to nastavenim title s cislom vyssie
<span class="fc" id="L789">						doc.setVirtualPath(&quot;&quot;);</span>
					}
					else {
<span class="fc bfc" id="L792" title="All 2 branches covered.">						if (editedDoc.getVirtualPath().endsWith(&quot;.html&quot;)) {</span>
<span class="fc" id="L793">							doc.setVirtualPath(Tools.replace(editedDoc.getVirtualPath(), &quot;.html&quot;, &quot;-&quot; + i + &quot;.html&quot;));</span>
<span class="fc" id="L794">							ending = &quot;-&quot; + i + &quot;.html&quot;;</span>
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">						} else if (editedDoc.getVirtualPath().endsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L796">							doc.setVirtualPath(editedDoc.getVirtualPath() + i + &quot;.html&quot;);</span>
<span class="nc" id="L797">							ending = i + &quot;.html&quot;;</span>
<span class="pc bpc" id="L798" title="2 of 6 branches missed.">						} else if (Tools.isNotEmpty(editedDoc.getVirtualPath()) &amp;&amp; editedDoc.getVirtualPath().endsWith(&quot;/&quot;)==false &amp;&amp; editedDoc.getVirtualPath().contains(&quot;.html&quot;)==false) {</span>
							//url without last slash and without .html like /aaa/bbb
<span class="fc" id="L800">							doc.setVirtualPath(editedDoc.getVirtualPath() + &quot;-&quot; + i + &quot;.html&quot;);</span>
<span class="fc" id="L801">							ending = i + &quot;.html&quot;;</span>
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">						} else if (Tools.isEmpty(editedDoc.getVirtualPath())) {</span>
<span class="fc" id="L803">							ending = &quot;.html&quot;;</span>
						}
					}

<span class="fc" id="L807">					virtualPath = DocDB.getURL(doc, groupDiskPath);</span>

<span class="pc bpc" id="L809" title="1 of 4 branches missed.">					if (lastVirtualPath != null &amp;&amp; lastVirtualPath.equals(virtualPath)) {</span>
<span class="nc" id="L810">						long fixedI = i - 100;</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">						if (fixedI &lt; 2) fixedI = 2;</span>
						//virtualPath is not changing, it is probably main page of folder, add number to the end
<span class="nc bnc" id="L813" title="All 2 branches missed.">						if (virtualPath.contains(&quot;.html&quot;)) {</span>
							//add number before .html
<span class="nc" id="L815">							virtualPath = virtualPath.substring(0, virtualPath.lastIndexOf(&quot;.html&quot;)) + &quot;-&quot; + fixedI + &quot;.html&quot;;</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">						} else if (virtualPath.endsWith(&quot;/&quot;)) {</span>
							//add number before last slash
<span class="nc" id="L818">							virtualPath = virtualPath.substring(0, virtualPath.length() - 1) + &quot;-&quot; + fixedI + &quot;/&quot;;</span>
						} else {
<span class="nc" id="L820">							virtualPath = virtualPath + &quot;-&quot; + fixedI;</span>
						}
<span class="nc" id="L822">					} else {</span>
<span class="fc bfc" id="L823" title="All 2 branches covered.">						if (i&gt;100) lastVirtualPath = virtualPath;</span>
					}
				}

<span class="fc" id="L827">				editedDoc.setVirtualPath(DocDB.normalizeVirtualPath(virtualPath));</span>

<span class="fc" id="L829">				Logger.println(EditorService.class, &quot;nastaveny virtual path na:&quot;+virtualPath+&quot;;&quot;);</span>
<span class="fc" id="L830">			}</span>
<span class="pc bpc" id="L831" title="1 of 2 branches missed.">			else if (&quot;cloud&quot;.equals(Constants.getInstallName())) {</span>
				//tiket 15910 - kontrola specialnych znakov v URL
<span class="nc" id="L833">				String cleaned = DocTools.removeCharsDir(DB.internationalToEnglish(editedDoc.getVirtualPath())).toLowerCase();</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">				if(!cleaned.equals(editedDoc.getVirtualPath())) {</span>
<span class="nc" id="L835">					editedDoc.setVirtualPath(DocDB.normalizeVirtualPath(cleaned));</span>
<span class="nc" id="L836">					Logger.println(EditorService.class, &quot;virtual path upraveny na:&quot;+editedDoc.getVirtualPath()+&quot;;&quot;);</span>
				}
			}
		}
		//pre uz existujucu stranku, ktora ma automaticky generovane URL nezobrazuj varovanie (lebo sa vzdy generuje a zobrazi sa pri kazdom ulozeni)
<span class="pc bpc" id="L841" title="1 of 6 branches missed.">		if (virtualPathConflictDocId&gt;0 &amp;&amp; (Boolean.FALSE.equals(editedDoc.getGenerateUrlFromTitle()) || editedDoc.getDocId()&lt;1  ) ) {</span>
<span class="fc" id="L842">			NotifyBean notifyBean = new NotifyBean(prop.getText(&quot;text.warning&quot;), prop.getText(&quot;editor.virtual_path_allready_used_in_doc&quot;)+&quot;: &quot;+virtualPathConflictDocId, NotifyType.WARNING, 20000);</span>
<span class="fc" id="L843">			addNotify(notifyBean);</span>
		}
<span class="fc" id="L845">		String normalized = DocDB.normalizeVirtualPath(editedDoc.getVirtualPath());</span>
<span class="pc bpc" id="L846" title="1 of 6 branches missed.">		if (normalized!=null &amp;&amp; normalized.equals(editedDoc.getVirtualPath())==false &amp;&amp; editedDoc.getVirtualPath().contains(&quot;*&quot;)==false) editedDoc.setVirtualPath(normalized);</span>
<span class="fc" id="L847">	}</span>

	/**
	 * Ak sa zmeni virtual path stranky aktualizuje vsetky doterajsie linky
	 * @param docId
	 * @param oldLinkUrl //It's virtual path !!
	 * @param newVirtualPath
	 * @return
	 */
	private List&lt;DocDetails&gt; fixRenamedVirtualPath(int docId, String oldLinkURL, String newVirtualPath) {

<span class="fc" id="L858">		List&lt;DocDetails&gt; updated = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L859" title="2 of 4 branches missed.">		if (Tools.isEmpty(newVirtualPath) || Constants.getBoolean(&quot;editorDisableAutomaticRedirect&quot;)) return(updated);</span>

<span class="fc" id="L861">		newVirtualPath = DocDB.normalizeVirtualPath(newVirtualPath);</span>
<span class="fc" id="L862">		String domain = null;</span>

<span class="fc" id="L864">		Logger.println(EditorService.class, &quot;OldLinkURL: &quot; + oldLinkURL);</span>

		//Find the webpages, we need to rename
<span class="pc bpc" id="L867" title="1 of 4 branches missed.">		if (Tools.isNotEmpty(oldLinkURL) &amp;&amp; !oldLinkURL.equals(&quot;/showdoc.do?docid=&quot; + docId)) {</span>
<span class="fc" id="L868">			String newLinkURL = newVirtualPath;</span>
			//Logger.println(EditorService.class, &quot;newLinkURL=&quot;+newLinkURL);

<span class="fc bfc" id="L871" title="All 2 branches covered.">			if (oldLinkURL.compareTo(newLinkURL) != 0) {</span>
<span class="fc" id="L872">				String subGroupsIds = &quot;&quot;;</span>

				//Find domain (if need), and do it only on domain sub-pages
<span class="pc bpc" id="L875" title="1 of 2 branches missed.">				if (Constants.getBoolean(&quot;multiDomainEnabled&quot;) == true) {</span>
<span class="fc" id="L876">					DocDetails doc = docDB.getBasicDocDetails(docId, false);</span>
<span class="pc bpc" id="L877" title="1 of 2 branches missed.">					if (doc != null) {</span>
<span class="fc" id="L878">						GroupDetails group = groupsDB.getGroup(doc.getGroupId());</span>
<span class="fc" id="L879">						domain = group.getDomainName();</span>
<span class="fc" id="L880">						subGroupsIds = groupsDB.getSubgroupsIds(domain);</span>
					}
				}

<span class="fc" id="L884">				Logger.debug(EditorService.class, &quot;fixRenamedVirtualPath: old=&quot; + oldLinkURL + &quot; new=&quot; + newLinkURL + &quot; domain=&quot; + domain);</span>

				//Replace all old URl to new in all pages
<span class="fc" id="L887">				updated = replaceUrl(oldLinkURL, newLinkURL, domain);</span>

				//aktualizuj presmerovania
<span class="pc bpc" id="L890" title="1 of 2 branches missed.">				if(Tools.isNotEmpty(subGroupsIds)) {</span>
<span class="fc" id="L891">					int[] subGroupsArray = Tools.getTokensInt(subGroupsIds, &quot;,&quot;);</span>
					try {
<span class="fc" id="L893">						docRepo.updateRedirect(newLinkURL, oldLinkURL, subGroupsArray);</span>
<span class="nc" id="L894">					} catch (Exception ex) {</span>
						//asi prilis vela groupIds IN, skusme premenovat co sa da
<span class="nc" id="L896">						docRepo.updateRedirect(newLinkURL, oldLinkURL);</span>
<span class="fc" id="L897">					}</span>
<span class="fc" id="L898">				} else {</span>
<span class="nc" id="L899">					docRepo.updateRedirect(newLinkURL, oldLinkURL);</span>
				}

				//Update media
<span class="fc" id="L903">				mediaService.updateMediaLink(oldLinkURL, newLinkURL, domain);</span>

				//Write redirect
<span class="fc" id="L906">				UrlRedirectDB.addRedirect(oldLinkURL, newVirtualPath, domain, 301);</span>
			}
		}

<span class="fc" id="L910">		return(updated);</span>
	}

	/**
	 * Nahradi odkazy z povodneho na nove URL vo vsetkych strankach
	 * @param oldLinkURL
	 * @param newLinkURL
	 * @param domain
	 * @return
	 */
	private List&lt;DocDetails&gt; replaceUrl(String oldLinkURL, String newLinkURL, String domain) {
<span class="fc" id="L921">		List&lt;DocDetails&gt; docsUpdated = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L922">		String subgroupsIds = &quot;&quot;;</span>
		List&lt;DocDetails&gt; docs;

<span class="pc bpc" id="L925" title="1 of 2 branches missed.">		if (Constants.getBoolean(&quot;editorQuickUrlFix&quot; )== true) return docsUpdated;</span>

<span class="fc" id="L927">		DebugTimer dt = new DebugTimer(&quot;replaceUrl&quot;);</span>
<span class="fc" id="L928">		dt.diff(&quot;starting&quot;);</span>

<span class="fc" id="L930">		String oldLinkURL2 = oldLinkURL;</span>
<span class="pc bpc" id="L931" title="1 of 4 branches missed.">		if (oldLinkURL.length() &gt; 2 &amp;&amp; oldLinkURL.endsWith(&quot;/&quot;)) { oldLinkURL2 = oldLinkURL.substring(0, oldLinkURL.length() - 1); }</span>

		//zisti domenu (ak treba) a sprav to iba na substrankach domeny
<span class="pc bpc" id="L934" title="2 of 4 branches missed.">		if (Constants.getBoolean(&quot;multiDomainEnabled&quot;)==true &amp;&amp; Tools.isNotEmpty(domain)) {</span>
<span class="fc" id="L935">			subgroupsIds = groupsDB.getSubgroupsIds(domain);</span>

<span class="fc" id="L937">			docs = docRepo.findByDataLikeAndGroupIdIn(&quot;%&quot; + oldLinkURL2 + &quot;%&quot;, Tools.getTokensInt(subgroupsIds, &quot;,&quot;));</span>
		} else {
<span class="nc" id="L939">			docs = docRepo.findByDataLike(&quot;%&quot; + oldLinkURL2 + &quot;%&quot;);</span>
		}
<span class="fc" id="L941">		dt.diff(&quot;mam, pocet:&quot;+docs.size());</span>

		//We have list, now update it all
<span class="fc bfc" id="L944" title="All 2 branches covered.">		for (DocDetails doc : docs) {</span>
<span class="fc" id="L945">			Logger.println(EditorService.class, &quot;updating link in: &quot; + doc.getTitle());</span>

<span class="fc" id="L947">			String oldData = doc.getData();</span>
<span class="fc" id="L948">			doc.setData(Tools.replace(doc.getData(), &quot;'&quot; + oldLinkURL + &quot;'&quot;, &quot;'&quot; +newLinkURL + &quot;'&quot;));</span>
<span class="fc" id="L949">			doc.setData(Tools.replace(doc.getData(), &quot;\&quot;&quot; + oldLinkURL + &quot;\&quot;&quot;, &quot;\&quot;&quot; + newLinkURL + &quot;\&quot;&quot;));</span>
			//toto robilo problem ked sa URL / menilo na /nieco-ine, menilo to aj 0903 / 100 100
			//doc.setData(Tools.replace(doc.getData(), &quot; &quot;+oldLinkURL+&quot; &quot;, &quot; &quot;+newLinkURL+&quot; &quot;));
<span class="fc" id="L952">			doc.setData(Tools.replace(doc.getData(), &quot;'&quot; + oldLinkURL + &quot;#&quot;, &quot;'&quot; + newLinkURL + &quot;#&quot;));</span>
<span class="fc" id="L953">			doc.setData(Tools.replace(doc.getData(), &quot;\&quot;&quot; + oldLinkURL + &quot;#&quot;, &quot;\&quot;&quot; + newLinkURL + &quot;#&quot;));</span>
			//doc.setData(Tools.replace(doc.getData(), &quot; &quot; + oldLinkURL + &quot;#&quot;, &quot; &quot; + newLinkURL + &quot;#&quot;));

<span class="pc bpc" id="L956" title="2 of 4 branches missed.">			if (oldLinkURL.length()&gt;2 &amp;&amp; oldLinkURL.endsWith(&quot;/&quot;)) {</span>
				//fix na chybajuce koncove lomitko
<span class="nc" id="L958">				doc.setData(Tools.replace(doc.getData(), &quot;'&quot; + oldLinkURL2 + &quot;'&quot;, &quot;'&quot; + newLinkURL + &quot;'&quot;));</span>
<span class="nc" id="L959">				doc.setData(Tools.replace(doc.getData(), &quot;\&quot;&quot; + oldLinkURL2 + &quot;\&quot;&quot;, &quot;\&quot;&quot; + newLinkURL + &quot;\&quot;&quot;));</span>
				//doc.setData(Tools.replace(doc.getData(), &quot; &quot; + oldLinkURL2 + &quot; &quot;, &quot; &quot; + newLinkURL + &quot; &quot;));
<span class="nc" id="L961">				doc.setData(Tools.replace(doc.getData(), &quot;'&quot; + oldLinkURL2 + &quot;#&quot;, &quot;'&quot; + newLinkURL + &quot;#&quot;));</span>
<span class="nc" id="L962">				doc.setData(Tools.replace(doc.getData(), &quot;\&quot;&quot; + oldLinkURL2 + &quot;#&quot;, &quot;\&quot;&quot; + newLinkURL + &quot;#&quot;));</span>
				//doc.setData(Tools.replace(doc.getData(), &quot; &quot; + oldLinkURL2 + &quot;#&quot;, &quot; &quot; + newLinkURL + &quot;#&quot;));
<span class="pc bpc" id="L964" title="2 of 4 branches missed.">			} else if (oldLinkURL.length() &gt; 2 &amp;&amp; oldLinkURL.endsWith(&quot;.html&quot;) == false) {</span>
				//ak je linka bez koncoveho /, toto to vyriesi
<span class="nc" id="L966">				oldLinkURL2 = oldLinkURL + &quot;/&quot;;</span>

<span class="nc" id="L968">				doc.setData(Tools.replace(doc.getData(), &quot;'&quot; + oldLinkURL2 + &quot;'&quot;, &quot;'&quot; + newLinkURL + &quot;'&quot;));</span>
<span class="nc" id="L969">				doc.setData(Tools.replace(doc.getData(), &quot;\&quot;&quot; + oldLinkURL2 + &quot;\&quot;&quot;, &quot;\&quot;&quot; + newLinkURL + &quot;\&quot;&quot;));</span>
				//doc.setData(Tools.replace(doc.getData(), &quot; &quot; + oldLinkURL2 + &quot; &quot;, &quot; &quot; + newLinkURL + &quot; &quot;));
<span class="nc" id="L971">				doc.setData(Tools.replace(doc.getData(), &quot;'&quot; + oldLinkURL2 + &quot;#&quot;, &quot;'&quot; + newLinkURL + &quot;#&quot;));</span>
<span class="nc" id="L972">				doc.setData(Tools.replace(doc.getData(), &quot;\&quot;&quot; + oldLinkURL2 + &quot;#&quot;, &quot;\&quot;&quot; + newLinkURL + &quot;#&quot;));</span>
				//doc.setData(Tools.replace(doc.getData(), &quot; &quot; + oldLinkURL2 + &quot;#&quot;, &quot; &quot; + newLinkURL + &quot;#&quot;));
			}

<span class="pc bpc" id="L976" title="1 of 2 branches missed.">			if (oldData.equals(doc.getData()) == false) {</span>
<span class="fc" id="L977">				dt.diff(&quot;updating doc:&quot; + doc.getDocId());</span>
<span class="fc" id="L978">				docRepo.updateAfterUrlReplace(doc.getData(), DB.internationalToEnglish(doc.getData()).toLowerCase(), doc.getDocId());</span>

<span class="fc" id="L980">				docsUpdated.add(doc);</span>
			}
			//DocDB.updateDataClob(db_conn, doc.getDocId(), -1, doc.getData(), DB.internationalToEnglish(doc.getData()).toLowerCase());
<span class="fc" id="L983">		}</span>
<span class="fc" id="L984">		dt.diff(&quot;done&quot;);</span>

<span class="fc" id="L986">		return(docsUpdated);</span>
	}

	//getre/setre

	/**
	 * Ak nastalo schvalovanie vrati zoznam schvalovatelov
	 * @return
	 */
	public List&lt;UserDetails&gt; getApprovers() {
<span class="fc" id="L996">		return approveService.getApprovers();</span>
	}

	/**
	 * Ak ma web stranka publikovanie v buducnosti nastavi sa sem timestamp zaciatku publikovania
	 * @return
	 */
	public Long getPublihStart() {
<span class="fc" id="L1004">		return publihStart;</span>
	}

	/**
	 * Ak bola stranka uspesne vypublikovana na verejne zobrazenie vrati true
	 * @return
	 */
	public boolean isPageSavedToPublic() {
<span class="nc" id="L1012">		return pageSavedToPublic;</span>
	}

	/**
	 * Ak bola stranka korektne ulozena ako rozpracovana verzia vrati true
	 * @return
	 */
	public boolean isPageSavedAsWorkVersion() {
<span class="fc" id="L1020">		return pageSavedAsWorkVersion;</span>
	}

	/**
	 * Vrati true ak je potrebne obnovit stromovu strukturu web stranok na GUI
	 * @return
	 */
<span class="fc" id="L1027">	public boolean isForceReload() { return forceReload; }</span>

	/**
	 * Vyvola reload=true atribut v JSON odpovedi pre obnovenie stromovej struktury/datatabulky
	 * @param forceReload
	 */
<span class="nc" id="L1033">	public void setForceReload(boolean forceReload) { this.forceReload = forceReload; }</span>

	/**
	 * Vrati zoznam moznych notifikacii pre pouzivatela
	 * @return
	 */
	public List&lt;NotifyBean&gt; getNotify() {
<span class="fc" id="L1040">		return notify;</span>
	}

	/**
	 * Prida notifikaciu
	 * @param notifyBean
	 */
	public void addNotify(NotifyBean notifyBean) {
<span class="pc bpc" id="L1048" title="1 of 2 branches missed.">        if(this.notify == null) this.notify = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1049">        this.notify.add(notifyBean);</span>
<span class="fc" id="L1050">    }</span>

	/**
	 * Overi, ci pouzivatel ma pravo na editaciu zadanej web stranky
	 * @param user
	 * @param doc
	 * @param isDelete
	 * @return
	 */
	public boolean isPageEditable(Identity user, DocDetails doc, boolean isDelete) {
<span class="pc bpc" id="L1060" title="1 of 2 branches missed.">		if (UsersDB.checkUserPerms(user, Constants.getString(&quot;webpagesFunctionsPerms&quot;)) == false) return false;</span>

<span class="fc bfc" id="L1062" title="All 2 branches covered.">		if (isDelete) {</span>
<span class="fc bfc" id="L1063" title="All 2 branches covered.">			if (user.isDisabledItem(&quot;deletePage&quot;)) {</span>
<span class="fc" id="L1064">				return false;</span>
			}
<span class="pc bpc" id="L1066" title="1 of 4 branches missed.">		} else if (doc.getDocId()&lt;1 &amp;&amp; user.isDisabledItem(&quot;addPage&quot;)) {</span>
<span class="nc" id="L1067">			return false;</span>
<span class="pc bpc" id="L1068" title="1 of 4 branches missed.">		} else if (doc.getDocId()&gt;0 &amp;&amp; user.isDisabledItem(&quot;pageSave&quot;)) {</span>
<span class="nc" id="L1069">			return false;</span>
		}

<span class="pc bpc" id="L1072" title="1 of 2 branches missed.">		if (doc == null) return true;</span>

		//otestuj, ci mame na tento dokument pristupove prava
<span class="fc" id="L1075">		boolean canAccess = GroupsDB.isGroupEditable(user, doc.getGroupId());</span>

<span class="pc bpc" id="L1077" title="1 of 2 branches missed.">		if (!canAccess)</span>
		{
			//zisti, ci to nie je moja stranka
<span class="nc" id="L1080">			int[] editablePages = Tools.getTokensInt(user.getEditablePages(), &quot;,&quot;);</span>
<span class="nc bnc" id="L1081" title="All 2 branches missed.">			for (int id : editablePages)</span>
			{
<span class="nc bnc" id="L1083" title="All 2 branches missed.">				if (id == doc.getDocId())</span>
				{
<span class="nc" id="L1085">					canAccess = true;</span>
				}
			}
		}

		//kontrola pre slave adresare danej stranky
<span class="pc bpc" id="L1091" title="1 of 2 branches missed.">		if(!canAccess)</span>
		{
			int groupId;
<span class="nc bnc" id="L1094" title="All 2 branches missed.">			for (MultigroupMapping mapping : MultigroupMappingDB.getSlaveMappings(doc.getDocId()))</span>
			{
<span class="nc" id="L1096">				int dId = mapping.getDocId();</span>
<span class="nc" id="L1097">				groupId = DocDB.getInstance().getBasicDocDetails(dId, true).getGroupId();</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">				if (groupId &gt; 0) canAccess = GroupsDB.isGroupEditable(user, groupId);</span>
<span class="nc" id="L1099">				Logger.debug(EditorService.class, &quot;testujem pristup pre multigroup stranky [groupId=&quot;+groupId+&quot;] canAccess=&quot;+canAccess);</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">				if(canAccess) break;</span>
<span class="nc" id="L1101">			}</span>
		}

<span class="pc bpc" id="L1104" title="2 of 4 branches missed.">		if (canAccess &amp;&amp; Constants.getBoolean(&quot;adminCheckUserGroups&quot;))</span>
		{
<span class="nc bnc" id="L1106" title="All 2 branches missed.">			if (DocDB.canAccess(doc, user, true)==false)</span>
			{
<span class="nc" id="L1108">				 canAccess = false;</span>
			}
		}

<span class="fc" id="L1112">		return canAccess;</span>
	}

	/**
	 * Skontroluje prava na editaciu web stranky a throwne Runtime exception v pripade nedostatocnych prav
	 * @param user
	 * @param doc
	 * @param isDelete - nastavte na true, ak sa jedna o kontrolu prav pre mazanie stranky
	 */
	public void checkPermissions(Identity user, DocDetails doc, boolean isDelete) {
<span class="fc" id="L1122">		String errorKey = null;</span>
<span class="pc bpc" id="L1123" title="3 of 6 branches missed.">		if (user == null || UsersDB.checkUserPerms(user, Constants.getString(&quot;webpagesFunctionsPerms&quot;)) == false || doc == null) {</span>
<span class="nc" id="L1124">			errorKey = &quot;error.userNotLogged&quot;;</span>
<span class="fc bfc" id="L1125" title="All 4 branches covered.">		} else if (isDelete &amp;&amp; isPageEditable(user, doc, true)==false) {</span>
<span class="fc" id="L1126">			errorKey = &quot;admin.delete.deletePageDisabled.error&quot;;</span>
<span class="fc bfc" id="L1127" title="All 4 branches covered.">		} else if (doc.getDocId()&lt;1 &amp;&amp; user.isDisabledItem(&quot;addPage&quot;)) {</span>
<span class="fc" id="L1128">			errorKey = &quot;admin.addPage.addPageDisabled.error&quot;;</span>
<span class="fc bfc" id="L1129" title="All 4 branches covered.">		} else if (doc.getDocId()&gt;0 &amp;&amp; user.isDisabledItem(&quot;pageSave&quot;)) {</span>
<span class="fc" id="L1130">			errorKey = &quot;admin.editPage.error&quot;;</span>
<span class="pc bpc" id="L1131" title="1 of 2 branches missed.">		} else if (isPageEditable(user, doc, false)==false) {</span>
<span class="nc" id="L1132">			errorKey = &quot;admin.editPage.error&quot;;</span>
		}

<span class="fc bfc" id="L1135" title="All 2 branches covered.">		if (Tools.isNotEmpty(errorKey)) {</span>
<span class="fc" id="L1136">			throw new RuntimeException(prop.getText(errorKey));</span>
		}

<span class="fc" id="L1139">	}</span>

	public Prop getProp() {
<span class="nc" id="L1142">		return prop;</span>
	}

	/**
	 * Vrati mapu CSS stylov pre roletku vyberu stylu v editore
	 * @param baseCssPath
	 * @return
	 */
	public static List&lt;Map&lt;String, String&gt;&gt; getCssListJson(DocBasic doc) {
<span class="fc" id="L1151">		List&lt;Map&lt;String, String&gt;&gt; sessionCssParsed = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L1153">		StringTokenizer stCss = new StringTokenizer(getCssPath(doc), &quot;,\n&quot;);</span>
<span class="fc bfc" id="L1154" title="All 2 branches covered.">		while (stCss.hasMoreTokens())</span>
		{
<span class="fc" id="L1156">			String cssFile = stCss.nextToken();</span>
			//bootstrap neparsujeme, to by bol masaker
<span class="pc bpc" id="L1158" title="2 of 4 branches missed.">			if (cssFile.contains(&quot;bootstrap.min.css&quot;) || cssFile.contains(&quot;bootstrap.css&quot;)) continue;</span>

			//PathFilter.getRealPath je pouzity z dovodu najdenia custom_path pre vyvoj
<span class="fc" id="L1161">			IwcmFile file = new IwcmFile(PathFilter.getCustomPathRealPath(cssFile));</span>
<span class="fc bfc" id="L1162" title="All 2 branches covered.">			if (!file.exists()) {</span>
				//skus najst subor s pridanym InstallName
<span class="fc" id="L1164">				file = new IwcmFile(PathFilter.getCustomPathRealPath(Tools.replace(cssFile, &quot;/templates/&quot;, &quot;/templates/&quot;+Constants.getInstallName()+&quot;/&quot;)));</span>
			}
<span class="fc bfc" id="L1166" title="All 2 branches covered.">			if (!file.exists()) {</span>
<span class="fc" id="L1167">				Logger.error(EditorService.class, &quot;Css file &quot; + file.getName() + &quot; not exist&quot;);</span>
<span class="fc" id="L1168">				continue;</span>
			}

			//ak subor konci na min.css skus najst neminifikovanu verziu
<span class="fc bfc" id="L1172" title="All 2 branches covered.">			if (file.getName().endsWith(&quot;.min.css&quot;)) {</span>
<span class="fc" id="L1173">				String path = Tools.replace(file.getAbsolutePath(), &quot;.min.css&quot;, &quot;.css&quot;);</span>
<span class="fc" id="L1174">				IwcmFile notMinified = new IwcmFile(path);</span>
<span class="pc bpc" id="L1175" title="1 of 4 branches missed.">				if (notMinified.exists() &amp;&amp; notMinified.canRead()) file = notMinified;</span>
			}

<span class="fc" id="L1178">			sk.iway.css.CssParser cssParser = new sk.iway.css.CssParser(file);</span>
<span class="fc" id="L1179">			List&lt;Pair&lt;String, String&gt;&gt; editorCss = cssParser.getElements();</span>
			try
			{
				//prehod na json format
<span class="fc bfc" id="L1183" title="All 2 branches covered.">				for(Pair&lt;String, String&gt; element : editorCss)</span>
				{
<span class="fc" id="L1185">					Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1186">					map.put(&quot;tag&quot;, element.getFirst());</span>
<span class="fc" id="L1187">					map.put(&quot;class&quot;, element.getSecond());</span>
<span class="fc" id="L1188">					sessionCssParsed.add(map);</span>
<span class="fc" id="L1189">				}</span>
			}
<span class="nc" id="L1191">			catch (Exception ex)</span>
			{
<span class="nc" id="L1193">				Logger.error(EditorService.class, ex);</span>
<span class="fc" id="L1194">			}</span>
<span class="fc" id="L1195">		}</span>

<span class="fc" id="L1197">		return sessionCssParsed;</span>
	}

	private static String getCssPath(DocBasic doc) {

<span class="fc" id="L1202">		String defaultBaseCssPath = &quot;/css/page.css&quot;; //NOSONAR</span>
<span class="fc" id="L1203">		String baseCssPath = null;</span>
<span class="fc" id="L1204">		TemplateDetails temp = TemplatesDB.getInstance().getTemplate(doc.getTempId());</span>
<span class="fc" id="L1205">		GroupDetails group = doc.getGroup();</span>
<span class="fc" id="L1206">		String domainName = null;</span>
<span class="fc bfc" id="L1207" title="All 2 branches covered.">		if (group != null) domainName = group.getDomainName();</span>

<span class="fc bfc" id="L1209" title="All 2 branches covered.">		if (temp != null) {</span>
<span class="fc" id="L1210">			baseCssPath = temp.getBaseCssPath();</span>
		}

<span class="pc bpc" id="L1213" title="1 of 6 branches missed.">		if (Tools.isNotEmpty(baseCssPath) &amp;&amp; Constants.getBoolean(&quot;multiDomainEnabled&quot;) == true &amp;&amp; Tools.isNotEmpty(domainName)) {</span>
			// baseCssPath = Tools.replace(baseCssPath, &quot;/css/&quot;,
			// &quot;/css/&quot;+MultiDomainFilter.getDomainAlias(editForm.getDomainName())+&quot;/&quot;);
<span class="fc" id="L1216">			baseCssPath = MultiDomainFilter.rewriteUrlToLocal(baseCssPath, MultiDomainFilter.getDomainAlias(domainName));</span>
		}

<span class="fc bfc" id="L1219" title="All 2 branches covered.">		if (Tools.isEmpty(baseCssPath)) {</span>
<span class="fc" id="L1220">			baseCssPath = defaultBaseCssPath;</span>
		}

<span class="fc" id="L1223">		String editorCssPath = getEditorCssPath(baseCssPath);</span>
<span class="pc bpc" id="L1224" title="3 of 10 branches missed.">		if (baseCssPath != null &amp;&amp; baseCssPath.startsWith(&quot;/templates/&quot;) &amp;&amp; baseCssPath.contains(&quot;editor.css&quot;) == false &amp;&amp; editorCssPath != null &amp;&amp; editorCssPath.startsWith(&quot;/templates&quot;)) {</span>
<span class="fc" id="L1225">			baseCssPath += &quot;,&quot; + editorCssPath;</span>
		}

<span class="fc" id="L1228">		return baseCssPath;</span>
	}

	private static String getEditorCssPath(String baseCssPathMultiline) {
		String editorCss;
<span class="fc" id="L1233">		String[] lines = Tools.getTokens(baseCssPathMultiline, &quot;\n&quot;);</span>
<span class="fc bfc" id="L1234" title="All 2 branches covered.">		for (String baseCssPath : lines) {</span>
<span class="fc" id="L1235">			baseCssPath = baseCssPath.trim();</span>
<span class="pc bpc" id="L1236" title="2 of 6 branches missed.">			if (baseCssPath != null &amp;&amp; baseCssPath.startsWith(&quot;/templates/&quot;) &amp;&amp; baseCssPath.contains(&quot;editor.css&quot;) == false) {</span>
				// skus automaticky dohladat aj editor.css v danom adresari
<span class="fc" id="L1238">				editorCss = baseCssPath.substring(0, baseCssPath.lastIndexOf(&quot;/&quot;)) + &quot;/editor.css&quot;;</span>
<span class="fc bfc" id="L1239" title="All 2 branches covered.">				if (FileTools.isFile(editorCss)) {</span>
<span class="fc" id="L1240">					return editorCss;</span>
				}
			}
		}

<span class="fc" id="L1245">		editorCss = &quot;/css/editor.css&quot;;</span>
<span class="pc bpc" id="L1246" title="1 of 2 branches missed.">		if (FileTools.isFile(editorCss)) {</span>
<span class="nc" id="L1247">			return editorCss;</span>
		}

<span class="fc" id="L1250">		return null;</span>
	}

	public void saveAttrs(DocDetails doc, List&lt;DocAtrDefEntity&gt; attrs, boolean cleanBeforeSave) {
<span class="pc bpc" id="L1254" title="2 of 6 branches missed.">		if (doc == null || attrs == null || attrs.size()&lt;1) return;</span>

<span class="fc bfc" id="L1256" title="All 2 branches covered.">		if (cleanBeforeSave) {</span>
<span class="fc" id="L1257">			docAtrRepository.deleteAllByDocId(doc.getDocId());</span>
		}

<span class="fc bfc" id="L1260" title="All 2 branches covered.">		for (DocAtrDefEntity def : attrs) {</span>
<span class="fc" id="L1261">			DocAtrEntity atrEntity = def.getDocAtrEntityFirst();</span>
<span class="pc bpc" id="L1262" title="1 of 2 branches missed.">			if (atrEntity != null) {</span>
<span class="fc bfc" id="L1263" title="All 2 branches covered.">				if (cleanBeforeSave) atrEntity.setId(null);</span>
<span class="fc bfc" id="L1264" title="All 4 branches covered.">				if (atrEntity.getDocId()==null || cleanBeforeSave) atrEntity.setDocId(doc.getDocId());</span>
<span class="fc bfc" id="L1265" title="All 2 branches covered.">				if (atrEntity.getAtrDef()==null) atrEntity.setAtrDef(def);</span>
<span class="fc" id="L1266">				docAtrRepository.save(atrEntity);</span>
			}
<span class="fc" id="L1268">		}</span>
<span class="fc" id="L1269">	}</span>

	/**
	 *
	 * @param editedDoc
	 * @param isInsert
	 * @param dt
	 */
	private void docSave(DocDetails editedDoc, boolean isInsert, DebugTimer dt) {
<span class="fc bfc" id="L1278" title="All 2 branches covered.">		if(isInsert) dt.diff(&quot;preparing insert&quot;);</span>
<span class="fc" id="L1279">		else dt.diff(&quot;preparing update data&quot;);</span>

<span class="fc" id="L1281">		GroupDetails group = groupsDB.getGroup(editedDoc.getGroupId());</span>
<span class="fc" id="L1282">		String fileName = null;</span>

<span class="pc bpc" id="L1284" title="1 of 4 branches missed.">		if (group != null &amp;&amp; group.isInternal() == false) fileName = groupsDB.getGroupNamePath(editedDoc.getGroupId());</span>

		//Cut string too maxLength 255, then set
<span class="fc" id="L1287">		editedDoc.setFileName(DB.prepareString(fileName,255));</span>

		// Set root groups L1, L2, L3
<span class="fc" id="L1290">		setRootGroupL(editedDoc.getGroupId(), editedDoc);</span>

<span class="pc bpc" id="L1292" title="1 of 2 branches missed.">		if (Tools.isEmpty(editedDoc.getNavbar())) editedDoc.setNavbar(editedDoc.getTitle());</span>

<span class="fc bfc" id="L1294" title="All 2 branches covered.">		if(isInsert) {</span>
			// Insert new doc entity via DocDeailsRepository
<span class="fc" id="L1296">			docRepo.save(editedDoc);</span>
<span class="fc" id="L1297">			dt.diff(&quot;after insert&quot;);</span>

			// Set docId into entity (get id from DB)
<span class="fc" id="L1300">			editedDoc.setDocId(docRepo.findMaxIdByGroupIdAndTitle(editedDoc.getGroupId(), editedDoc.getTitle()));</span>
<span class="fc" id="L1301">			dt.diff(&quot;after setDocId&quot;);</span>
		} else {
			//Update webpage via DocDeailsRepository
<span class="fc" id="L1304">			docRepo.save(editedDoc);</span>
<span class="fc" id="L1305">			dt.diff(&quot;after update&quot;);</span>
		}

		//aktualizuj pripadne aj tab. perex_group_doc
<span class="fc" id="L1309">		DocDB.udpdatePerexGroupDoc(editedDoc.getDocId(), editedDoc.getPerexGroupIdsString());</span>
<span class="fc" id="L1310">		dt.diff(&quot;after update perex group doc&quot;);</span>
<span class="fc" id="L1311">	}</span>

	private void renameVirtualPath(DocDetails editedDoc, DebugTimer dt) {
		//Ak sa zmeni virtual path stranky aktualizuje vsetky doterajsie linky
<span class="fc" id="L1315">		String oldLinkURL = DocDB.getURLFromDocId(editedDoc.getDocId(), request); //Get page old virtual path</span>

<span class="fc" id="L1317">		List&lt;DocDetails&gt; updated = fixRenamedVirtualPath(editedDoc.getDocId(), oldLinkURL, editedDoc.getVirtualPath());</span>
<span class="fc bfc" id="L1318" title="All 2 branches covered.">		if (updated.isEmpty()==false) {</span>
			//zobraz cez notifikaciu
<span class="fc" id="L1320">			StringBuilder changedPages = new StringBuilder();</span>
<span class="fc bfc" id="L1321" title="All 2 branches covered.">			for (DocDetails doc : updated) {</span>
<span class="fc" id="L1322">				changedPages.append(&quot;\n&lt;br/&gt;&quot;).append(doc.getDocId()).append(&quot;-&quot;).append(doc.getTitle());</span>
<span class="fc" id="L1323">			}</span>

<span class="fc" id="L1325">			NotifyBean notifyBean = new NotifyBean(prop.getText(&quot;text.info&quot;), prop.getText(&quot;editor.updatedDocs&quot;)+changedPages.toString(), NotifyType.INFO);</span>
<span class="fc" id="L1326">			addNotify(notifyBean);</span>
		}
<span class="fc" id="L1328">		dt.diff(&quot;after fixRenamedVirtualPath&quot;);</span>
<span class="fc" id="L1329">	}</span>

	/**
	 * Approve waiting DocHistory to change some webpage (can be update/insert).
	 * @param editedHistory
	 */
	public void approveDocHistory(DocHistory editedHistory) {
		//Set actual informations
<span class="nc" id="L1337">		editedHistory.setApprovedBy(currentUser.getUserId());</span>
<span class="nc" id="L1338">		editedHistory.setAwaitingApprove(null);</span>
<span class="nc" id="L1339">		editedHistory.setActual(true);</span>
<span class="nc" id="L1340">		editedHistory.setAvailable(true);</span>
<span class="nc" id="L1341">		editedHistory.setApproveDate(new Date(now));</span>

		//Create new version of DocDetails from DocHistory
<span class="nc" id="L1344">		DocDetails editedDoc = DocDetailsToDocHistoryMapper.INSTANCE.docHistoryToDocDetails(editedHistory);</span>

		//Inicialize editorFields
<span class="nc" id="L1347">		DocEditorFields def = new DocEditorFields();</span>
<span class="nc" id="L1348">		def.fromDocDetails(editedDoc, true, false);</span>
<span class="nc" id="L1349">		def.setRequestPublish(true);</span>
<span class="nc" id="L1350">		editedDoc.setEditorFields(def);</span>

<span class="nc" id="L1352">		DebugTimer dt = new DebugTimer(&quot;EditorService.saveEditedDoc&quot;);</span>

<span class="nc" id="L1354">		Logger.println(this,&quot;ApproveAction.approve&quot;);</span>

<span class="nc" id="L1356">		(new WebjetEvent&lt;&gt;(editedDoc, WebjetEventType.ON_START)).publishEvent();</span>

		//Check perms
<span class="nc" id="L1359">		checkPermissions(currentUser, editedDoc, false);</span>

		//Do update itself
<span class="nc" id="L1362">		updateWebpage(editedDoc, dt);</span>

		//Update docHistory record (no more waiting)
<span class="nc" id="L1365">		historyRepo.save(editedHistory);</span>

		//Delete other waiting docHistory records for this webpage
<span class="nc" id="L1368">		deleteHistorySaveRecords(editedDoc, editedHistory, editedHistory.getHistoryId(), dt);</span>

		//There can be situation that change is approved, but isRequestPublish = false because we are waiting for publishing date
<span class="nc bnc" id="L1371" title="All 2 branches missed.">		if(editedDoc.getEditorFields().isRequestPublish()) {</span>
			//IN case of update webpage, there is NEEDED to do some sort of adjustments and refresh

<span class="nc" id="L1374">			renameVirtualPath(editedDoc, dt);</span>
<span class="nc" id="L1375">			refreshCacheObjects(editedDoc, dt);</span>
<span class="nc" id="L1376">			refreshTemplates(editedDoc, dt);</span>
		}

<span class="nc" id="L1379">		(new WebjetEvent&lt;&gt;(editedDoc, WebjetEventType.AFTER_SAVE)).publishEvent();</span>
<span class="nc" id="L1380">	}</span>

	/**
	 * Refresh cache object. Used after DOC change, so this changes will show.
	 * @param editedDoc
	 * @param dt
	 */
	private void refreshCacheObjects(DocDetails editedDoc, DebugTimer dt) {
<span class="pc bpc" id="L1388" title="3 of 6 branches missed.">		if (editedDoc.getGroupId() == Constants.getInt(&quot;tempGroupId&quot;) || editedDoc.getGroupId() == Constants.getInt(&quot;menuGroupId&quot;) || editedDoc.getGroupId() == Constants.getInt(&quot;headerFooterGroupId&quot;)) {</span>
			//v system adresari pre istotu spravim klasicky refresh
<span class="nc" id="L1390">			docDB = DocDB.getInstance(true);</span>
<span class="nc" id="L1391">			dt.diff(&quot;after DocDB.getInstance&quot;);</span>
			/*spravime update dokumentu v indexe */
<span class="nc" id="L1393">			docDB.updateInternalCaches(editedDoc.getDocId());</span>
		} else {
<span class="fc" id="L1395">			docDB.updateInternalCaches(editedDoc.getDocId());</span>
<span class="fc" id="L1396">			dt.diff(&quot;after DocDB.update internal caches&quot;);</span>
		}
<span class="fc" id="L1398">	}</span>

	/**
	 * Refresh templates. Used after DOC change, so this changes will show.
	 * @param editedDoc
	 * @param dt
	 */
	private void refreshTemplates(DocDetails editedDoc, DebugTimer dt) {
<span class="fc" id="L1406">		boolean isInSystemFolder = false;</span>
<span class="pc bpc" id="L1407" title="2 of 4 branches missed.">		if (editedDoc.getVirtualPath()!=null &amp;&amp; editedDoc.getVirtualPath().startsWith(&quot;/system/&quot;)) isInSystemFolder = true;</span>
<span class="pc bpc" id="L1408" title="4 of 8 branches missed.">		if (isInSystemFolder || editedDoc.getGroupId() == Constants.getInt(&quot;tempGroupId&quot;) || editedDoc.getGroupId() == Constants.getInt(&quot;menuGroupId&quot;) || editedDoc.getGroupId() == Constants.getInt(&quot;headerFooterGroupId&quot;)) {</span>
<span class="nc" id="L1409">			TemplatesDB.getInstance(true);</span>
<span class="nc" id="L1410">			dt.diff(&quot;after templates DB getInstance&quot;);</span>
		}
<span class="fc" id="L1412">	}</span>

	/**
	 * Perform insert/update webpage action (aka waiting docHistory) by approve/reject throu calling ApproveSrvice.approveAction method
	 * @return
	 */
	public boolean approveAction() {
<span class="nc" id="L1419">		return approveService.approveAction(historyRepo, this);</span>
	}

	/**
	 * Perform delete webpage action (aka waiting docHistory) by approve/reject throu calling ApproveSrvice.approveDelAction method
	 * @return
	 */
	public boolean approveDelAction() {
<span class="nc" id="L1427">		return approveService.approveDelAction(historyRepo, docRepo, this);</span>
	}

	/**
	 * Delete webpage logic + checkPermissions and check approve posibility.
	 *
	 * It will move webpage to trash folder (soft delete) OR if delete is called from trash folder perform permanent delete.
	 * @param delDocId
	 * @param approveService
	 * @param publishEvents
	 * @return Return &quot;success&quot; or other string taht represend some sort of error taht occured
	 */
	protected String deleteWebpageLogic(int delDocId, ApproveService approveService, boolean publishEvents) {
		//If id is -1, try get id from request, if id is still -1 return eeror message
<span class="pc bpc" id="L1441" title="1 of 2 branches missed.">		if(delDocId == -1) delDocId = Tools.getIntValue(request.getParameter(&quot;docid&quot;), -1);</span>
<span class="pc bpc" id="L1442" title="1 of 2 branches missed.">		if(delDocId == -1) return &quot;There's no provided docId to by used for delete.&quot;;</span>

		//Try get DocDetails object by id, if not present return error message
<span class="fc" id="L1445">		Optional&lt;DocDetails&gt; docDetailsOpt = docRepo.findById(Long.valueOf(delDocId));</span>
<span class="pc bpc" id="L1446" title="1 of 2 branches missed.">		if(!docDetailsOpt.isPresent()) {</span>
<span class="nc" id="L1447">			return &quot;Record by provided ID not found.&quot;;</span>
		}
<span class="fc" id="L1449">		DocDetails docDetails = docDetailsOpt.get();</span>

		//To check perms and approve for this action
<span class="fc" id="L1452">		checkPermissions(currentUser, docDetails, true);</span>
<span class="fc" id="L1453">		approveService.loadApproveTables(docDetails.getGroupId());</span>

		//Check if user can approve this action
<span class="pc bpc" id="L1456" title="1 of 4 branches missed.">		if(approveService.needApprove()==false || approveService.isSelfApproved()) {</span>
			//Doc, do not need approve OR
			//current user IS self approver, can do delete action

<span class="fc bfc" id="L1460" title="All 2 branches covered.">			if (publishEvents) (new WebjetEvent&lt;DocDetails&gt;(docDetails, WebjetEventType.ON_DELETE)).publishEvent();</span>

			// zisti ci sme v adresari /System/Trash (kos), ak nie presun, inak vymaz
<span class="fc" id="L1463">			String navbarNoHref = DB.internationalToEnglish(groupsDB.getURLPath(docDetails.getGroupId())).toLowerCase();</span>
<span class="fc" id="L1464">			Logger.println(EditorService.class,&quot;MAZEM: &quot; + navbarNoHref);</span>

			//tu sa vytvara adresar podla default jazyka, nie podla prihlaseneho pouzivatela!
<span class="fc" id="L1467">			Prop propSystem = Prop.getInstance(Constants.getString(&quot;defaultLanguage&quot;));</span>
<span class="fc" id="L1468">			String trashDirName = propSystem.getText(&quot;config.trash_dir&quot;);</span>
<span class="fc" id="L1469">			GroupDetails group = groupsDB.getGroup(docDetails.getGroupId());</span>

			//vypne zapisovanie zaznamov do documents_history tabulky. true - nezapise zaznam do documents_history
<span class="fc" id="L1472">			boolean disableHistory = Constants.getBoolean(&quot;editorDisableHistory&quot;);</span>
<span class="pc bpc" id="L1473" title="1 of 2 branches missed.">			GroupDetails trashGroupDetails = disableHistory == false ? groupsDB.getCreateGroup(trashDirName) : null;</span>

<span class="pc bpc" id="L1475" title="1 of 4 branches missed.">			if (trashGroupDetails==null || navbarNoHref.startsWith(DB.internationalToEnglish(groupsDB.getURLPath(trashGroupDetails.getGroupId())).toLowerCase()))  {</span>
					//Permanent DOC delete
<span class="fc" id="L1477">					docRepo.deleteById(Long.valueOf(delDocId));</span>

					//Every docHistory record awaiting for approve is canceled (DOC is deleted so changes waiting for approve are irelevant)
<span class="fc" id="L1480">					historyRepo.updateAwaitingApprove(&quot;&quot;, delDocId);</span>

					//Check, if DOC is main in the folder
<span class="pc bpc" id="L1483" title="1 of 2 branches missed.">                    if (group.getDefaultDocId() == delDocId)  {</span>
<span class="nc" id="L1484">                        List&lt;DocDetails&gt; pages = docDB.getDocByGroup(group.getGroupId(), DocDB.ORDER_PRIORITY, true, -1, -1, true);</span>
<span class="nc bnc" id="L1485" title="All 2 branches missed.">                        if (pages.size() &gt; 0) {</span>
<span class="nc" id="L1486">                            docDetails = pages.get(0);</span>

<span class="nc bnc" id="L1488" title="All 2 branches missed.">                            if (docDetails != null) {</span>
<span class="nc" id="L1489">                                group.setDefaultDocId(docDetails.getDocId());</span>
<span class="nc" id="L1490">                                group.setSyncStatus(1);</span>
<span class="nc" id="L1491">                                groupsDB.setGroup(group);</span>
                            } else {
<span class="nc" id="L1493">                                group.setDefaultDocId(0);</span>
<span class="nc" id="L1494">                                group.setSyncStatus(1);</span>
<span class="nc" id="L1495">                                groupsDB.setGroup(group);</span>
                            }
                        }
                    }
                    //Set for ApproveDelAction (proof of succesfull delete)
<span class="pc bpc" id="L1500" title="1 of 2 branches missed.">                    if (request!=null) request.setAttribute(&quot;deleteSuccess&quot;, &quot;yes&quot;);</span>

					//delete doc from multigroup mapping
<span class="fc" id="L1503">					MultigroupMappingDB.deleteSlaveDocFromMapping(delDocId);</span>

                    //14.8.2012 pridany Admin log stranka bola vymazana uplne (z kosa)
<span class="fc" id="L1506">                    Adminlog.add(Adminlog.TYPE_PAGE_DELETE, &quot;(DocID: &quot;+delDocId+&quot;): Stranka bola uplne zmazana (z kosa)&quot;, delDocId, 0);</span>

<span class="fc" id="L1508">					List&lt;MultigroupMapping&gt; slaveMappingList = MultigroupMappingDB.getSlaveMappings(delDocId);</span>
<span class="pc bpc" id="L1509" title="1 of 4 branches missed.">					if(slaveMappingList != null &amp;&amp; slaveMappingList.isEmpty()==false) {</span>
<span class="fc" id="L1510">						List&lt;Long&gt; slaveIds = slaveMappingList.stream().map(x-&gt;Long.valueOf(x.getDocId())).collect(Collectors.toList());</span>

						//Delete all connections from multigroup table
<span class="fc" id="L1513">						MultigroupMappingDB.deleteSlaves(delDocId);</span>

						//Perform HARD (permanent) delete of slave pages
<span class="fc" id="L1516">						docRepo.deleteByDocIdIn(slaveIds);</span>

<span class="fc bfc" id="L1518" title="All 2 branches covered.">						for (Long slaveId : slaveIds) {</span>
<span class="fc" id="L1519">							DocDB.getInstance().updateInternalCaches(slaveId.intValue());</span>
<span class="fc" id="L1520">						}</span>

<span class="fc" id="L1522">						Adminlog.add(Adminlog.TYPE_PAGE_DELETE, &quot;(DocID's : &quot; + StringUtils.collectionToDelimitedString(slaveIds, &quot;,&quot;) + &quot;): Slave stranky boli uplne zmazane (hard delete)&quot;, delDocId, 0);</span>
					}
<span class="fc" id="L1524">            } else {</span>
                //failsafe na zle zmazane polozky (take co v kosi boli volakedy a zle sa zmazali)

<span class="fc" id="L1527">				List&lt;Integer&gt; groupIds = (new SimpleQuery()).forListInteger(&quot;SELECT group_id FROM groups WHERE group_id=parent_group_id&quot;);</span>

<span class="fc" id="L1529">				String ids = null;</span>
<span class="fc" id="L1530">				StringBuilder buf = null;</span>

<span class="pc bpc" id="L1532" title="1 of 2 branches missed.">				for(Integer groupIdX : groupIds) {</span>
<span class="nc bnc" id="L1533" title="All 2 branches missed.">					if (buf == null) buf = new StringBuilder(Integer.toString(groupIdX));</span>
<span class="nc" id="L1534">					else buf.append(',').append(groupIdX);</span>
<span class="nc" id="L1535">				}</span>

<span class="pc bpc" id="L1537" title="1 of 2 branches missed.">				if(buf != null) ids = buf.toString();</span>

<span class="pc bpc" id="L1539" title="1 of 2 branches missed.">				if (ids != null) {</span>
<span class="nc" id="L1540">					new SimpleQuery().execute(&quot;UPDATE groups SET parent_group_id=? WHERE group_id IN (&quot; + ids + &quot;)&quot;);</span>
<span class="nc" id="L1541">					GroupsDB.getInstance(true);</span>
				}

                //presun to do trash adresara
<span class="fc" id="L1545">                Logger.println(EditorService.class,&quot;presuvam do trash adresara&quot;);</span>

				//Soft delete, move to thash folder
<span class="fc" id="L1548">				docRepo.moveToTrash(false, trashGroupDetails.getGroupId(), delDocId);</span>

				//Every docHistory record awaiting for approve is canceled (DOC is deleted so changes waiting for approve are irelevant)
<span class="fc" id="L1551">				historyRepo.updateAwaitingApprove(&quot;&quot;, delDocId);</span>

                //Check, if DOC is main in the folder
<span class="pc bpc" id="L1554" title="2 of 4 branches missed.">                if (group!=null &amp;&amp; group.getDefaultDocId() == delDocId) {</span>
<span class="nc" id="L1555">                    List&lt;DocDetails&gt; pages = docDB.getDocByGroup(group.getGroupId(), DocDB.ORDER_PRIORITY, true, -1, -1, true);</span>
<span class="nc bnc" id="L1556" title="All 2 branches missed.">                    if (pages.size() &gt; 0) {</span>
<span class="nc" id="L1557">                        docDetails = pages.get(0);</span>

<span class="nc bnc" id="L1559" title="All 2 branches missed.">                        if (docDetails!=null) {</span>
<span class="nc" id="L1560">                            group.setDefaultDocId(docDetails.getDocId());</span>
<span class="nc" id="L1561">                            group.setSyncStatus(1);</span>
<span class="nc" id="L1562">                            groupsDB.setGroup(group);</span>
                        } else {
<span class="nc" id="L1564">							group.setDefaultDocId(0);</span>
<span class="nc" id="L1565">							group.setSyncStatus(1);</span>
<span class="nc" id="L1566">							groupsDB.setGroup(group);</span>
						}
                    }
                }
				//Set for ApproveDelAction (proof of succesfull delete)
<span class="pc bpc" id="L1571" title="1 of 2 branches missed.">                if (request != null) request.setAttribute(&quot;deleteSuccess&quot;, &quot;yes&quot;);</span>
                //Admin log stranka bola presunuta do kosa
<span class="fc" id="L1573">                Adminlog.add(Adminlog.TYPE_PAGE_DELETE, &quot;(DocID: &quot; + delDocId + &quot;): Stranka bola presunuta do kosa &quot;, delDocId, 0);</span>
            }
<span class="fc" id="L1575">            DocDB.getInstance().updateInternalCaches(delDocId);</span>

<span class="fc bfc" id="L1577" title="All 2 branches covered.">			if (publishEvents) (new WebjetEvent&lt;DocDetails&gt;(docDetails, WebjetEventType.AFTER_DELETE)).publishEvent();</span>

			//Success signlization
<span class="fc" id="L1580">			return &quot;success&quot;;</span>
		} else {
			//Doc NEED's approve, BUT current user is NOT selfApprover, so he can't approve this shit

			//ziskaj aktualne vypublikovane history_id
<span class="fc" id="L1585">			Optional&lt;Integer&gt; actualPublishedHistoryIdOpt = historyRepo.findMaxHistoryId(delDocId, true);</span>

			//!! BUG FIX - If page is stil waiting to be approven (as inserted)
			//If approver try delete this page it's gonna be ok, BUT in this (non approver) case actualPublishedHistoryId is empty
<span class="pc bpc" id="L1589" title="1 of 2 branches missed.">			if(!actualPublishedHistoryIdOpt.isPresent()) return &quot;Something went wrong. Page probably isn't exist.&quot;;</span>
<span class="fc" id="L1590">			int actualPublishedHistoryId  = actualPublishedHistoryIdOpt.get();</span>

			//vypne zapisovanie zaznamov do documents_history tabulky. true - nezapise zaznam do documents_history
<span class="fc" id="L1593">            boolean disableHistory =  Constants.getBoolean(&quot;editorDisableHistory&quot;);</span>
<span class="pc bpc" id="L1594" title="1 of 2 branches missed.">            if(disableHistory) {</span>
<span class="nc" id="L1595">                Logger.debug(EditorDB.class, &quot;Write into documents_history is disabled&quot;);</span>
            } else {
<span class="fc" id="L1597">				Logger.println(EditorService.class,&quot;approveByUsersId=&quot; + approveService.getApproveUserIds());</span>

				//Convert DocDetail to DocHistory entity (this new entity will be inserted)
<span class="fc" id="L1600">				DocHistory docHistory = prepareDeleteDocHistoryEntityFromDocDetails(docDetails);</span>

				//Save
<span class="fc" id="L1603">				historyRepo.save(docHistory);</span>

				//Id of new docHistory entity
<span class="fc" id="L1606">				int historyId = historyRepo.findMaxHistoryId(delDocId);</span>

				//Send request's to this deleet action
<span class="fc" id="L1609">				approveService.sendWebpageApproveDelRequestEmail(docHistory, historyId, actualPublishedHistoryId);</span>

				//9.8.2012 pridany audit o zmazani suboru
<span class="fc" id="L1612">				Adminlog.add(Adminlog.TYPE_PAGE_DELETE, &quot;(DocID: &quot;+delDocId+&quot;): Stranka poziadana o vymazanie : &quot; + approveService.getEmailsToNotify(null), delDocId, 0);</span>
			}

			//Can't approve signalization
<span class="fc" id="L1616">			return prop.getText(&quot;approveAction.err.cantApprove&quot;);</span>
		}
	}

	private DocHistory prepareDeleteDocHistoryEntityFromDocDetails(DocDetails docDetails) {
		//Convert DocDetail to DocHistory entity (this new entity will be inserted)
<span class="fc" id="L1622">		DocHistory docHistory = DocDetailsToDocHistoryMapper.INSTANCE.docDetailsToDocHistory(docDetails);</span>

		//General setting - !! there MUST be set &quot;[DELETE]&quot; as delete prefix, that indicates delete intend
<span class="fc" id="L1625">		docHistory.setTitle(&quot;[DELETE] &quot; + docHistory.getTitle());</span>
<span class="fc" id="L1626">		docHistory.setData(prop.getText(&quot;approve.delete.doctext&quot;));</span>
<span class="fc" id="L1627">		docHistory.setDataAsc(&quot;[DELETE]&quot;);</span>

		//When created and by who
<span class="fc" id="L1630">		docHistory.setDateCreated(now);</span>
<span class="fc" id="L1631">		docHistory.setSaveDate(new Date(now));</span>
<span class="fc" id="L1632">		docHistory.setAuthorId(currentUser.getUserId());</span>

		//Set availability of page etc
<span class="fc" id="L1635">		docHistory.setSearchable(false);</span>
<span class="fc" id="L1636">		docHistory.setCacheable(false);</span>
<span class="fc" id="L1637">		docHistory.setAvailable(false);</span>
<span class="fc" id="L1638">		docHistory.setActual(false);</span>

		//Mark docHistory as waiting for approve (need's approve by approver)
<span class="fc" id="L1641">		docHistory.setApprovedBy(-1);</span>
<span class="fc" id="L1642">		docHistory.setAwaitingApprove(&quot;,&quot; + approveService.getApproveUserIds() + &quot;,&quot;);</span>

<span class="fc" id="L1644">		return docHistory;</span>
	}

	/**
	 * Recover webpage from trash folder:
	 * - set groupId from history (latest where actual=1 or latest)
	 * - set available from history (latest where actual=1 or latest)
	 * @param recoverDocId
	 */
	public void recoverWebpageFromTrash(int recoverDocId) {
<span class="pc bpc" id="L1654" title="1 of 2 branches missed.">		if(recoverDocId &lt;1) throw new RuntimeException(&quot;recoverDocId is not valid&quot;);</span>

		//Try get DocDetails object by id, if not present return error message
<span class="fc" id="L1657">		Optional&lt;DocDetails&gt; docDetailsOpt = docRepo.findById(Long.valueOf(recoverDocId));</span>
<span class="pc bpc" id="L1658" title="1 of 2 branches missed.">		if(!docDetailsOpt.isPresent()) throw new RuntimeException(&quot;DocDetails doesn't exists.&quot;);</span>
<span class="fc" id="L1659">		DocDetails docDetailsToRecover = docDetailsOpt.get();</span>

		//To check perms and approve for this action
<span class="fc" id="L1662">		checkPermissions(currentUser, docDetailsToRecover, true);</span>

		//Find last actual (if posible) history id (so we know wehre to recover page)
<span class="fc" id="L1665">		Integer historyId = null;</span>
<span class="fc" id="L1666">		Optional&lt;Integer&gt; historyIdOpt = historyRepo.findMaxHistoryId(recoverDocId, true); //(actual history id)</span>
<span class="pc bpc" id="L1667" title="1 of 2 branches missed.">		if(historyIdOpt.isPresent())</span>
<span class="fc" id="L1668">			historyId = historyIdOpt.get();</span>
<span class="nc" id="L1669">		else historyId = historyRepo.findMaxHistoryId(recoverDocId); //(any history id)</span>

<span class="pc bpc" id="L1671" title="1 of 2 branches missed.">		if(historyId == null) {</span>
			//There is no history
<span class="nc" id="L1673">			NotifyBean info = new NotifyBean(prop.getText(&quot;editor.recover.notifyTitle&quot;), prop.getText(&quot;editor.recover.notify.no_history&quot;), NotifyBean.NotifyType.WARNING, 60000);</span>
<span class="nc" id="L1674">            addNotify(info);</span>
<span class="nc" id="L1675">			return;</span>
		} else {
<span class="fc" id="L1677">			Optional&lt;Integer&gt; destGroupId = historyRepo.findGroupIdById(Long.valueOf(historyId));</span>
<span class="pc bpc" id="L1678" title="1 of 2 branches missed.">			if(!destGroupId.isPresent()) {</span>
<span class="nc" id="L1679">				NotifyBean info = new NotifyBean(prop.getText(&quot;editor.recover.notifyTitle&quot;), prop.getText(&quot;editor.recover.notify.no_history&quot;), NotifyBean.NotifyType.WARNING, 60000);</span>
<span class="nc" id="L1680">            	addNotify(info);</span>
<span class="nc" id="L1681">				return;</span>
			}
<span class="fc" id="L1683">			GroupDetails destGroup = groupsDB.getGroup(destGroupId.get());</span>
<span class="fc bfc" id="L1684" title="All 2 branches covered.">			if(destGroup == null) {</span>
<span class="fc" id="L1685">				NotifyBean info = new NotifyBean(prop.getText(&quot;editor.recover.notifyTitle&quot;), prop.getText(&quot;editor.recover.notify.no_history&quot;), NotifyBean.NotifyType.WARNING, 60000);</span>
<span class="fc" id="L1686">            	addNotify(info);</span>
<span class="fc" id="L1687">				return;</span>
			}

			//Check perms
<span class="fc" id="L1691">			approveService.loadApproveTables(destGroup.getGroupId());</span>
<span class="pc bpc" id="L1692" title="3 of 4 branches missed.">			if(approveService.needApprove() == false || approveService.isSelfApproved()) {</span>
				//Have right
<span class="fc" id="L1694">				docDetailsToRecover.setGroupId(destGroup.getGroupId());</span>
<span class="fc" id="L1695">				docDetailsToRecover.setAvailable(true);</span>
<span class="fc" id="L1696">				docRepo.save(docDetailsToRecover);</span>
			} else {
				//No right
<span class="nc" id="L1699">				NotifyBean info = new NotifyBean(prop.getText(&quot;editor.recover.notifyTitle&quot;), prop.getText(&quot;editor.recover.notify.no_right&quot;), NotifyBean.NotifyType.WARNING, 60000);</span>
<span class="nc" id="L1700">				addNotify(info);</span>
<span class="nc" id="L1701">				return;</span>
			}
		}

		//Refresh
<span class="fc" id="L1706">		DocDB.getInstance(true);</span>
<span class="fc" id="L1707">		GroupsDB.getInstance(true);</span>

		//Success
<span class="fc" id="L1710">		NotifyBean info = new NotifyBean(prop.getText(&quot;editor.recover.notify_title.success_page&quot;), prop.getText(&quot;editor.recover.notify_body.success_page&quot;, docDetailsToRecover.getTitle(), docDetailsToRecover.getFullPath()), NotifyBean.NotifyType.SUCCESS, 60000);</span>
<span class="fc" id="L1711">		addNotify(info);</span>
<span class="fc" id="L1712">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>