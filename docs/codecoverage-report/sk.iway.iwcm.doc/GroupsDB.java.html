<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="sk"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GroupsDB.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">webjetcms</a> &gt; <a href="index.source.html" class="el_package">sk.iway.iwcm.doc</a> &gt; <span class="el_source">GroupsDB.java</span></div><h1>GroupsDB.java</h1><pre class="source lang-java linenums">package sk.iway.iwcm.doc;

import org.apache.commons.beanutils.BeanUtils;
import org.apache.struts.util.ResponseUtils;

import sk.iway.iwcm.*;
import sk.iway.iwcm.common.CloudToolsForCore;
import sk.iway.iwcm.common.FilePathTools;
import sk.iway.iwcm.common.UserTools;
import sk.iway.iwcm.database.ComplexQuery;
import sk.iway.iwcm.database.Mapper;
import sk.iway.iwcm.database.SimpleQuery;
import sk.iway.iwcm.editor.service.GroupsService;
import sk.iway.iwcm.helpers.BeanDiff;
import sk.iway.iwcm.helpers.BeanDiffPrinter;
import sk.iway.iwcm.i18n.Prop;
import sk.iway.iwcm.io.IwcmFile;
import sk.iway.iwcm.system.cluster.ClusterDB;
import sk.iway.iwcm.system.spring.events.WebjetEvent;
import sk.iway.iwcm.system.spring.events.WebjetEventType;
import sk.iway.iwcm.users.UserDetails;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

import static sk.iway.iwcm.Tools.isEmpty;

/**
 *  Drzi obsah tabulky groups
 *
 *@Title        Interway Content Management
 *@Company      Interway s.r.o. (www.interway.sk)
 *@Copyright    Interway s.r.o. (c) 2001-2002
 *@author       $Author: jeeff $
 *@version      $Revision: 1.18 $
 *@created      $Date: 2004/03/25 17:36:09 $
 *@modified     $Date: 2004/03/25 17:36:09 $
 */
@SuppressWarnings({&quot;java:S6905&quot;})
public class GroupsDB extends DB
{

	private List&lt;GroupDetails&gt; groups;
	//cache pre zobrazenie stromovej struktury stranok (pri velkych sidlach sa to dlho a zbytocne nacitavalo dookola)
<span class="fc" id="L51">	private List&lt;GroupDetails&gt; groupsTreeAllCache = null;</span>

	private Map&lt;Integer, GroupDetails&gt; idToGroups;
	private Map&lt;String,Integer&gt; domainIds;

	private final String serverName;

<span class="fc" id="L58">	public static final Comparator&lt;GroupDetails&gt; groupsDbSorter = new Comparator&lt;GroupDetails&gt;(){</span>
		@Override
		public int compare(GroupDetails group1, GroupDetails group2)
		{
<span class="fc bfc" id="L62" title="All 2 branches covered.">			return 	group1.getSortPriority() - group2.getSortPriority() != 0 ?</span>
<span class="fc" id="L63">						group1.getSortPriority() - group2.getSortPriority() :</span>
<span class="fc" id="L64">						group1.getGroupId() - group2.getGroupId();</span>
		}
	};

<span class="fc" id="L68">	public static final Comparator&lt;GroupDetails&gt; nameSorter = new Comparator&lt;GroupDetails&gt;()</span>
<span class="fc" id="L69">	{</span>
		@Override
		public int compare(GroupDetails group1, GroupDetails group2)
		{
<span class="nc" id="L73">			return Tools.slovakCollator.compare(group1.getGroupName(), group2.getGroupName());</span>
		}
	};


	/**
	 * vrati instanciu triedy
	 * @return
	 */
	public static GroupsDB getInstance()
	{
<span class="fc" id="L84">		return(getInstance(false));</span>
	}

	/**
	 * vrati instanciu triedy
	 * @param forceRefresh
	 * @return
	 */
	public static GroupsDB getInstance(boolean forceRefresh)
	{
<span class="fc" id="L94">		return(getInstance(Constants.getServletContext(), forceRefresh, &quot;iwcm&quot;)); //NOSONAR</span>
	}

	/**
	 *  Gets the instance attribute of the GroupsDB class
	 *
	 *@param  servletContext  Description of the Parameter
	 *@param  force_refresh   Description of the Parameter
	 *@param  serverName      Description of the Parameter
	 *@return                 The instance value
	 *@deprecated - pouzite verziu getInstance(boolean forceRefresh)
	 */
	@Deprecated
	public static GroupsDB getInstance(javax.servlet.ServletContext servletContext, boolean force_refresh, String serverName)
	{
		//try to get it from server space
<span class="fc bfc" id="L110" title="All 2 branches covered.">		if (force_refresh == false)</span>
		{
<span class="fc" id="L112">			GroupsDB groupsDB = ((GroupsDB) servletContext.getAttribute(Constants.A_GROUPS_DB));</span>
			//Logger.println(this,&quot;GroupsDB: getting from server space&quot;);
<span class="pc bpc" id="L114" title="1 of 4 branches missed.">			if (groupsDB != null &amp;&amp; groupsDB.groups!=null) // fix MBO: ak groups je null, zbehne force refresh</span>
			{
<span class="fc" id="L116">				return groupsDB;</span>
			}
		}
<span class="fc" id="L119">		synchronized (GroupsDB.class)</span>
		{
<span class="fc bfc" id="L121" title="All 2 branches covered.">			if (force_refresh)</span>
			{
<span class="fc" id="L123">				GroupsDB groupsDB = new GroupsDB(servletContext, serverName);</span>
				//	remove
<span class="fc" id="L125">				servletContext.removeAttribute(Constants.A_GROUPS_DB);</span>
				//save us to server space
<span class="fc" id="L127">				servletContext.setAttribute(Constants.A_GROUPS_DB, groupsDB);</span>

<span class="fc" id="L129">				return groupsDB;</span>
			}
			else
			{
<span class="fc" id="L133">				GroupsDB groupsDB = (GroupsDB) servletContext.getAttribute(Constants.A_GROUPS_DB);</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">				if (groupsDB == null)</span>
				{
<span class="fc" id="L136">					groupsDB = new GroupsDB(servletContext, serverName);</span>
					//	remove
<span class="fc" id="L138">					servletContext.removeAttribute(Constants.A_GROUPS_DB);</span>
					//save us to server space
<span class="fc" id="L140">					servletContext.setAttribute(Constants.A_GROUPS_DB, groupsDB);</span>

				}
<span class="fc" id="L143">				return groupsDB;</span>
			}
		}
	}

	/**
	 *  Constructor for the GroupsDB object
	 *
	 *@param  servletContext  Description of the Parameter
	 *@param  serverName      Description of the Parameter
	 */
	private GroupsDB(javax.servlet.ServletContext servletContext, String serverName)
<span class="fc" id="L155">	{</span>
<span class="fc" id="L156">		Logger.println(this,&quot;GroupsDB: constructor [&quot; + Constants.getInstallName()+&quot;]&quot;);</span>
<span class="fc" id="L157">		this.serverName = serverName;</span>

		try
		{
<span class="fc" id="L161">			reloadGroups();</span>
		}
<span class="nc" id="L163">		catch (Exception ex)</span>
		{
<span class="nc" id="L165">			sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L166">		}</span>

<span class="fc" id="L168">		ClusterDB.addRefresh(GroupsDB.class);</span>
<span class="fc" id="L169">		Cache.getInstance().removeObjectStartsWithName(&quot;GroupsDB.&quot;);</span>
<span class="fc" id="L170">	}</span>

	/**
	 *  Description of the Method
	 *
	 *@exception  Exception  Description of the Exception
	 */
	public void reloadGroups() throws Exception
	{
<span class="fc" id="L179">		DebugTimer dt = new DebugTimer(&quot;GroupsDB.reloadGroups&quot;);</span>

		//ak vieme predchadzajucu velkost, tak si ju vopred predalokujeme
<span class="fc" id="L182">		List&lt;GroupDetails&gt; groupsHolderWhileLoading = new CopyOnWriteArrayList&lt;&gt;(); //Collections.synchronizedList(new ArrayList&lt;&gt;(groups!=null?groups.size():300));</span>
		//ak existuje, tak si vopred predalokuj dost miesta pre kluce
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">		Map&lt;Integer, GroupDetails&gt; idToGroupsHolderWhileLoading = Collections.synchronizedMap(new HashMap&lt;Integer, GroupDetails&gt;(idToGroups!=null?idToGroups.size():300));</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">		Map&lt;String,GroupDetails&gt; domainIdsGroups = Collections.synchronizedMap(new HashMap&lt;String, GroupDetails&gt;(domainIds!=null?domainIds.size():100));</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">		Map&lt;String,Integer&gt; domainIdsHolderWhileLoading = Collections.synchronizedMap(new HashMap&lt;String, Integer&gt;(domainIds!=null?domainIds.size():100));</span>

<span class="fc" id="L188">		java.sql.Connection db_conn = null;</span>
<span class="fc" id="L189">		java.sql.PreparedStatement ps = null;</span>
<span class="fc" id="L190">		java.sql.ResultSet rs = null;</span>
		try
		{
<span class="fc" id="L193">			dt.diff(&quot;after objects&quot;);</span>

<span class="fc" id="L195">			db_conn = DBPool.getConnection(serverName);</span>
<span class="fc" id="L196">			String sql = &quot;SELECT * FROM groups ORDER BY sort_priority, group_name&quot;;</span>
<span class="fc" id="L197">			ps = db_conn.prepareStatement(sql);</span>
<span class="fc" id="L198">			rs = ps.executeQuery();</span>

<span class="fc" id="L200">			dt.diff(&quot;after rs&quot;);</span>

<span class="fc bfc" id="L202" title="All 2 branches covered.">			while (rs.next())</span>
			{
<span class="fc" id="L204">				GroupDetails group = fillFieldsByResultSet(rs);</span>

<span class="fc" id="L206">				groupsHolderWhileLoading.add(group);</span>
<span class="fc" id="L207">				idToGroupsHolderWhileLoading.put(group.getGroupId(), group);</span>
<span class="fc bfc" id="L208" title="All 4 branches covered.">				if(Tools.isNotEmpty(group.getDomainName()) &amp;&amp; group.getParentGroupId() == 0)</span>
				{
<span class="fc" id="L210">					GroupDetails domainGroup = domainIdsGroups.get(group.getDomainName());</span>
					//ako domainId bereme groupId, ktore ma najnizsie ID, aby sa prvo vytvoreny priecinok v domene zachoval
<span class="fc bfc" id="L212" title="All 4 branches covered.">					if (domainGroup==null || group.getGroupId()&lt;domainGroup.getGroupId())</span>
					{

<span class="fc" id="L215">						domainIdsGroups.put(group.getDomainName(), group);</span>
						//pomocou konf. premennej domainId-www.domena.sk je mozne nastavit fixne ID, napr. ak zmazeme povodny korenovy priecinok domeny
<span class="fc" id="L217">						int constantDomainId = Constants.getInt(&quot;domainId-&quot;+group.getDomainName());</span>
<span class="fc" id="L218">						int domainId = group.getGroupId();</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">						if (constantDomainId&gt;0) domainId = constantDomainId;</span>
<span class="fc" id="L220">						domainIdsHolderWhileLoading.put(group.getDomainName(), domainId);</span>
					}
				}
<span class="fc" id="L223">			}</span>
<span class="fc" id="L224">			rs.close();</span>
<span class="fc" id="L225">			ps.close();</span>
<span class="fc" id="L226">			db_conn.close();</span>
<span class="fc" id="L227">			db_conn = null;</span>
<span class="fc" id="L228">			ps = null;</span>
<span class="fc" id="L229">			rs = null;</span>

<span class="fc" id="L231">			groups = groupsHolderWhileLoading;</span>
<span class="fc" id="L232">			idToGroups = idToGroupsHolderWhileLoading;</span>
<span class="fc" id="L233">			domainIds = domainIdsHolderWhileLoading;</span>

<span class="fc" id="L235">			dt.diff(&quot;after db load&quot;);</span>

			//nastav full path
<span class="fc bfc" id="L238" title="All 2 branches covered.">			for (GroupDetails group : groups)</span>
			{
<span class="fc" id="L240">				group.setFullPath(getPath(group.getGroupId()));</span>
<span class="fc" id="L241">			}</span>

<span class="fc" id="L243">			dt.diff(&quot;after full path&quot;);</span>

<span class="fc" id="L245">			getAllSystemFolders(true);</span>

<span class="fc" id="L247">			dt.diff(&quot;after system folders&quot;);</span>
		}
<span class="nc" id="L249">		catch (Exception ex){sk.iway.iwcm.Logger.error(ex);}</span>
		finally{
			try{
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">				if (rs != null) rs.close();</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">				if (ps != null) ps.close();</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">				if (db_conn != null) db_conn.close();</span>
<span class="pc" id="L255">			}catch (Exception e) {sk.iway.iwcm.Logger.error(e);}</span>
		}

<span class="fc" id="L258">		dt.diff(&quot;done&quot;);</span>
<span class="fc" id="L259">	}</span>

	/**
	 * Naplni objekt z result setu
	 * @param rs
	 * @return
	 * @throws SQLException
	 */
	public static GroupDetails fillFieldsByResultSet(java.sql.ResultSet rs) throws SQLException
	{
		GroupDetails group;
<span class="fc" id="L270">		group = new GroupDetails();</span>
<span class="fc" id="L271">		group.setGroupId(rs.getInt(&quot;group_id&quot;));</span>
<span class="fc" id="L272">		group.setGroupName(getDbString(rs, &quot;group_name&quot;));</span>
<span class="fc" id="L273">		group.setInternal(rs.getBoolean(&quot;internal&quot;));</span>
<span class="fc" id="L274">		group.setParentGroupId(rs.getInt(&quot;parent_group_id&quot;));</span>
<span class="fc" id="L275">		group.setNavbar(getDbString(rs, &quot;navbar&quot;));</span>
<span class="fc" id="L276">		group.setDefaultDocId(rs.getInt(&quot;default_doc_id&quot;));</span>
<span class="fc" id="L277">		group.setTempId(rs.getInt(&quot;temp_id&quot;));</span>
<span class="fc" id="L278">		group.setSortPriority(rs.getInt(&quot;sort_priority&quot;));</span>
<span class="fc" id="L279">		group.setPasswordProtected(getDbString(rs, &quot;password_protected&quot;));</span>
<span class="fc" id="L280">		group.setMenuType(rs.getInt(&quot;menu_type&quot;));</span>
<span class="fc" id="L281">		group.setUrlDirName(getDbString(rs, &quot;url_dir_name&quot;));</span>
<span class="fc" id="L282">		group.setSyncId(rs.getInt(&quot;sync_id&quot;));</span>
<span class="fc" id="L283">		group.setSyncStatus(rs.getInt(&quot;sync_status&quot;));</span>
<span class="fc" id="L284">		group.setHtmlHead(DB.getDbString(rs, &quot;html_head&quot;));</span>
<span class="fc" id="L285">		group.setLogonPageDocId(rs.getInt(&quot;logon_page_doc_id&quot;));</span>

		//	domain_name, new_page_docid_template, install_name, field_a, field_b, field_c, field_d
<span class="fc" id="L288">		group.setDomainName(DB.getDbString(rs, &quot;domain_name&quot;));</span>
<span class="fc" id="L289">		group.setNewPageDocIdTemplate(rs.getInt(&quot;new_page_docid_template&quot;));</span>
<span class="fc" id="L290">		group.setInstallName(DB.getDbString(rs, &quot;install_name&quot;));</span>
<span class="fc" id="L291">		group.setFieldA(DB.getDbString(rs, &quot;field_a&quot;));</span>
<span class="fc" id="L292">		group.setFieldB(DB.getDbString(rs, &quot;field_b&quot;));</span>
<span class="fc" id="L293">		group.setFieldC(DB.getDbString(rs, &quot;field_c&quot;));</span>
<span class="fc" id="L294">		group.setFieldD(DB.getDbString(rs, &quot;field_d&quot;));</span>

<span class="fc" id="L296">		group.setLoggedMenuType(rs.getInt(&quot;logged_menu_type&quot;));</span>
<span class="fc" id="L297">		group.setLinkGroupId(rs.getInt(&quot;link_group_id&quot;));</span>
<span class="fc" id="L298">		group.setLng(rs.getString(&quot;lng&quot;));</span>
<span class="fc" id="L299">		group.setHiddenInAdmin(rs.getBoolean(&quot;hidden_in_admin&quot;));</span>
<span class="fc" id="L300">		group.setForceTheUseOfGroupTemplate(rs.getBoolean(&quot;force_group_template&quot;));</span>

<span class="fc" id="L302">		DataAccessHelper.groupLoadData(rs, group);</span>

<span class="fc" id="L304">		return group;</span>
	}


	/**
	 * Naplni objekt GroupSchedulerDetails z result setu
	 * @param rs
	 * @return
	 * @throws SQLException
	 */
	public static GroupSchedulerDetails fillFieldsByResultSetFromScheduler(java.sql.ResultSet rs) throws SQLException
	{
		GroupSchedulerDetails groupScheduler;
<span class="nc" id="L317">		groupScheduler = new GroupSchedulerDetails();</span>
<span class="nc" id="L318">		groupScheduler.setGroupId(rs.getInt(&quot;group_id&quot;));</span>
<span class="nc" id="L319">		groupScheduler.setGroupName(getDbString(rs, &quot;group_name&quot;));</span>
<span class="nc" id="L320">		groupScheduler.setInternal(rs.getBoolean(&quot;internal&quot;));</span>
<span class="nc" id="L321">		groupScheduler.setParentGroupId(rs.getInt(&quot;parent_group_id&quot;));</span>
<span class="nc" id="L322">		groupScheduler.setNavbar(getDbString(rs, &quot;navbar&quot;));</span>
<span class="nc" id="L323">		groupScheduler.setDefaultDocId(rs.getInt(&quot;default_doc_id&quot;));</span>
<span class="nc" id="L324">		groupScheduler.setTempId(rs.getInt(&quot;temp_id&quot;));</span>
<span class="nc" id="L325">		groupScheduler.setSortPriority(rs.getInt(&quot;sort_priority&quot;));</span>
<span class="nc" id="L326">		groupScheduler.setPasswordProtected(getDbString(rs, &quot;password_protected&quot;));</span>
<span class="nc" id="L327">		groupScheduler.setMenuType(rs.getInt(&quot;menu_type&quot;));</span>
<span class="nc" id="L328">		groupScheduler.setUrlDirName(getDbString(rs, &quot;url_dir_name&quot;));</span>
<span class="nc" id="L329">		groupScheduler.setSyncId(rs.getInt(&quot;sync_id&quot;));</span>
<span class="nc" id="L330">		groupScheduler.setSyncStatus(rs.getInt(&quot;sync_status&quot;));</span>
<span class="nc" id="L331">		groupScheduler.setHtmlHead(DB.getDbString(rs, &quot;html_head&quot;));</span>
<span class="nc" id="L332">		groupScheduler.setLogonPageDocId(rs.getInt(&quot;logon_page_doc_id&quot;));</span>

		//	domain_name, new_page_docid_template, install_name, field_a, field_b, field_c, field_d
<span class="nc" id="L335">		groupScheduler.setDomainName(DB.getDbString(rs, &quot;domain_name&quot;));</span>
<span class="nc" id="L336">		groupScheduler.setNewPageDocIdTemplate(rs.getInt(&quot;new_page_docid_template&quot;));</span>
<span class="nc" id="L337">		groupScheduler.setInstallName(DB.getDbString(rs, &quot;install_name&quot;));</span>
<span class="nc" id="L338">		groupScheduler.setFieldA(DB.getDbString(rs, &quot;field_a&quot;));</span>
<span class="nc" id="L339">		groupScheduler.setFieldB(DB.getDbString(rs, &quot;field_b&quot;));</span>
<span class="nc" id="L340">		groupScheduler.setFieldC(DB.getDbString(rs, &quot;field_c&quot;));</span>
<span class="nc" id="L341">		groupScheduler.setFieldD(DB.getDbString(rs, &quot;field_d&quot;));</span>

<span class="nc" id="L343">		groupScheduler.setLoggedMenuType(rs.getInt(&quot;logged_menu_type&quot;));</span>
<span class="nc" id="L344">		groupScheduler.setLinkGroupId(rs.getInt(&quot;link_group_id&quot;));</span>

		//groupScheduler
<span class="nc" id="L347">		groupScheduler.setUserId(rs.getInt(&quot;user_id&quot;));</span>
<span class="nc" id="L348">		groupScheduler.setSaveDate(rs.getTimestamp(&quot;save_date&quot;));</span>
<span class="nc" id="L349">		groupScheduler.setScheduleId(rs.getInt(&quot;schedule_id&quot;));</span>
<span class="nc" id="L350">		groupScheduler.setWhenToPublish(rs.getTimestamp(&quot;when_to_publish&quot;));</span>

<span class="nc" id="L352">		groupScheduler.setLng(rs.getString(&quot;lng&quot;));</span>
<span class="nc" id="L353">		groupScheduler.setHiddenInAdmin(rs.getBoolean(&quot;hidden_in_admin&quot;));</span>
<span class="nc" id="L354">		groupScheduler.setForceTheUseOfGroupTemplate(rs.getBoolean(&quot;force_group_template&quot;));</span>

<span class="nc" id="L356">		DataAccessHelper.groupLoadData(rs, groupScheduler);</span>

<span class="nc" id="L358">		return groupScheduler;</span>
	}

	/**
	 *  Vrati zoznam skupin v danej skupine
	 *
	 *@param  parent  Description of the Parameter
	 *@return         The groups value
	 */
	public List&lt;GroupDetails&gt; getGroups(int parent)
	{
<span class="fc" id="L369">		List&lt;GroupDetails&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">		for (GroupDetails group : groups)</span>
		{
<span class="fc bfc" id="L372" title="All 2 branches covered.">			if (group.getParentGroupId() == parent)</span>
			{
<span class="fc" id="L374">				ret.add(group);</span>
			}
<span class="fc" id="L376">		}</span>
<span class="fc" id="L377">		return (ret);</span>
	}

	/**
	 * Vrati zoznam skupin v danej skupine dostupnych v menu
	 * @param parent
	 * @return
	 */
	public List&lt;GroupDetails&gt; getGroupsAvailableInMenu(int parent)
	{
<span class="nc" id="L387">		return getGroupsAvailableInMenu(parent, null);</span>
	}

	 /**
	  * Vrati zoznam skupin v danej skupine dostupnych v menu, testuje menuType pre prihlaseneho usera
	  * @param parent
	  * @param session
	  * @return
	  */
	 public List&lt;GroupDetails&gt; getGroupsAvailableInMenu(int parent, HttpSession session)
	 {
<span class="nc" id="L398">		  List&lt;GroupDetails&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">		 for (GroupDetails group : groups)</span>
		  {
<span class="nc bnc" id="L401" title="All 6 branches missed.">				if (group.getParentGroupId() == parent &amp;&amp; group.isInternal()==false &amp;&amp; group.getMenuType(session)!=GroupDetails.MENU_TYPE_HIDDEN)</span>
				{
<span class="nc" id="L403">					 ret.add(group);</span>
				}
<span class="nc" id="L405">		  }</span>
<span class="nc" id="L406">		  return (ret);</span>
	 }

	/**
	 *  Vrati GroupDetails so zadanym ID
	 *
	 *@param  group_id - id adresara
	 *@return           The group value
	 */
	public GroupDetails getGroup(int group_id)
	{
<span class="fc" id="L417">		return idToGroups.get(group_id);</span>
	}

	/**
	 * Ziska adresar podla zadanej full path
	 * @param fullPath
	 * @return
	 */
	public GroupDetails getGroupByPath(String fullPath)
	{
<span class="fc" id="L427">		return getGroupByPathAndDomain(fullPath, null);</span>
	}

	public GroupDetails getGroupByPathAndDomain(String fullPath, String domainName) {
<span class="pc bpc" id="L431" title="3 of 4 branches missed.">		if (fullPath.endsWith(&quot;/&quot;) &amp;&amp; fullPath.length() &gt; 1)</span>
		{
			//Remove last character, slash &quot;/&quot;
<span class="nc" id="L434">			fullPath = fullPath.substring(0, fullPath.length()-1);</span>
		}

<span class="fc" id="L437">		RequestBean rb = SetCharacterEncodingFilter.getCurrentRequestBean();</span>
<span class="fc" id="L438">		GroupDetails firstGroup = null;</span>
		//Loop all groups to find match
<span class="fc bfc" id="L440" title="All 2 branches covered.">		for (GroupDetails group : getGroupsAll())</span>
		{
			//We found match be full path
<span class="fc bfc" id="L443" title="All 2 branches covered.">			if (group.getFullPath().equals(fullPath))</span>
			{
				//Check if domainName is set - IF yes, we REQUIRE match
<span class="pc bpc" id="L446" title="1 of 4 branches missed.">				if(Constants.getBoolean(&quot;multiDomainEnabled&quot;) == true &amp;&amp; Tools.isNotEmpty(domainName)) {</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">					if(domainName.equals(group.getDomainName())) return group;</span>
				} else {
					//We are good with only fullPath match
<span class="fc bfc" id="L450" title="All 2 branches covered.">					if (firstGroup == null) firstGroup = group;</span>

					//If we have better match full path AND domainName, we return it
<span class="pc bpc" id="L453" title="3 of 6 branches missed.">					if (rb != null &amp;&amp; Tools.isNotEmpty(rb.getDomain()) &amp;&amp; Constants.getBoolean(&quot;multiDomainEnabled&quot;)==true) {</span>
						//mame presnu zhodu aj podla domenoveho mena
<span class="fc bfc" id="L455" title="All 2 branches covered.">						if (rb.getDomain().equals(group.getDomainName())) return group;</span>
					}
				}
			}
<span class="fc" id="L459">		}</span>
<span class="fc" id="L460">		return firstGroup;</span>
	}

	/**
	 *  Gets the group attribute of the GroupsDB object
	 *
	 *@param  groupName  Description of the Parameter
	 *@return           The group value
	 */
	public GroupDetails getGroup(String groupName)
	{
<span class="nc" id="L471">		return getGroup(groupName,false);</span>
	}

	/**
	 *  Gets the group attribute of the GroupsDB object
	 *
	 *@param  groupName  Description of the Parameter
	 *@param internationalToEnglish ci sa maju nazvy adresarov upravit z international do english
	 *@return           The group value
	 */
	public GroupDetails getGroup(String groupName, boolean internationalToEnglish)
	{
<span class="nc" id="L483">		groupName = sanitizeGroupName(groupName, true);</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">		if (Tools.isNotEmpty(groupName))</span>
		{
<span class="nc bnc" id="L486" title="All 2 branches missed.">			for (GroupDetails group : getGroupsAll())</span>
			{
<span class="nc bnc" id="L488" title="All 2 branches missed.">				if(internationalToEnglish)</span>
				{
<span class="nc bnc" id="L490" title="All 2 branches missed.">					if (DB.internationalToEnglish(groupName).equalsIgnoreCase(DB.internationalToEnglish(group.getGroupName())))</span>
					{
<span class="nc" id="L492">						return (group);</span>
					}
				}
				else
				{
<span class="nc bnc" id="L497" title="All 2 branches missed.">					if (groupName.equalsIgnoreCase(group.getGroupName()))</span>
					{
<span class="nc" id="L499">						return (group);</span>
					}
				}
<span class="nc" id="L502">			}</span>
		}
<span class="nc" id="L504">		return (null);</span>
	}

	/**
	 * Ziska adresar so zadanym menom v zadanom adresari
	 * @param groupName
	 * @param parentGroupId
	 * @return
	 */
	public GroupDetails getGroup(String groupName, int parentGroupId)
	{
<span class="fc" id="L515">		GroupDetails firstGroup = null;</span>
<span class="fc" id="L516">		RequestBean rb = SetCharacterEncodingFilter.getCurrentRequestBean();</span>
<span class="fc" id="L517">		groupName = sanitizeGroupName(groupName, true);</span>
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">		if (Tools.isNotEmpty(groupName))</span>
		{
<span class="fc bfc" id="L520" title="All 2 branches covered.">			for (GroupDetails group : getGroupsAll())</span>
			{
<span class="fc bfc" id="L522" title="All 4 branches covered.">				if (group.getParentGroupId() == parentGroupId &amp;&amp; groupName.equalsIgnoreCase(group.getGroupName()))</span>
				{
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">					if (firstGroup==null) firstGroup = group;</span>
<span class="pc bpc" id="L525" title="3 of 6 branches missed.">					if (rb != null &amp;&amp; Tools.isNotEmpty(rb.getDomain()) &amp;&amp; Constants.getBoolean(&quot;multiDomainEnabled&quot;)==true) {</span>
						//mame presnu zhodu aj podla domenoveho mena
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">						if (rb.getDomain().equals(group.getDomainName())) return group;</span>
					}
				}
<span class="fc" id="L530">			}</span>
		}
<span class="fc" id="L532">		return (firstGroup);</span>
	}

	 /**
	  * Ziska adresar so zadanym menom v zadanom adresari, ak neexistuje tak ho vytvori
	  * @param groupName
	  * @param parentGroupId
	  * @return
	  */
	public GroupDetails getOrCreateGroup(String groupName, int parentGroupId)
	{
<span class="nc" id="L543">		 GroupDetails group = getGroup(groupName, parentGroupId);</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">		 if (group == null) {</span>
<span class="nc" id="L545">			  group = addNewGroup(groupName, parentGroupId);</span>
		 }
<span class="nc" id="L547">		 return group;</span>
	}


	/**
	 *  Ziska stromovu strukturu adresarov
	 *
	 *@return    The groupsTree value
	 */
	public List&lt;GroupDetails&gt; getGroupsTree()
	{
<span class="nc" id="L558">		List&lt;GroupDetails&gt; p_groups = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L559">		getGroupsTree(0, p_groups, true);</span>
<span class="nc" id="L560">		return (p_groups);</span>
	}

	/**
	 * Ziska stromovu strukturu adresarov iba pre userom editovatelne adresare
	 * @param editableGroups
	 * @return
	 */
	public List&lt;GroupDetails&gt; getGroupsTree(String editableGroups)
	{
		//cache pre groupslist-tree.jsp
<span class="pc bpc" id="L571" title="2 of 4 branches missed.">		if (Tools.isEmpty(editableGroups) &amp;&amp; groupsTreeAllCache!=null)</span>
		{
<span class="nc" id="L573">			Logger.debug(GroupsDB.class, &quot;getGroupsTree - returning from cache&quot;);</span>
<span class="nc" id="L574">			List&lt;GroupDetails&gt; cloned = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L575">			cloned.addAll(groupsTreeAllCache);</span>
<span class="nc" id="L576">			return cloned;</span>
		}

<span class="fc" id="L579">		List&lt;GroupDetails&gt; p_groups = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L581" title="2 of 4 branches missed.">		if (editableGroups != null &amp;&amp; editableGroups.length() &gt; 0)</span>
		{
<span class="nc" id="L583">			StringTokenizer st = new StringTokenizer(editableGroups, &quot;,&quot;);</span>
			String id;
			int i_id;
<span class="nc bnc" id="L586" title="All 2 branches missed.">			while (st.hasMoreTokens())</span>
			{
<span class="nc" id="L588">				id = st.nextToken().trim();</span>
				try
				{
<span class="nc" id="L591">					i_id = Integer.parseInt(id);</span>
					//pridaj to do stromu editovatelnych stranok
<span class="nc" id="L593">					GroupDetails parentGroup = findGroup(i_id);</span>
<span class="nc" id="L594">					GroupDetails parentGroupCopy = new GroupDetails(parentGroup);</span>
<span class="nc" id="L595">					parentGroupCopy.setParentGroupId(0);</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">					if (parentGroup.getFullPath().length() &gt; 200)</span>
					{
<span class="nc" id="L598">						parentGroupCopy.setGroupName(&quot;...&quot;+parentGroup.getFullPath().substring(parentGroup.getFullPath().length()-198));</span>
					}
					else
					{
<span class="nc" id="L602">						parentGroupCopy.setGroupName(parentGroup.getFullPath());</span>
					}
<span class="nc" id="L604">					p_groups.add(parentGroupCopy);</span>
<span class="nc" id="L605">					getGroupsTree(i_id, p_groups, true);</span>
				}
<span class="nc" id="L607">				catch (Exception ex)</span>
				{

<span class="nc" id="L610">				}</span>
			}
<span class="nc" id="L612">		}</span>
		else
		{
<span class="fc" id="L615">			getGroupsTree(0, p_groups, true);</span>

<span class="pc bpc" id="L617" title="1 of 2 branches missed.">			if (Tools.isEmpty(editableGroups))</span>
			{
<span class="fc" id="L619">				groupsTreeAllCache = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L620">				groupsTreeAllCache.addAll(p_groups);</span>
<span class="fc" id="L621">				Logger.debug(GroupsDB.class, &quot;getGroupsTree - SETTING cache&quot;);</span>
			}
		}

<span class="fc" id="L625">		return (p_groups);</span>
	}


	/**
	 *  Ziska stromovu strukturu adresarov
	 *
	 *@param  parent          rodicovsky adresar
	 *@param  includeParent  ak true, vratane rodica
	 *@param  includeInternals ak true, vratane internych adresarov
	 *@return                 The groupsTree value
	 */
	public List&lt;GroupDetails&gt; getGroupsTree(int parent, boolean includeParent, boolean includeInternals)
	{
<span class="fc" id="L639">		return getGroupsTree(parent, includeParent, includeInternals, false);</span>
	}

	/**
	 * Ziska stromovu strukturu adresarov
	 * @param parent -  rodicovsky adresar
	 * @param includeParent - ak true, vratane rodica
	 * @param includeInternals - ak true, vratane internych adresarov
	 * @param onlyAvailableInMenu - ak true, iba dostupne v menu
	 * @return
	 */
	public List&lt;GroupDetails&gt; getGroupsTree(int parent, boolean includeParent, boolean includeInternals, boolean onlyAvailableInMenu)
	{
<span class="fc" id="L652">		return getGroupsTree(parent, includeParent, includeInternals, onlyAvailableInMenu, null);</span>
	}

	/**
	 * Ziska stromovu strukturu adresarov
	 * @param parent -  rodicovsky adresar
	 * @param includeParent - ak true, vratane rodica
	 * @param includeInternals - ak true, vratane internych adresarov
	 * @param onlyAvailableInMenu - ak true, iba dostupne v menu
	 * @param maxDepth - maximalna hlbka stromu
	 * @return
	 */
	public List&lt;GroupDetails&gt; getGroupsTree(int parent, boolean includeParent, boolean includeInternals, boolean onlyAvailableInMenu, Integer maxDepth)
	{
<span class="fc" id="L666">		List&lt;GroupDetails&gt; p_groups = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">		if (includeParent)</span>
		{
<span class="fc" id="L669">			GroupDetails parentGroup = findGroup(parent);</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">			if (parentGroup != null) p_groups.add(parentGroup);</span>
		}
<span class="fc" id="L672">		getGroupsTree(parent, p_groups, includeInternals, onlyAvailableInMenu, maxDepth);</span>
<span class="fc" id="L673">		return (p_groups);</span>
	}

	/**
	 * Ziska stromovu strukturu adresarov. Rekurzivna metoda!
	 * @param parent
	 * @param p_groups
	 */
	public void getGroupsTree(int parent, List&lt;GroupDetails&gt; p_groups)
	{
<span class="fc" id="L683">		getGroupsTree(parent, p_groups, true);</span>
<span class="fc" id="L684">	}</span>

	/**
	 *  Ziska stromovu strukturu adresarov. Rekurzivna metoda!
	 *
	 *@param  parent    rodicovsky adresar
	 *@param  p_groups  array list, do ktoreho sa to plni
	 *@param  includeInternals ak true, vratane internych adresarov
	 */
	public void getGroupsTree(int parent, List&lt;GroupDetails&gt; p_groups, boolean includeInternals)
	{
<span class="fc" id="L695">		getGroupsTree(parent, p_groups, includeInternals, false);</span>
<span class="fc" id="L696">	}</span>

	/**
	 *
	 * @param parent
	 * @param p_groups
	 * @param includeInternals
	 * @param onlyAvailableInMenu
	 */
	public void getGroupsTree(int parent, List&lt;GroupDetails&gt; p_groups, boolean includeInternals, boolean onlyAvailableInMenu)
	{
<span class="fc" id="L707">		getGroupsTree(parent, p_groups, includeInternals, onlyAvailableInMenu, null);</span>
<span class="fc" id="L708">	}</span>

	/**
	 *
	 * @param parent
	 * @param p_groups
	 * @param includeInternals
	 * @param onlyAvailableInMenu
	 */
	public void getGroupsTree(int parent, List&lt;GroupDetails&gt; p_groups, boolean includeInternals, boolean onlyAvailableInMenu, Integer maxDepth)
	{
<span class="fc" id="L719">		Map&lt;Integer, List&lt;GroupDetails&gt;&gt; childsTable = prepareChildsTable();</span>
<span class="fc" id="L720">		getGroupsTree(childsTable, parent, p_groups, includeInternals, onlyAvailableInMenu, maxDepth, 1);</span>
<span class="fc" id="L721">	}</span>

	/**
	 * Pripravi hash tabulku kde klucom je groupId a hodnotou je zoznam childov
	 * @return
	 */
	private Map&lt;Integer, List&lt;GroupDetails&gt;&gt; prepareChildsTable()
	{
<span class="fc" id="L729">		Map&lt;Integer, List&lt;GroupDetails&gt;&gt; childsTable = new Hashtable&lt;&gt;();</span>

<span class="fc bfc" id="L731" title="All 2 branches covered.">		for (GroupDetails group : groups)</span>
		{
<span class="fc" id="L733">			List&lt;GroupDetails&gt; childsList = childsTable.get(group.getParentGroupId());</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">			if (childsList == null)</span>
			{
<span class="fc" id="L736">				childsList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L737">				childsTable.put(group.getParentGroupId(), childsList);</span>
			}
<span class="fc" id="L739">			childsList.add(group);</span>
<span class="fc" id="L740">		}</span>

<span class="fc" id="L742">		return childsTable;</span>
	}

	/**
	 * Do listu p_groups rekurzivne naplni zoznam childov pre zadane parent group id
	 * @param childsTable
	 * @param parent
	 * @param p_groups
	 * @param includeInternals
	 * @param onlyAvailableInMenu
	 * @param maxDepth
	 */
	private void getGroupsTree(Map&lt;Integer, List&lt;GroupDetails&gt;&gt; childsTable, int parent, List&lt;GroupDetails&gt; p_groups, boolean includeInternals, boolean onlyAvailableInMenu, Integer maxDepth, int iteration)
	{
<span class="fc bfc" id="L756" title="All 4 branches covered.">		if(maxDepth != null &amp;&amp; (iteration &gt; maxDepth)) return;</span>

<span class="fc" id="L758">		List&lt;GroupDetails&gt; childs = childsTable.get(parent);</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">		if (childs == null) return;</span>

<span class="pc bpc" id="L761" title="1 of 2 branches missed.">		if (iteration &gt; 500) return;</span>

<span class="fc" id="L763">		GroupDetails system = null;</span>

<span class="fc bfc" id="L765" title="All 2 branches covered.">		for (GroupDetails group : childs)</span>
		{
<span class="pc bpc" id="L767" title="1 of 4 branches missed.">			if (includeInternals == false &amp;&amp; group.isInternal()) continue;</span>
<span class="pc bpc" id="L768" title="3 of 4 branches missed.">			if (onlyAvailableInMenu &amp;&amp; group.getMenuType()==GroupDetails.MENU_TYPE_HIDDEN) continue;</span>

<span class="pc bpc" id="L770" title="3 of 4 branches missed.">			if (&quot;cloud&quot;.equals(Constants.getInstallName()) &amp;&amp; &quot;System&quot;.equals(group.getGroupName()))</span>
			{
				//system grupu presunieme uplne na koniec
<span class="nc" id="L773">				system = group;</span>
<span class="nc" id="L774">				continue;</span>
			}

<span class="fc" id="L777">			p_groups.add(group);</span>

<span class="pc bpc" id="L779" title="3 of 4 branches missed.">			if (onlyAvailableInMenu &amp;&amp; group.getMenuType()==GroupDetails.MENU_TYPE_NOSUB) continue;</span>

			//recursive call
<span class="fc" id="L782">			getGroupsTree(childsTable, group.getGroupId(), p_groups, includeInternals, onlyAvailableInMenu, maxDepth, iteration+1);</span>
<span class="fc" id="L783">		}</span>

<span class="pc bpc" id="L785" title="1 of 2 branches missed.">		if (system != null)</span>
		{
<span class="nc" id="L787">			p_groups.add(system);</span>
<span class="nc bnc" id="L788" title="All 4 branches missed.">			if (onlyAvailableInMenu &amp;&amp; system.getMenuType()==GroupDetails.MENU_TYPE_NOSUB)</span>
			{
				//continue;
			}
			else
			{
				//recursive call
<span class="nc" id="L795">				getGroupsTree(childsTable, system.getGroupId(), p_groups, includeInternals, onlyAvailableInMenu, maxDepth, iteration+1);</span>
			}
		}
<span class="fc" id="L798">	}</span>

	/**
	 * Vytvori List parent adresarov pre rendering v select boxe namiesto standardneho vyberu, kazde meno adresara je odsadene medzerami aby bola zrozumitelna struktura
	 * @param parent
	 * @param includeParent
	 * @param includeInternals
	 * @param onlyAvailableInMenu
	 * @return
	 */
	public List&lt;LabelValueDetails&gt; getGroupsTreeForSelect(int parent, boolean includeParent, boolean includeInternals, boolean onlyAvailableInMenu)
	{
<span class="nc" id="L810">		List&lt;LabelValueDetails&gt; list = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L812">		int level = 0;</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">		if (includeParent)</span>
		{
<span class="nc" id="L815">			GroupDetails parentGroup = findGroup(parent);</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">			if (parentGroup != null) list.add(new LabelValueDetails(parentGroup.getGroupName(), String.valueOf(parentGroup.getGroupId())));</span>
<span class="nc" id="L817">			level++;</span>
		}

<span class="nc" id="L820">		Map&lt;Integer, List&lt;GroupDetails&gt;&gt; childsTable = prepareChildsTable();</span>
<span class="nc" id="L821">		getGroupsTreeForSelect(childsTable, parent, list, includeInternals, onlyAvailableInMenu, level);</span>

<span class="nc" id="L823">		return list;</span>
	}

	/**
	 * Vytvori List parent adresarov pre rendering v select boxe namiesto standardneho vyberu, kazde meno adresara je odsadene medzerami aby bola zrozumitelna struktura
	 * @param childsTable
	 * @param parent
	 * @param list
	 * @param includeInternals
	 * @param onlyAvailableInMenu
	 * @param level
	 */
	private void getGroupsTreeForSelect(Map&lt;Integer, List&lt;GroupDetails&gt;&gt; childsTable, int parent, List&lt;LabelValueDetails&gt; list, boolean includeInternals, boolean onlyAvailableInMenu, int level)
	{
<span class="nc" id="L837">		List&lt;GroupDetails&gt; childs = childsTable.get(parent);</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">		if (childs == null) return;</span>

<span class="nc" id="L840">		GroupDetails system = null;</span>

<span class="nc" id="L842">		StringBuilder spacer = new StringBuilder();</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">		for (int i=0; i&lt;level; i++)</span>
		{
<span class="nc" id="L845">			spacer.append(Constants.NON_BREAKING_SPACE);</span>
<span class="nc" id="L846">			spacer.append(Constants.NON_BREAKING_SPACE);</span>
<span class="nc" id="L847">			spacer.append(Constants.NON_BREAKING_SPACE);</span>
<span class="nc" id="L848">			spacer.append(Constants.NON_BREAKING_SPACE);</span>
<span class="nc" id="L849">			spacer.append(Constants.NON_BREAKING_SPACE);</span>
		}

<span class="nc bnc" id="L852" title="All 2 branches missed.">		for (GroupDetails group : childs)</span>
		{
<span class="nc bnc" id="L854" title="All 4 branches missed.">			if (includeInternals == false &amp;&amp; group.isInternal()) continue;</span>
<span class="nc bnc" id="L855" title="All 4 branches missed.">			if (onlyAvailableInMenu &amp;&amp; group.getMenuType()==GroupDetails.MENU_TYPE_HIDDEN) continue;</span>

<span class="nc bnc" id="L857" title="All 4 branches missed.">			if (&quot;cloud&quot;.equals(Constants.getInstallName()) &amp;&amp; &quot;System&quot;.equals(group.getGroupName()))</span>
			{
				//system grupu presunieme uplne na koniec
<span class="nc" id="L860">				system = group;</span>
<span class="nc" id="L861">				continue;</span>
			}

<span class="nc" id="L864">			list.add(new LabelValueDetails(spacer.toString()+group.getGroupName(), String.valueOf(group.getGroupId())));</span>

<span class="nc bnc" id="L866" title="All 4 branches missed.">			if (onlyAvailableInMenu &amp;&amp; group.getMenuType()==GroupDetails.MENU_TYPE_NOSUB) continue;</span>

			//recursive call
<span class="nc" id="L869">			getGroupsTreeForSelect(childsTable, group.getGroupId(), list, includeInternals, onlyAvailableInMenu, level+1);</span>
<span class="nc" id="L870">		}</span>

<span class="nc bnc" id="L872" title="All 2 branches missed.">		if (system != null)</span>
		{
<span class="nc" id="L874">			list.add(new LabelValueDetails(spacer.toString()+system.getGroupName(), String.valueOf(system.getGroupId())));</span>
<span class="nc bnc" id="L875" title="All 4 branches missed.">			if (onlyAvailableInMenu &amp;&amp; system.getMenuType()==GroupDetails.MENU_TYPE_NOSUB)</span>
			{
				//continue;
			}
			else
			{
				//recursive call
<span class="nc" id="L882">				getGroupsTreeForSelect(childsTable, system.getGroupId(), list, includeInternals, onlyAvailableInMenu, level+1);</span>
			}
		}
<span class="nc" id="L885">	}</span>

	/**
	 *  najde GroupDetails pre zadane groupId
	 *
	 *@param  groupId  Description of the Parameter
	 *@return          Description of the Return Value
	 */
	public GroupDetails findGroup(int groupId)
	{
<span class="fc" id="L895">		return getGroup(groupId);</span>
	}

	public static GroupDetails findGroup(List&lt;GroupDetails&gt; allGroups, int groupId)
	{
<span class="nc bnc" id="L900" title="All 2 branches missed.">		for (GroupDetails group : allGroups)</span>
		{
<span class="nc bnc" id="L902" title="All 2 branches missed.">			if (group.getGroupId() == groupId)</span>
			{
<span class="nc" id="L904">				return (group);</span>
			}
<span class="nc" id="L906">		}</span>
<span class="nc" id="L907">		return (null);</span>
	}

	/**
	 * Ulozenie adresara do databazy
	 * @param group
	 * @return
	 */
	public boolean save(GroupDetails group)
	{
<span class="fc" id="L917">		return setGroup(group);</span>
	}

	/**
	 * Ulozenie adresara do databazy
	 * @param group
	 * @return
	 */
	public boolean setGroup(GroupDetails group)
	{
<span class="fc" id="L927">		return setGroup(group, true);</span>
	}

	/**
	 * Ulozenie adresara, ak je nastavene doNotPublishEvents na true nie su vyvolane udalosti
	 * @param group
	 * @param publishEvents - ak je true, su vyvolane udalosti (false potrebne ak napr. reagujeme na udalost a potrebujeme znova upravit adresar a nechceme aby doslo k zacykleniu)
	 * @return
	 */
	public boolean setGroup(GroupDetails group, boolean publishEvents)
	{
<span class="fc bfc" id="L938" title="All 2 branches covered.">		if (publishEvents) (new WebjetEvent&lt;GroupDetails&gt;(group, WebjetEventType.ON_START)).publishEvent();</span>

<span class="pc bpc" id="L940" title="5 of 6 branches missed.">		if (InitServlet.isTypeCloud() &amp;&amp; group.getGroupId()&gt;0 &amp;&amp; Tools.isNotEmpty(group.getDomainName()))</span>
		{
			//kontrola prav
<span class="nc" id="L943">			GroupDetails oldGroup = getGroup(group.getGroupId());</span>
<span class="nc bnc" id="L944" title="All 4 branches missed.">			if (oldGroup == null || oldGroup.getDomainName().equals(CloudToolsForCore.getDomainName())==false)</span>
			{
<span class="nc" id="L946">				return false;</span>
			}
		}

<span class="fc" id="L950">		java.sql.Connection db_conn = null;</span>
<span class="fc" id="L951">		java.sql.PreparedStatement ps = null;</span>
<span class="fc" id="L952">		ResultSet rs = null;</span>
		try
		{
<span class="fc" id="L955">			GroupDetails newGroup = (GroupDetails)group.clone();	//Hlasilo CloneNotSupportedException</span>

<span class="pc bpc" id="L957" title="1 of 2 branches missed.">			if (InitServlet.isTypeCloud())</span>
			{
<span class="nc" id="L959">				newGroup.setDomainName(CloudToolsForCore.getDomainName());</span>

<span class="nc bnc" id="L961" title="All 2 branches missed.">				if (newGroup.getParentGroupId()&gt;1)</span>
				{
<span class="nc" id="L963">					GroupDetails parentGroup = getGroup(newGroup.getParentGroupId());</span>
<span class="nc bnc" id="L964" title="All 4 branches missed.">					if (parentGroup == null || parentGroup.getDomainName().equals(newGroup.getDomainName())==false)</span>
					{
<span class="nc" id="L966">						newGroup.setParentGroupId(CloudToolsForCore.getDomainId());</span>
					}
				}
			}

			//nahradim vyskyty &quot;/&quot; a &quot;\&quot; za &quot;-&quot;
<span class="fc" id="L972">			newGroup.setGroupName(Tools.replace(Tools.replace(newGroup.getGroupName(), &quot;\\&quot;, &quot;-&quot;), &quot;/&quot;, &quot;&amp;#47;&quot;));</span>
<span class="fc" id="L973">			newGroup.setNavbar(Tools.replace(Tools.replace(newGroup.getNavbarName(), &quot;\\&quot;, &quot;-&quot;), &quot;/&quot;, &quot;&amp;#47;&quot;));</span>

			//premenovanie nazvu hlavnej stranky Grupy, podla nazvu Grupy
<span class="fc bfc" id="L976" title="All 4 branches covered.">			if(newGroup.getDefaultDocId() &gt; 0 &amp;&amp; GroupsService.canSyncTitle(newGroup)) {</span>
<span class="fc" id="L977">				changeDocTitle(newGroup);</span>
<span class="fc" id="L978">				DocDB.getInstance(true);</span>
			}

<span class="fc" id="L981">			Logger.println(this,&quot;GroupsDB.setGroup: &quot; + newGroup.getGroupName());</span>

<span class="fc" id="L983">			String[] additionalFields = DataAccessHelper.getGroupFields();</span>
<span class="fc" id="L984">			StringBuilder addFieldsInsert = new StringBuilder();</span>
<span class="fc" id="L985">			StringBuilder addFieldsInsertParams = new StringBuilder();</span>
<span class="fc" id="L986">			StringBuilder addFieldsUpdate = new StringBuilder();</span>
<span class="pc bpc" id="L987" title="2 of 4 branches missed.">			if (additionalFields != null &amp;&amp; additionalFields.length&gt;0) {</span>
<span class="fc bfc" id="L988" title="All 2 branches covered.">				for (String field : additionalFields) {</span>
<span class="fc" id="L989">					addFieldsInsert.append(&quot;, &quot;).append(field);</span>
<span class="fc" id="L990">					addFieldsInsertParams.append(&quot;, ?&quot;);</span>
<span class="fc" id="L991">					addFieldsUpdate.append(&quot;, &quot;).append(field).append(&quot;=?&quot;);</span>
				}
			}

<span class="fc" id="L995">			String sql = &quot;INSERT INTO groups (group_name, internal, parent_group_id, navbar, default_doc_id, temp_id, sort_priority, password_protected, menu_type, url_dir_name, html_head, logon_page_doc_id, domain_name, new_page_docid_template, install_name, field_a, field_b, field_c, field_d, logged_menu_type, link_group_id, lng, hidden_in_admin, force_group_template&quot;+addFieldsInsert.toString()+&quot;) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?&quot;+addFieldsInsertParams.toString()+&quot;)&quot;;</span>
<span class="fc bfc" id="L996" title="All 2 branches covered.">			if (newGroup.getGroupId()&gt;0)</span>
			{
<span class="fc" id="L998">				sql = &quot;UPDATE groups SET group_name=?, internal=?, parent_group_id=?, navbar=?, default_doc_id=?, temp_id=?, sort_priority=?, password_protected=?, menu_type=?, url_dir_name=?, sync_status=1, html_head=?, logon_page_doc_id=?, domain_name=?, new_page_docid_template=?, install_name=?, field_a=?, field_b=?, field_c=?, field_d=?, logged_menu_type=?, link_group_id=?, lng=?, hidden_in_admin=?, force_group_template=?&quot;+addFieldsUpdate.toString()+&quot; WHERE group_id=?&quot;;</span>
			}

<span class="fc" id="L1001">			db_conn = DBPool.getConnection();</span>

<span class="fc" id="L1003">			ps = db_conn.prepareStatement(sql);</span>
<span class="fc" id="L1004">			ps.setString(1, newGroup.getGroupName());</span>
<span class="fc" id="L1005">			ps.setBoolean(2, newGroup.isInternal());</span>
<span class="fc" id="L1006">			ps.setInt(3, newGroup.getParentGroupId());</span>
<span class="fc" id="L1007">			ps.setString(4, newGroup.getNavbarName());</span>
<span class="fc" id="L1008">			ps.setInt(5, newGroup.getDefaultDocId());</span>
<span class="fc" id="L1009">			ps.setInt(6, newGroup.getTempId());</span>
<span class="fc" id="L1010">			ps.setInt(7, newGroup.getSortPriority());</span>
<span class="fc" id="L1011">			ps.setString(8, newGroup.getPasswordProtected());</span>
			//#20018, #15784 - pre Plusku ak je nazov noveho adresara cislo, tak daj Nezobrazovat a URL nazov adresara na pomlcku
<span class="pc bpc" id="L1013" title="3 of 4 branches missed.">			if(Tools.getIntValue(newGroup.getGroupName(),0) &gt; 0 &amp;&amp; Constants.getBoolean(&quot;editorGroupReplaceNumberWithDashInUrl&quot;))</span>
			{
<span class="nc" id="L1015">				newGroup.setMenuType(0);</span>
<span class="nc" id="L1016">				newGroup.setUrlDirName(&quot;-&quot;);</span>
<span class="nc" id="L1017">				Logger.println(GroupsDB.class, &quot;nazov adresara &quot;+newGroup.getGroupName()+&quot; {id:&quot;+newGroup.getGroupId()+&quot;} je cislo, nastavujem urlDirName na pomlcku a menuType=0&quot;);</span>
			}

<span class="fc" id="L1020">			ps.setInt(9, newGroup.getMenuType());</span>
<span class="fc" id="L1021">			ps.setString(10, newGroup.getUrlDirName());</span>
<span class="fc" id="L1022">			DB.setClob(ps, 11, newGroup.getHtmlHead());</span>
<span class="fc" id="L1023">			ps.setInt(12, newGroup.getLogonPageDocId());</span>

			//domain_name, new_page_docid_template, install_name, field_a, field_b, field_c, field_d
<span class="pc bpc" id="L1026" title="1 of 4 branches missed.">			if (Constants.getBoolean(&quot;multiDomainEnabled&quot;) &amp;&amp; newGroup.getParentGroupId()&gt;0)</span>
			{
<span class="pc bpc" id="L1028" title="1 of 4 branches missed.">				if (Tools.isEmpty(newGroup.getDomainName()) || Constants.getBoolean(&quot;multiDomainEnableNested&quot;)==false) {</span>
					//ak sa niekde zabudla nastavit domena / alebo nie je zapnute nested, pouzijem parent
<span class="fc" id="L1030">					GroupDetails parentGroup = getGroup(newGroup.getParentGroupId());</span>
<span class="pc bpc" id="L1031" title="2 of 4 branches missed.">					if (parentGroup != null &amp;&amp; Tools.isNotEmpty(parentGroup.getDomainName()))</span>
					{
<span class="fc" id="L1033">						newGroup.setDomainName(parentGroup.getDomainName());</span>
					}
				}
			}
<span class="fc" id="L1037">			ps.setString(13, newGroup.getDomainName());</span>
<span class="fc" id="L1038">			ps.setInt(14, newGroup.getNewPageDocIdTemplate());</span>
<span class="fc" id="L1039">			ps.setString(15, newGroup.getInstallName());</span>
<span class="fc" id="L1040">			ps.setString(16, newGroup.getFieldA());</span>
<span class="fc" id="L1041">			ps.setString(17, newGroup.getFieldB());</span>
<span class="fc" id="L1042">			ps.setString(18, newGroup.getFieldC());</span>
<span class="fc" id="L1043">			ps.setString(19, newGroup.getFieldD());</span>

<span class="fc" id="L1045">			ps.setInt(20, newGroup.getLoggedMenuType());</span>
<span class="fc" id="L1046">			ps.setInt(21, newGroup.getLinkGroupId());</span>

<span class="fc" id="L1048">			ps.setString(22, newGroup.getLng());</span>
<span class="fc" id="L1049">			ps.setBoolean(23, newGroup.isHiddenInAdmin());</span>

<span class="fc" id="L1051">			ps.setBoolean(24, newGroup.isForceTheUseOfGroupTemplate());</span>

<span class="fc" id="L1053">			int psCounter = DataAccessHelper.setGroupPreparedStatement(ps, newGroup, 25);</span>

<span class="fc bfc" id="L1055" title="All 2 branches covered.">			if (newGroup.getGroupId()&gt;0)</span>
			{
<span class="fc" id="L1057">				ps.setInt(psCounter++, newGroup.getGroupId());</span>
			}

<span class="fc" id="L1060">			ps.execute();</span>
<span class="fc" id="L1061">			ps.close();</span>
<span class="fc" id="L1062">			ps = null;</span>

<span class="fc bfc" id="L1064" title="All 2 branches covered.">			boolean isNew = newGroup.getGroupId()&lt;1;</span>
<span class="fc bfc" id="L1065" title="All 2 branches covered.">			if (isNew)</span>
			{
				//ziskaj group ID
<span class="fc" id="L1068">				sql = &quot;SELECT max(group_id) AS group_id FROM groups WHERE group_name=? AND parent_group_id=?&quot;;</span>
<span class="fc" id="L1069">				ps = db_conn.prepareStatement(sql);</span>
<span class="fc" id="L1070">				ps.setString(1, newGroup.getGroupName());</span>
<span class="fc" id="L1071">				ps.setInt(2, newGroup.getParentGroupId());</span>
<span class="fc" id="L1072">				rs = ps.executeQuery();</span>
<span class="pc bpc" id="L1073" title="1 of 2 branches missed.">				if (rs.next())</span>
				{
<span class="fc" id="L1075">					newGroup.setGroupId(rs.getInt(&quot;group_id&quot;));</span>
<span class="fc" id="L1076">					group.setGroupId(newGroup.getGroupId());</span>
				}
<span class="fc" id="L1078">				rs.close();</span>
<span class="fc" id="L1079">				ps.close();</span>
<span class="fc" id="L1080">				rs = null;</span>
<span class="fc" id="L1081">				ps = null;</span>
			}

<span class="fc" id="L1084">			db_conn.close();</span>
<span class="fc" id="L1085">			db_conn = null;</span>

			//ak su nastavene syncId tak zapis aj to, potrebne pre synchronizaciu struktury
<span class="fc bfc" id="L1088" title="All 2 branches covered.">			if (newGroup.getSyncId()&gt;0) {</span>
<span class="fc" id="L1089">				new SimpleQuery().execute(&quot;UPDATE groups SET sync_id=? WHERE group_id=?&quot;, newGroup.getSyncId(), newGroup.getGroupId());</span>
			}

			//groups_scheduler(history)
<span class="fc" id="L1093">			int userId = -1;</span>
<span class="fc" id="L1094">			RequestBean rb = SetCharacterEncodingFilter.getCurrentRequestBean();</span>
<span class="pc bpc" id="L1095" title="1 of 2 branches missed.">			if(rb != null)</span>
<span class="fc" id="L1096">				userId = rb.getUserId();</span>

<span class="fc" id="L1098">			GroupPublisher.addRecord(newGroup, null, userId);</span>
			//GroupPublisher.addRecord(newGroup, null);

<span class="fc" id="L1101">			StringBuilder logMessage = new StringBuilder();</span>
			//refresh data
<span class="fc bfc" id="L1103" title="All 2 branches covered.">			if (isNew)</span>
			{
<span class="fc" id="L1105">				insertGroupInCache(newGroup);</span>
				//nastavovanie full pathu musi byt aj v if aj v else kvoli logovaniu...
<span class="fc" id="L1107">				newGroup.setFullPath(getPath(newGroup.getGroupId()));</span>
<span class="fc" id="L1108">				group.setFullPath(newGroup.getFullPath());</span>
<span class="fc" id="L1109">				logMessage.append(&quot;Vytvoreny adresar &quot;).append(newGroup.getFullPath());</span>
			}
			else
			{
				//vymaz staru a vloz novu - mozu ist na ine miesto v zozname
<span class="fc" id="L1114">				GroupDetails oldGroup = getGroup(newGroup.getGroupId());</span>
<span class="fc" id="L1115">				replaceGroupInCache(oldGroup, newGroup);</span>
<span class="fc" id="L1116">				newGroup.setFullPath(getPath(newGroup.getGroupId()));</span>
<span class="fc" id="L1117">				group.setFullPath(newGroup.getFullPath());</span>

<span class="fc" id="L1119">				BeanDiff diff = new BeanDiff().setNew(newGroup).setOriginal(oldGroup).blacklist(&quot;syncStatus&quot;, &quot;groupIdName&quot;, &quot;fullPath&quot;);</span>
<span class="fc" id="L1120">				logMessage.append(&quot;Zmeneny adresar: &quot;).append(newGroup.getFullPath());</span>
<span class="fc" id="L1121">				logMessage.append('\n').append(new BeanDiffPrinter(diff).toString());</span>
			}
			//zresetuj all tree cache
<span class="fc" id="L1124">			groupsTreeAllCache = null;</span>

<span class="fc" id="L1126">			Adminlog.add(Adminlog.TYPE_GROUP, logMessage.toString(), newGroup.getGroupId(), newGroup.getParentGroupId());</span>
			//oznam ostatnym, ze nastala zmena
<span class="fc" id="L1128">			ClusterDB.addRefresh(GroupsDB.class);</span>

			//aktualizuj FT fieldy
<span class="fc" id="L1131">			DocDB.updateFileNameField(newGroup.getGroupId());</span>

			//ak sa jedna o system adresar, refreshnem zoznam tychto stranok
<span class="pc bpc" id="L1134" title="1 of 2 branches missed.">			if(&quot;System&quot;.equalsIgnoreCase(newGroup.getGroupName())) getAllSystemFolders(true);</span>

<span class="fc bfc" id="L1136" title="All 2 branches covered.">			if (publishEvents) (new WebjetEvent&lt;GroupDetails&gt;(newGroup, WebjetEventType.AFTER_SAVE)).publishEvent();</span>

<span class="fc" id="L1138">			return(true);</span>
		}
<span class="nc" id="L1140">		catch (Exception ex){sk.iway.iwcm.Logger.error(ex);}</span>
		finally{
			try{
<span class="pc bpc" id="L1143" title="1 of 2 branches missed.">				if (rs != null) rs.close();</span>
<span class="pc bpc" id="L1144" title="1 of 2 branches missed.">				if (ps != null) ps.close();</span>
<span class="pc bpc" id="L1145" title="1 of 2 branches missed.">				if (db_conn != null) db_conn.close();</span>
<span class="pc" id="L1146">			}catch (Exception e) {sk.iway.iwcm.Logger.error(e);}</span>
		}
<span class="nc" id="L1148">		return(false);</span>
	}

	/**
	 *  Vrati meno grupy pre zadane group_id
	 *
	 *@param  groupId  id grupy
	 *@return          nazov grupy
	 */
	public String getGroupName(int groupId)
	{
<span class="nc" id="L1159">		GroupDetails group = findGroup(groupId);</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">		if (group == null)</span>
<span class="nc" id="L1161">			return (&quot;&quot;);</span>
<span class="nc" id="L1162">		return group.getGroupName();</span>
	}

	/**
	 *  vrati zoznam potomkov
	 *
	 *@param  groupId     Description of the Parameter
	 *@param  noInternal  Description of the Parameter
	 *@return             Description of the Return Value
	 */
	public List&lt;GroupDetails&gt; findChilds(int groupId, boolean noInternal)
	{
<span class="nc" id="L1174">		List&lt;GroupDetails&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1175" title="All 2 branches missed.">		for (GroupDetails group : groups)</span>
		{
<span class="nc bnc" id="L1177" title="All 2 branches missed.">			if (group.getParentGroupId() == groupId)</span>
			{
<span class="nc bnc" id="L1179" title="All 2 branches missed.">				if (noInternal == true)</span>
				{
<span class="nc bnc" id="L1181" title="All 2 branches missed.">					if (!group.isInternal())</span>
					{
<span class="nc" id="L1183">						ret.add(group);</span>
					}
				}
				else
				{
<span class="nc" id="L1188">					ret.add(group);</span>
				}

			}
<span class="nc" id="L1192">		}</span>
<span class="nc" id="L1193">		return (ret);</span>
	}

	/**
	 *  vrati cestu k zadanej skupine napr.: /iwcm/Produkty
	 *
	 *@param  groupId  Description of the Parameter
	 *@return          The path value
	 */
	public String getPath(int groupId)
	{
<span class="fc bfc" id="L1204" title="All 2 branches covered.">		if (groupId &lt; 1) return(&quot;/&quot;);</span>
<span class="fc" id="L1205">		StringBuilder path = new StringBuilder();</span>
<span class="fc" id="L1206">		boolean finished = false;</span>
<span class="fc" id="L1207">		int currentGroupId = groupId;</span>
<span class="fc" id="L1208">		int depth = 0;</span>
<span class="fc" id="L1209">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc bfc" id="L1211" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L1213">			group = findGroup(currentGroupId);</span>
<span class="fc bfc" id="L1214" title="All 2 branches covered.">			if (group != null)</span>
			{
<span class="fc" id="L1216">				path.insert(0, &quot;/&quot; + group.getGroupName());</span>
<span class="fc" id="L1217">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="fc" id="L1222">				finished = true;</span>
			}
<span class="fc" id="L1224">			depth++;</span>
<span class="fc bfc" id="L1225" title="All 2 branches covered.">			if (depth &gt; max_depth)</span>
			{
<span class="fc" id="L1227">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L1230" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L1232">				finished = true;</span>
			}
		}
<span class="fc" id="L1235">		return (path.toString());</span>
	}

	/**
	 * Vrati zoznam GroupDetails ako cestu k zadanemu groupId
	 * @param groupId
	 * @return
	 */
	public List&lt;GroupDetails&gt; getPathList(int groupId)
	{
<span class="fc" id="L1245">		List&lt;GroupDetails&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L1246" title="1 of 2 branches missed.">		if (groupId &lt; 1) return(ret);</span>

<span class="fc" id="L1248">		boolean finished = false;</span>
<span class="fc" id="L1249">		int currentGroupId = groupId;</span>
<span class="fc" id="L1250">		int depth = 0;</span>
<span class="fc" id="L1251">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc bfc" id="L1253" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L1255">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L1256" title="1 of 2 branches missed.">			if (group != null)</span>
			{
				//pridavame na zaciatok
<span class="fc" id="L1259">				ret.add(0, group);</span>
<span class="fc" id="L1260">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L1265">				finished = true;</span>
			}
<span class="fc" id="L1267">			depth++;</span>
<span class="pc bpc" id="L1268" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L1270">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L1273" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L1275">				finished = true;</span>
			}
		}
<span class="fc" id="L1278">		return (ret);</span>
	}

	public String getPathLinkForward(int groupId, String forward)
	{
<span class="nc" id="L1283">		StringBuilder path = new StringBuilder();</span>
<span class="nc" id="L1284">		boolean finished = false;</span>
<span class="nc" id="L1285">		int currentGroupId = groupId;</span>
<span class="nc" id="L1286">		int depth = 0;</span>
<span class="nc" id="L1287">		int max_depth = 30;</span>
		GroupDetails group;
<span class="nc" id="L1289">		String forwardLink = &quot;&quot;;</span>
<span class="nc bnc" id="L1290" title="All 2 branches missed.">		if (forward!=null)</span>
		{
<span class="nc" id="L1292">			forwardLink = &quot;&amp;forward=&quot;+forward;</span>
		}
<span class="nc bnc" id="L1294" title="All 2 branches missed.">		while (finished == false)</span>
		{
<span class="nc" id="L1296">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">			if (group != null)</span>
			{
<span class="nc" id="L1299">				path.insert(0, &quot;/&lt;a class='groups' href='/admin/v9/webpages/web-pages-list/?groupid=&quot;+group.getGroupId()+forwardLink+&quot;'&gt;&quot; + ResponseUtils.filter(group.getGroupName()) + &quot;&lt;/a&gt;&quot;);</span>
<span class="nc" id="L1300">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L1305">				finished = true;</span>
			}
<span class="nc" id="L1307">			depth++;</span>
<span class="nc bnc" id="L1308" title="All 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L1310">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L1313" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L1315">				finished = true;</span>
			}
		}
<span class="nc" id="L1318">		return (path.toString());</span>
	}

	/**
	 * Vrati cestu k suboru ak je v subor v ListGroup inak vrati cestu s groupid = 0 (root)
	 * @param groupId
	 * @param forward
	 * @param listGroup
	 * @return
	 */
	public String getPathLinkForwardExceptNotAllow(int groupId, String forward, List&lt;GroupDetails&gt; listGroup)
	{
<span class="nc" id="L1330">		StringBuilder path = new StringBuilder();</span>
<span class="nc" id="L1331">		boolean finished = false;</span>
<span class="nc" id="L1332">		int currentGroupId = groupId;</span>
<span class="nc" id="L1333">		int depth = 0;</span>
<span class="nc" id="L1334">		int max_depth = 30;</span>
		GroupDetails group;
<span class="nc" id="L1336">		String forwardLink = &quot;&quot;;</span>
<span class="nc bnc" id="L1337" title="All 2 branches missed.">		if (forward!=null)</span>
		{
<span class="nc" id="L1339">			forwardLink = &quot;&amp;forward=&quot;+forward;</span>
		}
<span class="nc bnc" id="L1341" title="All 2 branches missed.">		while (finished == false)</span>
		{
<span class="nc" id="L1343">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L1344" title="All 2 branches missed.">			if (group != null)</span>
			{
				//is_allow
				String replaceID;
<span class="nc bnc" id="L1348" title="All 2 branches missed.">				if(  isAllow(listGroup, group.getGroupId())  )</span>
<span class="nc" id="L1349">					replaceID = group.getGroupId()+&quot;&quot;;</span>
				else
<span class="nc" id="L1351">					replaceID = &quot;0&quot; ;</span>
<span class="nc" id="L1352">				path.insert(0, &quot;/&lt;a class='groups' href='/admin/v9/webpages/web-pages-list/?groupid=&quot;+replaceID+forwardLink+&quot;'&gt;&quot; + group.getGroupName() + &quot;&lt;/a&gt;&quot;);</span>
<span class="nc" id="L1353">				currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1354">			}</span>
			else
			{
				//group doesn't exist
<span class="nc" id="L1358">				finished = true;</span>
			}
<span class="nc" id="L1360">			depth++;</span>
<span class="nc bnc" id="L1361" title="All 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L1363">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L1366" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L1368">				finished = true;</span>
			}
		}
<span class="nc" id="L1371">		return (path.toString());</span>
	}

	/**
	 * Vrati true ak v danom ListGroup je adresar s ID =  groupId
	 * @param ListGroup - zoznam vsetkych suborov
	 * @param groupId - id aktualneho adresara
	 */
	private static boolean isAllow(List&lt;GroupDetails&gt; listGroup,int groupId)
	{
<span class="nc bnc" id="L1381" title="All 2 branches missed.">		if(groupId == 0)</span>
<span class="nc" id="L1382">			return true;</span>

<span class="nc" id="L1384">		boolean finded = false;</span>
<span class="nc bnc" id="L1385" title="All 2 branches missed.">		for(int i = 0; i &lt; listGroup.size() ; i++)</span>
		{
<span class="nc bnc" id="L1387" title="All 2 branches missed.">			if( (listGroup.get(i).getGroupId()+&quot;&quot;).equals(groupId+&quot;&quot;) )</span>
<span class="nc" id="L1388">				return true;</span>
		}
<span class="nc" id="L1390">		return finded;</span>
	}
	/**
	 * Vrati naformatovanu cestu priorit k danemu adresaru (napr. 1.20.14)
	 * @param groupId
	 * @return
	 */
	public String getPathPriorityNumbers(int groupId)
	{
<span class="nc" id="L1399">		StringBuilder path = new StringBuilder();</span>
<span class="nc" id="L1400">		boolean finished = false;</span>
<span class="nc" id="L1401">		int currentGroupId = groupId;</span>
<span class="nc" id="L1402">		int depth = 0;</span>
<span class="nc" id="L1403">		int max_depth = 30;</span>
		GroupDetails group;
<span class="nc bnc" id="L1405" title="All 2 branches missed.">		while (finished == false)</span>
		{
<span class="nc" id="L1407">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L1408" title="All 2 branches missed.">			if (group != null)</span>
			{
<span class="nc" id="L1410">				path.insert(0, group.getSortPriority() + &quot;.&quot;);</span>
<span class="nc" id="L1411">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L1416">				finished = true;</span>
			}
<span class="nc" id="L1418">			depth++;</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L1421">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L1424" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L1426">				finished = true;</span>
			}
		}
<span class="nc" id="L1429">		return (path.toString());</span>
	}

	/**
	 * Vrati retazec s cestou k adresaru (napr. /sk/nieco/podnieco).
	 * Pouziva UrlDirName groupDetails
	 * @param groupId
	 * @return
	 */
	public String getURLPath(int groupId)
	{
<span class="fc" id="L1440">		return(getURLPathGroup(groups, groupId));</span>
	}

	/**
	 * Vrati retazec s cestou k adresaru (napr. /sk/nieco/podnieco).
	 * @param allGroups
	 * @param groupId
	 * @return
	 */
	public static String getURLPathGroup(List&lt;GroupDetails&gt; allGroups, int groupId)
	{
<span class="fc" id="L1451">		String[] retData = getURLPathDomainGroup(allGroups, groupId);</span>
<span class="fc" id="L1452">		return retData[0];</span>
	}

	/**
	 * Vrati domenu pre zadane groupId
	 * @param groupId
	 * @return
	 */
	public String getDomain(int groupId)
	{
<span class="pc bpc" id="L1462" title="1 of 2 branches missed.">		if (InitServlet.isTypeCloud())</span>
		{
<span class="nc" id="L1464">			GroupDetails group = getGroup(groupId);</span>
<span class="nc bnc" id="L1465" title="All 4 branches missed.">			if (group != null &amp;&amp; Tools.isNotEmpty(group.getDomainName())) return group.getDomainName();</span>
		}

<span class="fc" id="L1468">		return(getDomain(groups, groupId));</span>
	}

	/**
	 * Vrati domenu pre zadane groupId a zadany list
	 * @param allGroups
	 * @param groupId
	 * @return
	 */
	public static String getDomain(List&lt;GroupDetails&gt; allGroups, int groupId)
	{
<span class="fc" id="L1479">		String[] retData = getURLPathDomainGroup(allGroups, groupId);</span>
<span class="fc" id="L1480">		return retData[1];</span>
	}

	public static String[] getURLPathDomainGroup(List&lt;GroupDetails&gt; allGroups, int groupId)
	{
<span class="fc" id="L1485">		Map&lt;Integer, GroupDetails&gt; table = new Hashtable&lt;&gt;();</span>
<span class="fc bfc" id="L1486" title="All 2 branches covered.">		for (GroupDetails group : allGroups)</span>
		{
<span class="fc" id="L1488">			table.put(group.getGroupId(), group);</span>
<span class="fc" id="L1489">		}</span>

<span class="fc" id="L1491">		return getURLPathDomainGroup(table, groupId);</span>
	}

	/**
	 * Vrati pole stringov, kde ret[0]=URL cesta k adresaru a ret[1]=nazov domeny root adresara
	 * @param allGroups
	 * @param groupId
	 * @return
	 */
	public static String[] getURLPathDomainGroup(Map&lt;Integer, GroupDetails&gt; allGroups, int groupId)
	{
<span class="fc" id="L1502">		String[] retData = new String[2];</span>

<span class="fc" id="L1504">		StringBuilder path = new StringBuilder();</span>
<span class="fc" id="L1505">		boolean finished = false;</span>
<span class="fc" id="L1506">		int currentGroupId = groupId;</span>
<span class="fc" id="L1507">		int depth = 0;</span>
<span class="fc" id="L1508">		int max_depth = 30;</span>
		GroupDetails group;

<span class="fc" id="L1511">		String domain = null;</span>
		//pouzije sa ak je nastavene multiDomainEnableNested
<span class="fc" id="L1513">		String domainOnFirstGroup = null;</span>

<span class="fc bfc" id="L1515" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L1517">			group = allGroups.get(Integer.valueOf(currentGroupId));</span>

<span class="fc bfc" id="L1519" title="All 2 branches covered.">			if (group==null)</span>
			{
<span class="fc" id="L1521">				retData[0] = &quot;--------------------------&quot;;</span>
<span class="fc" id="L1522">				retData[1] = &quot;&quot;;</span>
<span class="fc" id="L1523">				return(retData);</span>
			}
			else
			{
<span class="fc bfc" id="L1527" title="All 4 branches covered.">				if (domainOnFirstGroup == null &amp;&amp; Tools.isNotEmpty(group.getDomainName()))</span>
				{
<span class="fc" id="L1529">					domainOnFirstGroup = group.getDomainName();</span>
<span class="fc" id="L1530">					domain = domainOnFirstGroup;</span>
				}

				//Logger.println(this,&quot;group=&quot;+group.getGroupId()+&quot; p=&quot;+group.getParentGroupId()+&quot; n=&quot;+group.getNavbarName());

<span class="fc bfc" id="L1535" title="All 2 branches covered.">				if (group.getUrlDirName().startsWith(&quot;/&quot;))</span>
				{
					//ak sa adresaru nastavi cesta zacinajuca / tak sa zrusi predchadzajuca URL cesta
<span class="fc" id="L1538">					path.insert(0, group.getUrlDirName());</span>
<span class="fc" id="L1539">					finished = true;</span>
				}
<span class="fc bfc" id="L1541" title="All 2 branches covered.">				else if(&quot;-&quot;.equals(group.getUrlDirName())==false)</span>
				{
<span class="fc" id="L1543">					path.insert(0, &quot;/&quot; + group.getUrlDirName());</span>
				}
<span class="fc" id="L1545">				currentGroupId = group.getParentGroupId();</span>
			}


			//Logger.println(this,&quot;path=&quot;+path);

<span class="fc" id="L1551">			depth++;</span>
<span class="fc bfc" id="L1552" title="All 2 branches covered.">			if (depth &gt; max_depth)</span>
			{
<span class="fc" id="L1554">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L1557" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L1559">				finished = true;</span>
<span class="pc bpc" id="L1560" title="1 of 2 branches missed.">				if (group != null) domain = group.getDomainName();</span>
			}
		}

		//ak sme skoncili iteraciu predcasne
<span class="pc bpc" id="L1565" title="3 of 4 branches missed.">		while (domain == null &amp;&amp; depth++ &lt; max_depth)</span>
		{
<span class="nc" id="L1567">			group = allGroups.get(Integer.valueOf(currentGroupId));</span>
<span class="nc bnc" id="L1568" title="All 2 branches missed.">			if (group == null)</span>
			{
<span class="nc" id="L1570">				domain = &quot;&quot;;</span>
<span class="nc" id="L1571">				break;</span>
			}
			else
			{
<span class="nc" id="L1575">				currentGroupId = group.getParentGroupId();</span>

<span class="nc bnc" id="L1577" title="All 2 branches missed.">				if (currentGroupId == 0)</span>
				{
<span class="nc" id="L1579">					domain = group.getDomainName();</span>
				}
			}
		}

<span class="pc bpc" id="L1584" title="1 of 2 branches missed.">		if (domain == null) domain=&quot;&quot;;</span>

<span class="pc bpc" id="L1586" title="1 of 2 branches missed.">		if (Constants.getBoolean(&quot;multiDomainEnableNested&quot;)) domain = domainOnFirstGroup;</span>

<span class="fc" id="L1588">		retData[0] = Tools.replace(path.toString(), &quot;//&quot;, &quot;/&quot;);</span>
<span class="fc" id="L1589">		retData[1] = domain;</span>
<span class="fc" id="L1590">		return(retData);</span>
	}

	/**
	 * Vrati cestu k adresaru s pouzitim NavbarName (napr. /Slovensky/O Nás/Kontakt)
	 * @param groupId
	 * @return
	 */
	public String getNavbarPath(int groupId)
	{
<span class="nc" id="L1600">		StringBuilder path = new StringBuilder();</span>
<span class="nc" id="L1601">		boolean finished = false;</span>
<span class="nc" id="L1602">		int currentGroupId = groupId;</span>
<span class="nc" id="L1603">		int depth = 0;</span>
<span class="nc" id="L1604">		int max_depth = 30;</span>
		GroupDetails group;

<span class="nc bnc" id="L1607" title="All 2 branches missed.">		while (finished == false)</span>
		{
<span class="nc" id="L1609">			group = findGroup(currentGroupId);</span>


<span class="nc bnc" id="L1612" title="All 2 branches missed.">			if (group==null)</span>
			{
<span class="nc" id="L1614">				return(&quot;--------------------------&quot;);</span>
			}
			else
			{
<span class="nc bnc" id="L1618" title="All 2 branches missed.">				if (&quot;-&quot;.equals(group.getUrlDirName())==false)</span>
				{
<span class="nc" id="L1620">					path.insert(0, &quot;/&quot; + group.getNavbarName());</span>
				}
<span class="nc" id="L1622">				currentGroupId = group.getParentGroupId();</span>
			}


			//Logger.println(this,&quot;path=&quot;+path);

<span class="nc" id="L1628">			depth++;</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L1631">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L1634" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L1636">				finished = true;</span>
			}
		}

<span class="nc" id="L1640">		return (path.toString());</span>
	}

	/**
	 * Vrati cestu k adresaru s pouzitim Title (napr. /Slovensky/O Nás/Kontakt)
	 * @param groupId
	 * @return
	 */
	public String getGroupNamePath(int groupId)
	{
<span class="fc" id="L1650">		StringBuilder path = new StringBuilder();</span>
<span class="fc" id="L1651">		boolean finished = false;</span>
<span class="fc" id="L1652">		int currentGroupId = groupId;</span>
<span class="fc" id="L1653">		int depth = 0;</span>
<span class="fc" id="L1654">		int max_depth = 30;</span>
		GroupDetails group;

<span class="fc bfc" id="L1657" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L1659">			group = findGroup(currentGroupId);</span>

<span class="fc bfc" id="L1661" title="All 2 branches covered.">			if (group==null)</span>
			{
<span class="fc" id="L1663">				return(&quot;--------------------------&quot;);</span>
			}
			else
			{
<span class="fc" id="L1667">				path.insert(0, &quot;/&quot; + group.getGroupName());</span>
<span class="fc" id="L1668">				currentGroupId = group.getParentGroupId();</span>
			}

			//Logger.println(this,&quot;path=&quot;+path);

<span class="fc" id="L1673">			depth++;</span>
<span class="pc bpc" id="L1674" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L1676">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L1679" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L1681">				finished = true;</span>
			}
		}

<span class="fc" id="L1685">		return (path.toString());</span>
	}

	/**
	 *  vrati navigacnu listu (podobne ako cestu) len je to iwcm &gt; Produkty
	 *
	 *@param  groupId  Description of the Parameter
	 *@return          The navbar value
	 */
	public String getNavbar(int groupId)
	{
<span class="fc" id="L1696">		return(getNavbar(groupId, -99, null));</span>
	}

	/**
	 * Vrati navigacnu listup, pre zadane docId (aktualne) nezrenderuje odkaz
	 * @param groupId
	 * @param docId
	 * @param session
	 * @return
	 */
	public String getNavbar(int groupId, int docId, HttpSession session)
	{
<span class="fc" id="L1708">		StringBuilder path = new StringBuilder();</span>
<span class="fc" id="L1709">		boolean finished = false;</span>
<span class="fc" id="L1710">		int currentGroupId = groupId;</span>
<span class="fc" id="L1711">		int depth = 0;</span>
<span class="fc" id="L1712">		int max_depth = 30;</span>
		GroupDetails group;
<span class="pc bpc" id="L1714" title="1 of 4 branches missed.">		while (finished == false &amp;&amp; depth++&lt;max_depth)</span>
		{
<span class="fc" id="L1716">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L1717" title="1 of 4 branches missed.">			if (group != null &amp;&amp; group.getGroupId()!=group.getParentGroupId())</span>
			{
<span class="fc bfc" id="L1719" title="All 4 branches covered.">				if (group.isInternal()==true || group.getMenuType(session)==GroupDetails.MENU_TYPE_HIDDEN)</span>
				{
<span class="fc" id="L1721">					currentGroupId = group.getParentGroupId();</span>
<span class="fc" id="L1722">					continue;</span>
				}

<span class="pc bpc" id="L1725" title="2 of 4 branches missed.">				if (group.getNavbar().length() &gt; 1 &amp;&amp; &quot;&amp;nbsp;&quot;.equals(group.getNavbarName())==false)</span>
				{
<span class="pc bpc" id="L1727" title="3 of 4 branches missed.">					if (Constants.getBoolean(&quot;navbarRenderAllLinks&quot;)==false &amp;&amp; group.getDefaultDocId()==docId)</span>
					{
<span class="nc" id="L1729">						String newPath = &quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot; + group.getNavbarName().replaceAll(&quot;(?i)&lt;aparam.*&gt;&quot;,&quot;&quot;);</span>
						//ochrana pred duplikovanim cesty (ak mame root a v nom mame hlavnu stranku v podadresari s rovnakym nazvom)
<span class="nc bnc" id="L1731" title="All 2 branches missed.">						if (path.indexOf(newPath)!=0) path.insert(0, newPath);</span>
<span class="nc" id="L1732">					}</span>
					else
					{
<span class="fc" id="L1735">						String navbarName = group.getNavbar();</span>
<span class="pc bpc" id="L1736" title="1 of 2 branches missed.">						if (navbarName.contains(&quot;*||&quot;)) navbarName = Tools.replace(navbarName, &quot;*||&quot;, &quot;&lt;/&quot;);</span>
<span class="pc bpc" id="L1737" title="1 of 2 branches missed.">						if (navbarName.contains(&quot;*|&quot;)) navbarName = Tools.replace(navbarName, &quot;*|&quot;, &quot;&lt;&quot;);</span>
<span class="pc bpc" id="L1738" title="1 of 2 branches missed.">						if (navbarName.contains(&quot;|*&quot;)) navbarName = Tools.replace(navbarName, &quot;|*&quot;, &quot;&gt;&quot;);</span>
<span class="fc" id="L1739">						String newPath = &quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot; + navbarName;</span>
<span class="pc bpc" id="L1740" title="1 of 2 branches missed.">						if (path.indexOf(newPath)!=0) path.insert(0, newPath);</span>
					}
				}
<span class="fc" id="L1743">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="fc" id="L1748">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L1751" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L1753">				finished = true;</span>
			}
		}
		try
		{
			//odstran zobak na zaciatku
<span class="pc bpc" id="L1759" title="1 of 2 branches missed.">			if (path.indexOf(&quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot;)==0)</span>
			{
<span class="fc" id="L1761">				return path.toString().substring(Constants.getString(&quot;navbarSeparator&quot;).length() + 2).trim();</span>
			}
		}
<span class="nc" id="L1764">		catch (Exception ex)</span>
		{
<span class="nc" id="L1766">		}</span>
<span class="nc" id="L1767">		return (path.toString());</span>
	}
	/**
	 * Vrati HTML kod pre Breadcrumb navigaciu vo formate schema.org
	 * @param groupId - ID adresara
	 * @param docId - ID aktualnej web stranky
	 * @param session
	 * @return
	 */
	public String getNavbarSchema(int groupId, int docId, HttpSession session)
	{
<span class="nc" id="L1778">		StringBuilder htmlCode = new StringBuilder();</span>
<span class="nc" id="L1779">		DocDB docDB = DocDB.getInstance();</span>

<span class="nc" id="L1781">		boolean finished = false;</span>
<span class="nc" id="L1782">		int currentGroupId = groupId;</span>
<span class="nc" id="L1783">		int depth = 0;</span>
<span class="nc" id="L1784">		int max_depth = 30;</span>
		GroupDetails group;
<span class="nc" id="L1786">		int realMaxDepth = 1;</span>

		// potrebujem zistit realny pocet urovni
<span class="nc bnc" id="L1789" title="All 4 branches missed.">		while (finished == false &amp;&amp; depth++&lt;max_depth)</span>
		{
<span class="nc" id="L1791">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L1792" title="All 4 branches missed.">			if (group != null &amp;&amp; group.getGroupId()!=group.getParentGroupId())</span>
			{
<span class="nc bnc" id="L1794" title="All 4 branches missed.">				if (group.isInternal()==true || group.getMenuType(session)==GroupDetails.MENU_TYPE_HIDDEN)</span>
				{
<span class="nc" id="L1796">					currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1797">					continue;</span>
				}

<span class="nc" id="L1800">				Map&lt;String, String&gt; aparams = parseAparam(group.getNavbarName());</span>
<span class="nc bnc" id="L1801" title="All 8 branches missed.">				if (group.getDefaultDocId() &gt; 0 &amp;&amp; (!aparams.containsKey(&quot;class&quot;) || aparams.containsKey(&quot;class&quot;) &amp;&amp; !aparams.get(&quot;class&quot;).equalsIgnoreCase(&quot;is-headline&quot;))) {</span>
<span class="nc" id="L1802">					realMaxDepth++;</span>
				}
<span class="nc" id="L1804">				currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1805">			}</span>
			else
			{
				//group doesn't exist
<span class="nc" id="L1809">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L1812" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L1814">				finished = true;</span>
			}
		}

<span class="nc" id="L1818">		depth = 0;</span>
<span class="nc" id="L1819">		currentGroupId = groupId;</span>
<span class="nc" id="L1820">		finished = false;</span>
<span class="nc" id="L1821">		int skippedCount = 0;</span>

<span class="nc bnc" id="L1823" title="All 4 branches missed.">		while (finished == false &amp;&amp; depth++&lt;max_depth)</span>
		{
<span class="nc" id="L1825">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L1826" title="All 4 branches missed.">			if (group != null &amp;&amp; group.getGroupId()!=group.getParentGroupId())</span>
			{
<span class="nc bnc" id="L1828" title="All 4 branches missed.">				if (group.isInternal()==true || group.getMenuType(session)==GroupDetails.MENU_TYPE_HIDDEN)</span>
				{
<span class="nc" id="L1830">					currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1831">					skippedCount++;</span>
<span class="nc" id="L1832">					continue;</span>
				}

<span class="nc" id="L1835">				String groupNavbar = Tools.convertToHtmlTags(group.getNavbarName());</span>

<span class="nc" id="L1837">				Map&lt;String, String&gt; aparams = parseAparam(groupNavbar);</span>
<span class="nc bnc" id="L1838" title="All 6 branches missed.">				if (group.getDefaultDocId() &lt; 1 || aparams.containsKey(&quot;class&quot;) &amp;&amp; aparams.get(&quot;class&quot;).equalsIgnoreCase(&quot;is-headline&quot;)) {</span>
<span class="nc" id="L1839">					currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1840">					skippedCount++;</span>
<span class="nc" id="L1841">					continue;</span>
				}

<span class="nc bnc" id="L1844" title="All 8 branches missed.">				if (group.getDefaultDocId() &gt; 0 &amp;&amp; groupNavbar.length() &gt; 1 &amp;&amp; (groupNavbar.indexOf(&quot;&lt;a&quot;) &lt; 0 || groupNavbar.toLowerCase().indexOf(&quot;&lt;aparam&quot;) &gt;= 0))</span>
				{
					//odstrani &lt;aparam&gt;
<span class="nc" id="L1847">					String text = groupNavbar.replaceAll(&quot;(?i)&lt;aparam.*&gt;&quot;, &quot;&quot;);</span>
<span class="nc" id="L1848">					groupNavbar = &quot;\n\t&lt;li class=\&quot;is-item\&quot; itemprop=\&quot;itemListElement\&quot; itemscope itemtype=\&quot;http://schema.org/ListItem\&quot;&gt;&quot; +</span>
<span class="nc" id="L1849">							&quot;&lt;a href='&quot; + docDB.getDocLink(group.getDefaultDocId()) + &quot;' class='navbar' itemprop=\&quot;item\&quot;&gt;&quot; +</span>
<span class="nc" id="L1850">							&quot;&lt;span itemprop=\&quot;name\&quot;&gt;&quot; + Tools.convertToHtmlTags(text) + &quot;&lt;/span&gt;&quot; +</span>
							&quot;&lt;/a&gt;&quot; +
							&quot;&lt;meta itemprop=\&quot;position\&quot; content=\&quot;&quot; + (realMaxDepth - depth + skippedCount) + &quot;\&quot; /&gt;&lt;/li&gt;&quot;;
				}

<span class="nc bnc" id="L1855" title="All 4 branches missed.">				if (groupNavbar.length() &gt; 1 &amp;&amp; &quot;&amp;nbsp;&quot;.equals(group.getNavbarName())==false)</span>
				{
<span class="nc bnc" id="L1857" title="All 4 branches missed.">					if (Constants.getBoolean(&quot;navbarRenderAllLinks&quot;)==false &amp;&amp; group.getDefaultDocId()==docId)</span>
					{
<span class="nc" id="L1859">						String text = group.getNavbarName().replaceAll(&quot;(?i)&lt;aparam.*&gt;&quot;, &quot;&quot;);</span>
<span class="nc" id="L1860">						String newPath = Tools.convertToHtmlTags(text);</span>

						//ochrana pred duplikovanim cesty (ak mame root a v nom mame hlavnu stranku v podadresari s rovnakym nazvom)
<span class="nc bnc" id="L1863" title="All 2 branches missed.">						if (htmlCode.indexOf(newPath)!=0) htmlCode.insert(0, newPath);</span>
<span class="nc" id="L1864">					}</span>
					else
					{
						//tu nepotrebujeme nahradu, tu uz len pridavame moznosti dokopy
<span class="nc" id="L1868">						String newPath = groupNavbar;</span>

<span class="nc bnc" id="L1870" title="All 2 branches missed.">						if (htmlCode.indexOf(newPath)!=0) htmlCode.insert(0, newPath);</span>
					}
				}
<span class="nc" id="L1873">				currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1874">			}</span>
			else
			{
				//group doesn't exist
<span class="nc" id="L1878">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L1881" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L1883">				finished = true;</span>
			}
		}
		try
		{
			//odstran zobak na zaciatku
<span class="nc bnc" id="L1889" title="All 2 branches missed.">			if (htmlCode.indexOf(&quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot;)==0)</span>
			{
<span class="nc" id="L1891">				htmlCode = new StringBuilder(htmlCode.toString().substring(Constants.getString(&quot;navbarSeparator&quot;).length() + 2).trim());</span>
			}
		}
<span class="nc" id="L1894">		catch (Exception ex)</span>
		{
<span class="nc" id="L1896">		}</span>

<span class="nc" id="L1898">		htmlCode.insert(0, &quot;\n&lt;ol itemscope itemtype=\&quot;http://schema.org/BreadcrumbList\&quot;&gt;&quot;);</span>
<span class="nc" id="L1899">		htmlCode.append(&quot;\n&lt;/ol&gt;&quot;);</span>
<span class="nc" id="L1900">		return (htmlCode.toString());</span>
	}

	protected Map&lt;String, String&gt; parseAparam(String str) {
<span class="nc bnc" id="L1904" title="All 2 branches missed.">		if (!str.contains(&quot;&lt;aparam&quot;)) {</span>
<span class="nc" id="L1905">			return Collections.emptyMap();</span>
		}

		try {
<span class="nc" id="L1909">			String string = str.substring(str.indexOf(&quot;&lt;aparam&quot;), str.length());</span>
<span class="nc" id="L1910">			string = string.substring(0, string.indexOf(&quot;&gt;&quot;) - 1);</span>
<span class="nc" id="L1911">			string = string.substring(7, string.length()).trim();</span>

<span class="nc" id="L1913">			String[] arr = Tools.getTokens(string, &quot;&quot;);</span>
<span class="nc" id="L1914">			Map&lt;String, String&gt; result = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L1916" title="All 2 branches missed.">			for (String item : arr) {</span>
<span class="nc" id="L1917">				String[] items = Tools.getTokens(item, &quot;=&quot;);</span>
<span class="nc bnc" id="L1918" title="All 2 branches missed.">				String value = items[1] != null ? Tools.replace(items[1], &quot;\&quot;&quot;, &quot;&quot;) : &quot;&quot;;</span>
<span class="nc" id="L1919">				result.put(items[0], value);</span>
			}

<span class="nc" id="L1922">			return result;</span>
		}
<span class="nc" id="L1924">		catch (Exception ex) {</span>
<span class="nc" id="L1925">			sk.iway.iwcm.Logger.error(ex);</span>
<span class="nc" id="L1926">			return Collections.emptyMap();</span>
		}
	}

	/**
	 * Vrati HTML kod pre Breadcrumb navigaciu vo formate RDF
	 * http://support.google.com/webmasters/bin/answer.py?hl=en&amp;topic=1088474&amp;hlrm=en&amp;answer=185417&amp;ctx=topic
	 * @param groupId - ID adresara
	 * @param docId - ID aktualnej web stranky
	 * @param session
	 * @return
	 */
	public String getNavbarRDF(int groupId, int docId, HttpSession session)
	{
<span class="nc" id="L1940">		StringBuilder htmlCode = new StringBuilder();</span>
<span class="nc" id="L1941">		DocDB docDB = DocDB.getInstance();</span>

<span class="nc" id="L1943">		boolean finished = false;</span>
<span class="nc" id="L1944">		int currentGroupId = groupId;</span>
<span class="nc" id="L1945">		int depth = 0;</span>
<span class="nc" id="L1946">		int max_depth = 30;</span>
		GroupDetails group;
<span class="nc bnc" id="L1948" title="All 4 branches missed.">		while (finished == false &amp;&amp; depth++&lt;max_depth)</span>
		{
<span class="nc" id="L1950">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L1951" title="All 4 branches missed.">			if (group != null &amp;&amp; group.getGroupId()!=group.getParentGroupId())</span>
			{
<span class="nc bnc" id="L1953" title="All 4 branches missed.">				if (group.isInternal()==true || group.getMenuType(session)==GroupDetails.MENU_TYPE_HIDDEN)</span>
				{
<span class="nc" id="L1955">					currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1956">					continue;</span>
				}

<span class="nc" id="L1959">				String groupNavbar = group.getNavbarName();</span>
<span class="nc bnc" id="L1960" title="All 8 branches missed.">				if (group.getDefaultDocId() &gt; 0 &amp;&amp; groupNavbar.length() &gt; 1 &amp;&amp; (groupNavbar.indexOf(&quot;&lt;a&quot;) &lt; 0 || groupNavbar.toLowerCase().indexOf(&quot;&lt;aparam&quot;) &gt;= 0))</span>
				{
					//odstrani &lt;aparam&gt;
<span class="nc" id="L1963">					String text = groupNavbar.replaceAll(&quot;(?i)&lt;aparam.*&gt;&quot;,&quot;&quot;);</span>
<span class="nc" id="L1964">					groupNavbar = &quot;&lt;span typeof=\&quot;v:Breadcrumb\&quot;&gt;&lt;a href='&quot;+docDB.getDocLink(group.getDefaultDocId())+&quot;' class='navbar' rel=\&quot;v:url\&quot; property=\&quot;v:title\&quot;&gt;&quot; + text + &quot;&lt;/a&gt;&lt;/span&gt;&quot;;</span>
				}

<span class="nc bnc" id="L1967" title="All 4 branches missed.">				if (groupNavbar.length() &gt; 1 &amp;&amp; &quot;&amp;nbsp;&quot;.equals(group.getNavbarName())==false)</span>
				{
<span class="nc bnc" id="L1969" title="All 4 branches missed.">					if (Constants.getBoolean(&quot;navbarRenderAllLinks&quot;)==false &amp;&amp; group.getDefaultDocId()==docId)</span>
					{
<span class="nc" id="L1971">						String newPath = &quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot; + group.getNavbarName().replaceAll(&quot;(?i)&lt;aparam.*&gt;&quot;,&quot;&quot;);</span>
						//ochrana pred duplikovanim cesty (ak mame root a v nom mame hlavnu stranku v podadresari s rovnakym nazvom)
<span class="nc bnc" id="L1973" title="All 2 branches missed.">						if (htmlCode.indexOf(newPath)!=0) htmlCode.insert(0, newPath);</span>
<span class="nc" id="L1974">					}</span>
					else
					{
<span class="nc" id="L1977">						String newPath = &quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot; + groupNavbar;</span>
<span class="nc bnc" id="L1978" title="All 2 branches missed.">						if (htmlCode.indexOf(newPath)!=0) htmlCode.insert(0, newPath);</span>
					}
				}
<span class="nc" id="L1981">				currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1982">			}</span>
			else
			{
				//group doesn't exist
<span class="nc" id="L1986">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L1989" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L1991">				finished = true;</span>
			}
		}
		try
		{
			//odstran zobak na zaciatku
<span class="nc bnc" id="L1997" title="All 2 branches missed.">			if (htmlCode.indexOf(&quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot;)==0)</span>
			{
<span class="nc" id="L1999">				htmlCode = new StringBuilder(htmlCode.toString().substring(Constants.getString(&quot;navbarSeparator&quot;).length() + 2).trim());</span>
			}
		}
<span class="nc" id="L2002">		catch (Exception ex)</span>
		{
<span class="nc" id="L2004">		}</span>

<span class="nc" id="L2006">		htmlCode.insert(0, &quot;&lt;div class=\&quot;breadcrumbrdf\&quot; xmlns:v=\&quot;http://rdf.data-vocabulary.org/#\&quot;&gt;&quot;);</span>
<span class="nc" id="L2007">		htmlCode.append(&quot;&lt;/div&gt;&quot;);</span>
<span class="nc" id="L2008">		return (htmlCode.toString());</span>
	}


	/**
	 *  to iste ako getNavbar, len do ciest nedava linky (&lt;a href...)
	 *
	 *@param  groupId  Description of the Parameter
	 *@return          The navbarNoHref value
	 */
	public String getNavbarNoHref(int groupId)
	{
<span class="fc" id="L2020">		StringBuilder path = new StringBuilder();</span>
<span class="fc" id="L2021">		boolean finished = false;</span>
<span class="fc" id="L2022">		int currentGroupId = groupId;</span>
<span class="fc" id="L2023">		int depth = 0;</span>
<span class="fc" id="L2024">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc bfc" id="L2026" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L2028">			group = findGroup(currentGroupId);</span>
<span class="fc bfc" id="L2029" title="All 2 branches covered.">			if (group != null)</span>
			{
<span class="pc bpc" id="L2031" title="1 of 2 branches missed.">				if (group.getNavbar().length() &gt; 1)</span>
				{
<span class="fc" id="L2033">					path.insert(0, &quot; &gt; &quot; + group.getNavbarName());</span>
				}
<span class="fc" id="L2035">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="fc" id="L2040">				finished = true;</span>
			}
<span class="fc" id="L2042">			depth++;</span>
<span class="pc bpc" id="L2043" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2045">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L2048" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L2050">				finished = true;</span>
			}
		}
		try
		{
			//odstran zobak na zaciatku
<span class="fc bfc" id="L2056" title="All 2 branches covered.">			if (path.indexOf(&quot; &gt; &quot;)==0)</span>
			{
<span class="fc" id="L2058">				path = new StringBuilder(path.toString().substring(3).trim());</span>
			}
		}
<span class="nc" id="L2061">		catch (Exception ex)</span>
		{
<span class="fc" id="L2063">		}</span>

<span class="fc" id="L2065">		path = Tools.replace(path, &quot;href=&quot;, &quot;hrf=&quot;);</span>

<span class="fc" id="L2067">		return (path.toString());</span>
	}

	/**
	 *  vrati zoznam parent groups (pre pristupove prava)
	 *
	 *@param  groupId  Description of the Parameter
	 *@return          The parents value
	 */
	public String getParents(int groupId)
	{
<span class="fc" id="L2078">		StringBuilder path = new StringBuilder(&quot;&quot;);</span>
<span class="fc" id="L2079">		boolean finished = false;</span>
<span class="fc" id="L2080">		int currentGroupId = groupId;</span>
<span class="fc" id="L2081">		int depth = 0;</span>
<span class="fc" id="L2082">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc bfc" id="L2084" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L2086">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L2087" title="1 of 2 branches missed.">			if (group != null)</span>
			{
<span class="fc" id="L2089">				path.insert(0, group.getGroupId()).insert(0, &quot;,&quot;);</span>
<span class="fc" id="L2090">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L2095">				finished = true;</span>
			}
<span class="fc" id="L2097">			depth++;</span>
<span class="pc bpc" id="L2098" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2100">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L2103" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L2105">				finished = true;</span>
			}
		}
		try
		{
			//odstran zobak na zaciatku
<span class="pc bpc" id="L2111" title="1 of 2 branches missed.">			if (path.toString().startsWith(&quot;,&quot;))</span>
			{
<span class="fc" id="L2113">				path.deleteCharAt(0);</span>
			}
		}
<span class="nc" id="L2116">		catch (Exception ex)</span>
		{
<span class="fc" id="L2118">		}</span>
<span class="fc" id="L2119">		return (path.toString());</span>
	}

	/**
	 * Vrati htmlHead atribut, hlada ho aj v nadradenych adresaroch
	 * @param groupId
	 * @return
	 */
	public String getHtmlHeadRecursive(int groupId)
	{
<span class="fc" id="L2129">		String htmlHead = null;</span>
<span class="fc" id="L2130">		boolean finished = false;</span>
<span class="fc" id="L2131">		int currentGroupId = groupId;</span>
<span class="fc" id="L2132">		int depth = 0;</span>
<span class="fc" id="L2133">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc bfc" id="L2135" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L2137">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L2138" title="1 of 2 branches missed.">			if (group != null)</span>
			{
<span class="pc bpc" id="L2140" title="2 of 4 branches missed.">				if (group.getHtmlHead()!=null &amp;&amp; group.getHtmlHead().length() &gt; 1)</span>
				{
<span class="nc" id="L2142">					htmlHead = group.getHtmlHead();</span>
<span class="nc" id="L2143">					finished = true;</span>
				}
<span class="fc" id="L2145">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L2150">				finished = true;</span>
			}
<span class="fc" id="L2152">			depth++;</span>
<span class="pc bpc" id="L2153" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2155">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L2158" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L2160">				finished = true;</span>
			}
		}
<span class="pc bpc" id="L2163" title="1 of 2 branches missed.">		if (htmlHead==null)</span>
		{
<span class="fc" id="L2165">			htmlHead = &quot;&quot;;</span>
		}
<span class="fc" id="L2167">		return (htmlHead);</span>
	}

	/**
	 * Rekurzivne vrati akukolvek property pre zadany adresar
	 * @param groupId
	 * @param propertyName
	 * @return
	 */
	public String getPropertyRecursive(int groupId, String propertyName)
	{
<span class="fc" id="L2178">		boolean finished = false;</span>
<span class="fc" id="L2179">		int currentGroupId = groupId;</span>
<span class="fc" id="L2180">		int depth = 0;</span>
<span class="fc" id="L2181">		int max_depth = 30;</span>
		GroupDetails group;
		String value;
<span class="fc bfc" id="L2184" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L2186">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L2187" title="1 of 2 branches missed.">			if (group != null)</span>
			{
				try
				{
<span class="fc" id="L2191">					Object o = BeanUtils.getProperty(group, propertyName);</span>
					//Logger.debug(GroupsDB.class, &quot;o=&quot;+o.getClass());
<span class="fc" id="L2193">					value = (String)o;</span>
					//Logger.debug(GroupsDB.class, &quot;value=&quot;+value);
<span class="pc bpc" id="L2195" title="1 of 4 branches missed.">					if (Tools.isNotEmpty(value) &amp;&amp; &quot;0&quot;.equals(value)==false)</span>
					{
<span class="fc" id="L2197">						return(value);</span>
					}
				}
<span class="nc" id="L2200">				catch (Exception ex)</span>
				{
<span class="nc" id="L2202">					sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L2203">				}</span>
<span class="fc" id="L2204">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L2209">				finished = true;</span>
			}
<span class="fc" id="L2211">			depth++;</span>
<span class="pc bpc" id="L2212" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2214">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L2217" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L2219">				finished = true;</span>
			}
		}
<span class="fc" id="L2222">		return (&quot;&quot;);</span>
	}

	/**
	 * Rekurzivne vrati id adresara v ktorom zadana property nadobuda hladanu hodnotu
	 * @param groupId
	 * @param propertyName
	 * @param propertyValue
	 * @return
	 */
	public int getGroupIdByPropertyValue(int groupId, String propertyName, String propertyValue)
	{
<span class="nc" id="L2234">		boolean finished = false;</span>
<span class="nc" id="L2235">		int currentGroupId = groupId;</span>
<span class="nc" id="L2236">		int depth = 0;</span>
<span class="nc" id="L2237">		int max_depth = 30;</span>
		GroupDetails group;
		String value;
<span class="nc bnc" id="L2240" title="All 2 branches missed.">		while (finished == false)</span>
		{
<span class="nc" id="L2242">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L2243" title="All 2 branches missed.">			if (group != null)</span>
			{
				try
				{
<span class="nc" id="L2247">					Object o = BeanUtils.getProperty(group, propertyName);</span>
<span class="nc" id="L2248">					Logger.debug(GroupsDB.class, &quot;o=&quot;+o.getClass());</span>
<span class="nc" id="L2249">					value = (String)o;</span>
<span class="nc" id="L2250">					Logger.debug(GroupsDB.class, &quot;value=&quot;+value);</span>
<span class="nc bnc" id="L2251" title="All 6 branches missed.">					if (Tools.isNotEmpty(value) &amp;&amp; &quot;0&quot;.equals(value)==false &amp;&amp; propertyValue.indexOf(value) != -1)</span>
					{
<span class="nc" id="L2253">						return(currentGroupId);</span>
					}
				}
<span class="nc" id="L2256">				catch (Exception ex)</span>
				{
<span class="nc" id="L2258">					sk.iway.iwcm.Logger.error(ex);</span>
<span class="nc" id="L2259">				}</span>
<span class="nc" id="L2260">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L2265">				finished = true;</span>
			}
<span class="nc" id="L2267">			depth++;</span>
<span class="nc bnc" id="L2268" title="All 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2270">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L2273" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L2275">				finished = true;</span>
			}
		}
<span class="nc" id="L2278">		return -1;</span>
	}

	/**
	 * Rekurzivne ziska docid prihlasovacieho dialogu
	 * @param groupId
	 * @return
	 */
	public int getRecursiveLogonPageDocId(int groupId)
	{
<span class="fc" id="L2288">		int logonPageDocId = -1;</span>
<span class="fc" id="L2289">		boolean finished = false;</span>
<span class="fc" id="L2290">		int currentGroupId = groupId;</span>
<span class="fc" id="L2291">		int depth = 0;</span>
<span class="fc" id="L2292">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc bfc" id="L2294" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L2296">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L2297" title="1 of 2 branches missed.">			if (group != null)</span>
			{
<span class="fc bfc" id="L2299" title="All 2 branches covered.">				if (group.getLogonPageDocId() &gt; 0)</span>
				{
					//Logger.println(this,&quot;logonPageDocId=&quot;+logonPageDocId+&quot; gid=&quot;+group.getGroupId());
<span class="fc" id="L2302">					logonPageDocId = group.getLogonPageDocId();</span>
<span class="fc" id="L2303">					finished = true;</span>
				}
<span class="fc" id="L2305">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L2310">				finished = true;</span>
			}
<span class="fc" id="L2312">			depth++;</span>
<span class="pc bpc" id="L2313" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2315">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L2318" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L2320">				finished = true;</span>
			}
		}
<span class="fc" id="L2323">		return (logonPageDocId);</span>
	}

	/**
	 * vrati rootGrupu pre zadane groupId (pouziva sa koli jazykovym mutaciam)
	 * @param groupId
	 * @return
	 */
	public int getRoot(int groupId)
	{
<span class="nc" id="L2333">		int root = groupId;</span>
<span class="nc" id="L2334">		boolean finished = false;</span>
<span class="nc" id="L2335">		int currentGroupId = groupId;</span>
<span class="nc" id="L2336">		int depth = 0;</span>
<span class="nc" id="L2337">		int max_depth = 30;</span>
		GroupDetails group;
<span class="nc bnc" id="L2339" title="All 2 branches missed.">		while (finished == false)</span>
		{
<span class="nc" id="L2341">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L2342" title="All 2 branches missed.">			if (group != null)</span>
			{
<span class="nc bnc" id="L2344" title="All 2 branches missed.">				if (group.getNavbar().length() &gt; 1)</span>
				{
<span class="nc" id="L2346">					root = group.getGroupId();</span>
				}
<span class="nc" id="L2348">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L2353">				finished = true;</span>
			}
<span class="nc" id="L2355">			depth++;</span>
<span class="nc bnc" id="L2356" title="All 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2358">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L2361" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L2363">				finished = true;</span>
			}
		}
<span class="nc" id="L2366">		return (root);</span>
	}


	/**
	 *  Vrati List zo zoznamom rodicovskych skupin (cesta k root adresaru)
	 *  VYNECHA tie, ktore maju prazdnu hodnotu v poli navbar
	 *
	 *@param  groupId  Description of the Parameter
	 *@return          The parentGroups value
	 */
	public List&lt;GroupDetails&gt; getParentGroups(int groupId) {
<span class="fc" id="L2378">		return getParentGroups(groupId, false);</span>
	}

	/**
	 * Vrati zoznam rodicovskych adresarov (vratane zadaneho groupId)
	 * @param groupId
	 * @param includeWithEmptyNavbar - ak je false pridaju sa do zoznamu len adresare, ktore naju neprazdne pole navbar
	 * @return
	 */
	public List&lt;GroupDetails&gt; getParentGroups(int groupId, boolean includeWithEmptyNavbar)
	{
<span class="fc" id="L2389">		boolean finished = false;</span>
<span class="fc" id="L2390">		int currentGroupId = groupId;</span>
<span class="fc" id="L2391">		int depth = 0;</span>
<span class="fc" id="L2392">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc" id="L2394">		List&lt;GroupDetails&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2395" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L2397">			group = findGroup(currentGroupId);</span>
<span class="fc bfc" id="L2398" title="All 2 branches covered.">			if (group != null)</span>
			{
<span class="pc bpc" id="L2400" title="1 of 4 branches missed.">				if (includeWithEmptyNavbar || group.getNavbar().length() &gt; 1)</span>
				{
					//path = path + &quot;,&quot; + group.getGroupId();
<span class="fc" id="L2403">					ret.add(group);</span>
				}
<span class="fc" id="L2405">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="fc" id="L2410">				finished = true;</span>
			}
<span class="fc" id="L2412">			depth++;</span>
<span class="pc bpc" id="L2413" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2415">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L2418" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L2420">				finished = true;</span>
			}
		}

<span class="fc" id="L2424">		return (ret);</span>
	}

	/**
	 *  vrati nacitane skupiny, je to tu takto ako ArrayList kvoli legacy JSP kodu
	 *
	 *@return    The groups value
	 *@deprecated - pouzivajte verziu getGroupsAll
	 */
	@Deprecated
	public List&lt;GroupDetails&gt; getGroups()
	{
<span class="nc" id="L2436">		List&lt;GroupDetails&gt; arlist = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2437">		arlist.addAll(groups);</span>
<span class="nc" id="L2438">		return arlist;</span>
	}

	/**
	 * Vrati vsetky nacitane skupiny
	 * @return
	 */
	public List&lt;GroupDetails&gt; getGroupsAll()
	{
<span class="fc" id="L2447">		return groups;</span>
	}

	/**
	 *  skontroluje ci uz neexistuje skupina s danym menom v danej skupine
	 *
	 *@param  parentId  id rodica skupiny
	 *@param  name       meno novej skupiny
	 *@return            true ak uz existuje, false inak
	 */
	public boolean checkExist(int parentId, String name)
	{
<span class="fc bfc" id="L2459" title="All 2 branches covered.">		for (GroupDetails group : getGroupsAll())</span>
		{
<span class="fc bfc" id="L2461" title="All 4 branches covered.">			if (group.getParentGroupId() == parentId &amp;&amp; group.getGroupName().compareToIgnoreCase(name) == 0)</span>
			{
<span class="fc" id="L2463">				return (true);</span>
			}
<span class="fc" id="L2465">		}</span>
<span class="fc" id="L2466">		return (false);</span>
	}

	/**
	 *  skontroluje ci uz existuje skupina s danym menom v danej skupine a vrati
	 *  jej id (ak existuje)
	 *
	 *@param  name             meno novej skupiny
	 *@param  parent_group_id  Description of the Parameter
	 *@return                  id skupiny ak existuje, -1 inak
	 */
	public int checkExist2(int parent_group_id, String name)
	{
<span class="nc bnc" id="L2479" title="All 2 branches missed.">		for (GroupDetails group : getGroupsAll())</span>
		{
<span class="nc bnc" id="L2481" title="All 4 branches missed.">			if (group.getParentGroupId() == parent_group_id &amp;&amp; group.getGroupName().compareToIgnoreCase(name) == 0)</span>
			{
<span class="nc" id="L2483">				return group.getGroupId();</span>
			}
<span class="nc" id="L2485">		}</span>
<span class="nc" id="L2486">		return -1;</span>
	}

	/**
	 * Vrati String s rekurzivny zoznamom groupId, ktore mame zadane ako origPerexGroup. Pouziva sa v JSP
	 * strankach pri volani DocDB.getDocPerex()
	 * @param origGroupIds
	 * @return
	 */
	public static String getRecursiveGroupsSqlIn(String origGroupIds)
	{
		//ziskaj rekurzivne stranky
<span class="nc" id="L2498">		StringTokenizer st = new StringTokenizer(origGroupIds, &quot;,&quot;);</span>
		int groupId;
		List&lt;GroupDetails&gt; childs;
<span class="nc" id="L2501">		GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="nc" id="L2502">		StringBuilder groupIds = null;</span>
<span class="nc bnc" id="L2503" title="All 2 branches missed.">		while (st.hasMoreTokens())</span>
		{
			try
			{
<span class="nc" id="L2507">				groupId = Integer.parseInt(st.nextToken());</span>
<span class="nc" id="L2508">				childs = groupsDB.getGroupsTree(groupId, true, false);</span>
<span class="nc bnc" id="L2509" title="All 2 branches missed.">				for (GroupDetails group : childs)</span>
				{
<span class="nc bnc" id="L2511" title="All 2 branches missed.">					if (groupIds == null)</span>
					{
<span class="nc" id="L2513">						groupIds = new StringBuilder(String.valueOf(group.getGroupId()));</span>
					}
					else
					{
<span class="nc" id="L2517">						groupIds.append(&quot;,&quot;).append(String.valueOf(group.getGroupId()));</span>
					}
<span class="nc" id="L2519">				}</span>
			}
<span class="nc" id="L2521">			catch (Exception ex)</span>
			{
<span class="nc" id="L2523">				sk.iway.iwcm.Logger.error(ex);</span>
<span class="nc" id="L2524">			}</span>
		}
<span class="nc bnc" id="L2526" title="All 2 branches missed.">		if (groupIds==null) return null;</span>
<span class="nc" id="L2527">		return(groupIds.toString());</span>
	}

	/**
	 * Vrati grupu podla fullPath (ak je zadane) alebo podla syncId (ak nenajde podla fullPath)
	 * @param fullPath - hodnota fullPath na remote serveri (alebo null, ak chceme hladat len podla syncId)
	 * @param syncId - hodnota groupId na remote serveri
	 * @return
	 */
	public GroupDetails getGroupBySync(String fullPath, int syncId)
	{

<span class="nc bnc" id="L2539" title="All 2 branches missed.">		if (Tools.isNotEmpty(fullPath))</span>
		{
<span class="nc bnc" id="L2541" title="All 2 branches missed.">			for (GroupDetails group : groups)</span>
			{
<span class="nc bnc" id="L2543" title="All 2 branches missed.">				if (group.getFullPath().equalsIgnoreCase(fullPath))</span>
				{
<span class="nc" id="L2545">					return(group);</span>
				}
<span class="nc" id="L2547">			}</span>
		}

<span class="nc bnc" id="L2550" title="All 2 branches missed.">		if (syncId == 0) return(null);</span>

<span class="nc bnc" id="L2552" title="All 2 branches missed.">		for (GroupDetails group : groups)</span>
		{
<span class="nc bnc" id="L2554" title="All 2 branches missed.">			if (group.getSyncId() == syncId)</span>
			{
<span class="nc" id="L2556">				return(group);</span>
			}
<span class="nc" id="L2558">		}</span>
<span class="nc" id="L2559">		return (null);</span>
	}

	/**
	 * Vrati/vytvori skupinu podla zadanej cesty
	 * @param path - cesta vo formate /adresar1/adresar2
	 * @return
	 */
	public GroupDetails getCreateGroup(String path)
	{
		//check if path is number, then get GroupDetails by ID
		try {
<span class="nc" id="L2571">			int groupId = Integer.parseInt(path);</span>
<span class="nc" id="L2572">			return(getGroup(groupId));</span>
<span class="fc" id="L2573">		} catch(Exception ex) {</span>
			//not a number, continue
		}

<span class="fc" id="L2577">		int domainSeparatorIndex = path.indexOf(&quot;:&quot;);</span>
<span class="pc bpc" id="L2578" title="1 of 2 branches missed.">		if (domainSeparatorIndex&gt;0) {</span>
<span class="nc" id="L2579">			String domain = path.substring(0, domainSeparatorIndex);</span>
<span class="nc" id="L2580">			RequestBean rb = SetCharacterEncodingFilter.getCurrentRequestBean();</span>
<span class="nc bnc" id="L2581" title="All 2 branches missed.">			if (rb != null) {</span>
<span class="nc" id="L2582">				rb.setDomain(domain);</span>
			}
<span class="nc" id="L2584">			path = path.substring(domainSeparatorIndex+1);</span>
		}

<span class="pc bpc" id="L2587" title="1 of 2 branches missed.">		if (path.contains(&quot;/&quot;)==false) {</span>
<span class="nc" id="L2588">			return null;</span>
		}

<span class="fc" id="L2591">		int actualParent = 0;</span>
<span class="pc bpc" id="L2592" title="1 of 2 branches missed.">		if(InitServlet.isTypeCloud())</span>
		{
			//ak sa jedna napr. o /System/Kos tak sa nastavi parent na ID hlavneho adresara namiesto na 0 (globalny System folder)
<span class="nc bnc" id="L2595" title="All 2 branches missed.">			if (path.startsWith(&quot;/&quot;+CloudToolsForCore.getDomainName())==false)	actualParent = CloudToolsForCore.getDomainId();</span>
		}
<span class="pc bpc" id="L2597" title="1 of 4 branches missed.">		else if (Constants.getBoolean(&quot;templatesUseDomainLocalSystemFolder&quot;)==true &amp;&amp; path.startsWith(&quot;/System/&quot;))</span>
		{
			//overenie lokalneho /System/Kos adresara
<span class="fc" id="L2600">			Prop propSystem = Prop.getInstance(Constants.getString(&quot;defaultLanguage&quot;));</span>
<span class="fc" id="L2601">			String trashDirName = propSystem.getText(&quot;config.trash_dir&quot;);</span>
<span class="pc bpc" id="L2602" title="1 of 2 branches missed.">			if (path.equals(trashDirName))</span>
			{
<span class="fc" id="L2604">				GroupDetails localSystemGroup = getLocalSystemGroup();</span>
				//pre pripad ze je /System priecinok niekde v subdomene, napr. /English/System/ zaciname hladat v /English priecinku (povazujeme ho za root)
<span class="pc bpc" id="L2606" title="1 of 4 branches missed.">				if (localSystemGroup != null &amp;&amp; localSystemGroup.getParentGroupId()&gt;0) actualParent = localSystemGroup.getParentGroupId();</span>
			}
		}

<span class="fc" id="L2610">		RequestBean rb = SetCharacterEncodingFilter.getCurrentRequestBean();</span>
		String actualGroupName;
<span class="fc" id="L2612">		StringTokenizer st = new StringTokenizer(path, &quot;/&quot;);</span>
		GroupDetails actualGroup;
<span class="fc" id="L2614">		GroupDetails parentGroup = null;</span>
<span class="pc bpc" id="L2615" title="1 of 2 branches missed.">		while (st.hasMoreTokens())</span>
		{
<span class="fc" id="L2617">			actualGroupName = st.nextToken();</span>

			//ak by boli za sebou nahodou //
<span class="pc bpc" id="L2620" title="1 of 2 branches missed.">			if (Tools.isEmpty(actualGroupName)) continue;</span>

<span class="pc bpc" id="L2622" title="1 of 6 branches missed.">			if (&quot;System&quot;.equals(actualGroupName) &amp;&amp; actualParent==0 &amp;&amp; Constants.getBoolean(&quot;templatesUseDomainLocalSystemFolder&quot;)) actualGroup = getLocalSystemGroup();</span>
<span class="fc" id="L2623">            else actualGroup = getGroup(actualGroupName, actualParent);</span>

<span class="fc bfc" id="L2625" title="All 2 branches covered.">			if (actualGroup == null)</span>
			{
<span class="fc" id="L2627">				actualGroup = new GroupDetails();</span>
				//vytvor skupinu, nastav prava podla parenta
<span class="pc bpc" id="L2629" title="1 of 2 branches missed.">				if (parentGroup != null)</span>
				{
					try
					{
<span class="fc" id="L2633">						BeanUtils.copyProperties(actualGroup, parentGroup);</span>
					}
<span class="nc" id="L2635">					catch (Exception ex)</span>
					{
<span class="nc" id="L2637">						sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L2638">					}</span>
<span class="fc" id="L2639">					actualGroup.setParentGroupId(parentGroup.getGroupId());</span>
<span class="fc" id="L2640">					actualGroup.setSyncId(0);</span>
				} else {
<span class="nc bnc" id="L2642" title="All 6 branches missed.">					if (rb != null &amp;&amp; Tools.isNotEmpty(rb.getDomain()) &amp;&amp; Constants.getBoolean(&quot;multiDomainEnabled&quot;)==true) {</span>
						//nastav domenu
<span class="nc" id="L2644">						actualGroup.setDomainName(rb.getDomain());</span>
					}
				}

<span class="fc" id="L2648">				actualGroup.setGroupId(-1);</span>
<span class="fc" id="L2649">				actualGroup.setDefaultDocId(-1);</span>
<span class="fc" id="L2650">				actualGroup.setGroupName(actualGroupName);</span>
<span class="fc" id="L2651">				actualGroup.setNavbar(actualGroupName);</span>
<span class="fc" id="L2652">				actualGroup.setUrlDirName(actualGroupName);</span>

<span class="fc" id="L2654">				actualGroup.setSortPriority(getDefaultSortPriority(actualGroup.getParentGroupId()));</span>

<span class="fc" id="L2656">				setGroup(actualGroup);</span>
			}

<span class="fc bfc" id="L2659" title="All 2 branches covered.">			if (st.hasMoreTokens()==false)</span>
			{
				//sme na konci
<span class="fc" id="L2662">				return(actualGroup);</span>
			}

<span class="fc" id="L2665">			actualParent = actualGroup.getGroupId();</span>
<span class="fc" id="L2666">			parentGroup = actualGroup;</span>
		}
<span class="nc" id="L2668">		return(null);</span>
	}

	/**
	 * Ziska docId sablony novej stranky pre zadany adresar (zvycajne vrati -1 = prazdna stranka)
	 * @param groupId
	 * @return
	 */
	public static int getNewPageDocIdTemplate(int groupId)
	{
<span class="nc" id="L2678">		GroupsDB groupsDB = GroupsDB.getInstance();</span>

<span class="nc" id="L2680">		int newPageDocIdTemplate = Constants.getInt(&quot;newDocumentId&quot;);</span>
<span class="nc" id="L2681">		int groupNewPageDocIdTemplate = Tools.getIntValue(groupsDB.getPropertyRecursive(groupId, &quot;newPageDocIdTemplate&quot;), 0);</span>
<span class="nc bnc" id="L2682" title="All 2 branches missed.">		if (groupNewPageDocIdTemplate!=0)</span>
		{
<span class="nc bnc" id="L2684" title="All 2 branches missed.">			if (groupNewPageDocIdTemplate == -1)</span>
			{
				//prehladaj podla nazvu sablony
<span class="nc" id="L2687">				GroupDetails actualGroup = groupsDB.getGroup(groupId);</span>
<span class="nc" id="L2688">				int tempId = actualGroup.getTempId();</span>
<span class="nc" id="L2689">				TemplateDetails temp = TemplatesDB.getInstance().getTemplate(tempId);</span>
<span class="nc" id="L2690">				DocDB docDB = DocDB.getInstance();</span>
<span class="nc" id="L2691">				List&lt;DocDetails&gt; temps = docDB.getDocByGroup(Constants.getInt(&quot;tempGroupId&quot;));</span>
<span class="nc bnc" id="L2692" title="All 4 branches missed.">				if (temps!=null &amp;&amp; temp!=null)</span>
				{
<span class="nc" id="L2694">					String tempName = DB.internationalToEnglish(temp.getTempName());</span>
<span class="nc bnc" id="L2695" title="All 2 branches missed.">					for (DocDetails doc : temps)</span>
					{
<span class="nc bnc" id="L2697" title="All 2 branches missed.">						if (DB.internationalToEnglish(doc.getTitle()).equalsIgnoreCase(tempName))</span>
						{
<span class="nc" id="L2699">							newPageDocIdTemplate = -doc.getDocId();</span>
<span class="nc" id="L2700">							break;</span>
						}
<span class="nc" id="L2702">					}</span>
				}
<span class="nc" id="L2704">			}</span>
			else
			{
<span class="nc" id="L2707">				newPageDocIdTemplate = -groupNewPageDocIdTemplate;</span>
			}
		}
<span class="nc" id="L2710">		return(newPageDocIdTemplate);</span>
	}

	/**
	 * Vymazanie adresara
	 * @param groupId - id adresara
	 * @param request - request (treba kvoli admin logu, ale moze byt aj null)
	 * @return
	 */
	public static boolean deleteGroup(int groupId, HttpServletRequest request)
	{
<span class="fc" id="L2721">		return deleteGroup(groupId, request, true, false);</span>
	}
	/**
	 * Vymazanie adresara
	 * @param groupId - id adresara
	 * @param request - request (treba kvoli admin logu, ale moze byt aj null)
	 * @param includeParent - urci, ci ma pri vymazani brat aj rodicovsky adresar
	 * @param permanentlyDelete - nevlozi do kosa, ale priamo vymaze
	 * @return
	 */
	public static boolean deleteGroup(int groupId, HttpServletRequest request, boolean includeParent, boolean permanentlyDelete)
	{
<span class="fc" id="L2733">		return deleteGroup(groupId, includeParent, permanentlyDelete, true);</span>
	}

	private static void deleteGroupsApprove(String groups) {
<span class="fc" id="L2737">		(new SimpleQuery()).execute(&quot;DELETE FROM groups_approve WHERE group_id IN (&quot;+groups+&quot;)&quot;);</span>
<span class="fc" id="L2738">	}</span>

	/**
	 * Vymazanie adresara
	 * @param groupId - id adresara
	 * @param request - request (treba kvoli admin logu, ale moze byt aj null)
	 * @param includeParent - urci, ci ma pri vymazani brat aj rodicovsky adresar
	 * @param permanentlyDelete - nevlozi do kosa, ale priamo vymaze
	 * @param publishEvents - ak je true, su vyvolane udalosti (false potrebne ak napr. reagujeme na udalost a potrebujeme znova upravit adresar a nechceme aby doslo k zacykleniu)
	 * @return
	 */
	public static boolean deleteGroup(int groupId, boolean includeParent, boolean permanentlyDelete, boolean publishEvents)
	{
<span class="fc" id="L2751">		Connection db_conn = null;</span>
<span class="fc" id="L2752">		PreparedStatement ps = null;</span>
<span class="fc" id="L2753">		GroupsDB groupsDB = GroupsDB.getInstance();</span>

		//kontrola prav
<span class="fc" id="L2756">		GroupDetails group = groupsDB.getGroup(groupId);</span>

<span class="pc bpc" id="L2758" title="1 of 2 branches missed.">		if (InitServlet.isTypeCloud())</span>
		{
<span class="nc bnc" id="L2760" title="All 4 branches missed.">			if (group == null || group.getDomainName().equals(CloudToolsForCore.getDomainName())==false)</span>
			{
<span class="nc" id="L2762">				return false;</span>
			}
		}

		try
		{
<span class="pc bpc" id="L2768" title="1 of 4 branches missed.">			if (group!=null &amp;&amp; publishEvents) {</span>
<span class="fc" id="L2769">				(new WebjetEvent&lt;GroupDetails&gt;(group, WebjetEventType.ON_DELETE)).publishEvent();</span>
			}

			//	zmazanie grupy
<span class="fc" id="L2773">			db_conn = DBPool.getConnection();</span>

			// zisti ci sme v adresari /System/Trash (kos), ak nie presun, inak vymaz
<span class="fc" id="L2776">			Logger.debug(GroupsDB.class, &quot;MAZEM: &quot; + group);</span>

<span class="fc" id="L2778">			boolean foundSystemDir = false;</span>
<span class="fc" id="L2779">			GroupDetails trashGroupDetails = null;</span>
<span class="fc" id="L2780">			boolean disableHistory = Constants.getBoolean(&quot;editorDisableHistory&quot;);</span>
<span class="pc bpc" id="L2781" title="1 of 2 branches missed.">			if (disableHistory == false)  {</span>
<span class="fc" id="L2782">				trashGroupDetails = groupsDB.getTrashGroup();</span>
			}

<span class="pc bpc" id="L2785" title="3 of 8 branches missed.">			if (permanentlyDelete || trashGroupDetails == null || trashGroupDetails.getGroupId()==groupId || groupsDB.isInTrash(groupId))</span>
			{
      			// ziskaj zoznam groups (tejto a podskupin)
<span class="fc" id="L2788">				StringBuilder groups = new StringBuilder();</span>
				//List subGroups = groupsDB.getGroups(my_form.getGroupId());
<span class="fc" id="L2790">				List&lt;GroupDetails&gt; subGroups = groupsDB.getGroupsTree(groupId, includeParent, true);</span>

<span class="fc bfc" id="L2792" title="All 2 branches covered.">				for (GroupDetails element : subGroups)</span>
				{
<span class="fc bfc" id="L2794" title="All 2 branches covered.">					if (groups.length() &gt; 0)</span>
<span class="fc" id="L2795">						groups.append(',');</span>
<span class="fc" id="L2796">					groups.append(element.getGroupId());</span>
					//refresh cache
<span class="fc" id="L2798">					groupsDB.removeGroupFromCache(element, false);</span>

<span class="pc bpc" id="L2800" title="2 of 4 branches missed.">					if(foundSystemDir == false &amp;&amp; &quot;System&quot;.equalsIgnoreCase(element.getGroupName())) foundSystemDir = true;</span>
<span class="fc" id="L2801">				}</span>

<span class="pc bpc" id="L2803" title="1 of 2 branches missed.">				if(Tools.isNotEmpty(groups))	//ak nezaratam rodicovsky adresa, moze byt groups prazdne v pripade, ak rodicovsky adresar nemal ziadne podadresare</span>
				{
					//vymaz stranky
<span class="fc" id="L2806">					String sql = &quot;DELETE FROM documents WHERE group_id IN (&quot;+groups+&quot;)&quot;;</span>
<span class="fc" id="L2807">					ps = db_conn.prepareStatement(sql);</span>
<span class="fc" id="L2808">					ps.executeUpdate();</span>
<span class="fc" id="L2809">					ps.close();</span>
<span class="fc" id="L2810">					ps = null;</span>

					//vymaz adresare
<span class="fc" id="L2813">					sql = &quot;DELETE FROM groups WHERE group_id IN (&quot;+groups+&quot;)&quot;;</span>
<span class="fc" id="L2814">					ps = db_conn.prepareStatement(sql);</span>
<span class="fc" id="L2815">					ps.executeUpdate();</span>
<span class="fc" id="L2816">					ps.close();</span>
<span class="fc" id="L2817">					ps = null;</span>

					//Vymaz approve
<span class="fc" id="L2820">					deleteGroupsApprove(groups.toString());</span>
				}

<span class="fc" id="L2823">				Adminlog.add(Adminlog.TYPE_GROUP, &quot;Delete group: &quot; + group, groupId, -1);</span>
<span class="fc" id="L2824">			}</span>
			else
			{
      		// presun adresar do trashu
<span class="fc" id="L2828">				String sql = &quot;UPDATE groups SET parent_group_id=?, sync_status=1 WHERE group_id=?&quot;;</span>
<span class="fc" id="L2829">				ps = db_conn.prepareStatement(sql);</span>
<span class="fc" id="L2830">				ps.setInt(1, trashGroupDetails.getGroupId());</span>
<span class="fc" id="L2831">				ps.setInt(2, groupId);</span>
<span class="fc" id="L2832">				ps.executeUpdate();</span>
<span class="fc" id="L2833">				ps.close();</span>
<span class="fc" id="L2834">				ps = null;</span>

<span class="fc" id="L2836">				Adminlog.add(Adminlog.TYPE_GROUP, &quot;Delete group (move to trash): &quot; + group, groupId, -1);</span>

				//refresh cache
<span class="fc" id="L2839">				groupsDB.findGroup(groupId).setParentGroupId( trashGroupDetails.getGroupId() );</span>

				//deaktivuj vsetky stranky v tejto skupine a podskupinach
<span class="fc" id="L2842">				StringBuilder groups = new StringBuilder();</span>
<span class="fc" id="L2843">				List&lt;GroupDetails&gt; subGroups = groupsDB.getGroupsTree(groupId, true, true);</span>

<span class="fc bfc" id="L2845" title="All 2 branches covered.">				for (GroupDetails g : subGroups)</span>
				{
<span class="fc" id="L2847">					g.setFullPath(groupsDB.getPath(g.getGroupId()));</span>

<span class="fc bfc" id="L2849" title="All 2 branches covered.">					if (groups.length() &gt; 0)</span>
<span class="fc" id="L2850">						groups.append(',').append(g.getGroupId());</span>
					else
<span class="fc" id="L2852">						groups.append(g.getGroupId());</span>

<span class="pc bpc" id="L2854" title="2 of 4 branches missed.">					if(foundSystemDir == false &amp;&amp; &quot;System&quot;.equalsIgnoreCase(g.getGroupName())) foundSystemDir = true;</span>
<span class="fc" id="L2855">				}</span>
				// zakaz zobrazovanie stranok
<span class="fc" id="L2857">				sql = &quot;UPDATE documents SET available=?, sync_status=1 WHERE group_id IN (&quot;+groups.toString()+&quot;)&quot;;</span>
<span class="fc" id="L2858">				ps = db_conn.prepareStatement(sql);</span>
<span class="fc" id="L2859">				ps.setBoolean(1, false);</span>
<span class="fc" id="L2860">				ps.executeUpdate();</span>
<span class="fc" id="L2861">				ps.close();</span>
<span class="fc" id="L2862">				ps = null;</span>

				//aktualizuj FT stplce
<span class="fc" id="L2865">				DocDB.updateFileNameField(groupId);</span>
      		}

      		//ak sa jedna o system adresar, refreshnem zoznam tychto stranok
<span class="pc bpc" id="L2869" title="1 of 2 branches missed.">			if(foundSystemDir) groupsDB.getAllSystemFolders(true);</span>

<span class="fc" id="L2871">			db_conn.close();</span>
<span class="fc" id="L2872">			db_conn = null;</span>
			//oznam ostatnym Node-om, ze sa nieco zmenilo
<span class="fc" id="L2874">			ClusterDB.addRefresh(GroupsDB.class);</span>
<span class="fc" id="L2875">			ClusterDB.addRefresh(DocDB.class);</span>
<span class="fc" id="L2876">			GroupsDB.getInstance(true);</span>
<span class="fc" id="L2877">			DocDB.getInstance(true);</span>

<span class="pc bpc" id="L2879" title="1 of 4 branches missed.">			if (group!=null &amp;&amp; publishEvents) (new WebjetEvent&lt;GroupDetails&gt;(group, WebjetEventType.AFTER_DELETE)).publishEvent();</span>

<span class="fc" id="L2881">			return(true);</span>
		}
<span class="nc" id="L2883">		catch (Exception ex)</span>
		{
<span class="nc" id="L2885">			sk.iway.iwcm.Logger.error(ex);</span>
		}
		finally
		{
			try
			{
<span class="pc bpc" id="L2891" title="1 of 2 branches missed.">				if (ps != null)</span>
<span class="nc" id="L2892">					ps.close();</span>
<span class="pc bpc" id="L2893" title="1 of 2 branches missed.">				if (db_conn != null)</span>
<span class="nc" id="L2894">					db_conn.close();</span>
			}
<span class="nc" id="L2896">			catch (Exception ex2)</span>
			{
<span class="fc" id="L2898">			}</span>
		}
<span class="nc" id="L2900">		return(false);</span>
	}

	/**
	 * Vrati TreeMap so zoznamom = retazec id adresarov oddelenych ciarkami pridelenych ku skupine obsiahnutej v hodnote kluca
	 * @return
	 */
	public static Map&lt;Integer, String&gt; getProtectedGroups()
	{
<span class="nc" id="L2909">		GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="nc" id="L2910">		List&lt;GroupDetails&gt; groups = groupsDB.getGroupsAll();</span>
<span class="nc" id="L2911">		TreeMap&lt;Integer, String&gt; tm = new TreeMap&lt;&gt;();</span>
<span class="nc bnc" id="L2912" title="All 2 branches missed.">		for (GroupDetails groupDetails : groups)</span>
		{
<span class="nc bnc" id="L2914" title="All 2 branches missed.">			if(Tools.isNotEmpty(groupDetails.getPasswordProtected()))</span>
			{
<span class="nc bnc" id="L2916" title="All 2 branches missed.">				if(groupDetails.getPasswordProtected().indexOf(',') &lt; 0)</span>
				{
<span class="nc bnc" id="L2918" title="All 2 branches missed.">					if(tm.containsKey(Integer.valueOf(groupDetails.getPasswordProtected())))</span>
					{
<span class="nc" id="L2920">						String tmp = tm.get(Integer.valueOf(groupDetails.getPasswordProtected()));</span>
<span class="nc" id="L2921">						tm.put(Integer.valueOf(groupDetails.getPasswordProtected()), tmp.concat(groupDetails.getGroupId()+&quot;,&quot;));</span>

<span class="nc" id="L2923">					}else{</span>
<span class="nc" id="L2924">						tm.put(Integer.valueOf(groupDetails.getPasswordProtected()), groupDetails.getGroupId()+&quot;,&quot;);</span>
					}
				}else{
<span class="nc" id="L2927">					String[] tmp = groupDetails.getPasswordProtected().split(&quot;,&quot;);</span>
<span class="nc bnc" id="L2928" title="All 2 branches missed.">					for (int i = 0; i &lt; tmp.length; i++)</span>
					{
<span class="nc bnc" id="L2930" title="All 2 branches missed.">						if(tm.containsKey(Integer.valueOf(tmp[i])))</span>
						{
<span class="nc" id="L2932">							String tmp2 = tm.get(Integer.valueOf(tmp[i]));</span>
<span class="nc" id="L2933">							tm.put(Integer.valueOf(tmp[i]), tmp2.concat(groupDetails.getGroupId()+&quot;,&quot;));</span>

<span class="nc" id="L2935">						}else{</span>
<span class="nc" id="L2936">							tm.put(Integer.valueOf(tmp[i]), groupDetails.getGroupId()+&quot;,&quot;);</span>
						}
					}
				}
			}
<span class="nc" id="L2941">		}</span>
		/*
		for (Iterator iterator = tm.entrySet().iterator(); iterator.hasNext();)
		{
			Map.Entry&lt;Integer, String&gt; key = (Map.Entry&lt;Integer, String&gt;)iterator.next();
			System.out.println(&quot;&gt;&gt; KEY: &quot;+key.getKey()+&quot; &gt; VALUE: &quot;+key.getValue());
		}
		*/
<span class="nc" id="L2949">		return tm;</span>
	}

	/**
	 * Vrati zoznam ID podadresarov zadaneho adresara (vratane)
	 * napr 1,5,77,28
	 * @param groupId
	 * @return
	 */
	public String getSubgroupsIds(int groupId)
	{
<span class="fc" id="L2960">		List&lt;GroupDetails&gt; subGroups = getGroupsTree(groupId, false, true);</span>
<span class="fc" id="L2961">		StringBuilder groupIds = new StringBuilder().append(groupId);</span>
<span class="fc bfc" id="L2962" title="All 2 branches covered.">		for (GroupDetails grp : subGroups)</span>
		{
<span class="fc" id="L2964">			groupIds.append(',').append(grp.getGroupId());</span>
<span class="fc" id="L2965">		}</span>

<span class="fc" id="L2967">		return groupIds.toString();</span>
	}

	/**
	 * Vrati zoznam ID adresarov so zadanou domenou (pouzitelne pre IN select)
	 * @param domainName
	 * @return
	 */
	public String getSubgroupsIds(String domainName)
	{
<span class="pc bpc" id="L2977" title="1 of 2 branches missed.">		if (Tools.isEmpty(domainName)) domainName = &quot;&quot;;</span>

<span class="fc" id="L2979">		StringBuilder groupIds = new StringBuilder(&quot;-1&quot;);</span>
<span class="fc bfc" id="L2980" title="All 2 branches covered.">		for (GroupDetails grp : groups)</span>
		{
<span class="fc bfc" id="L2982" title="All 2 branches covered.">			if (domainName.equals(grp.getDomainName()))</span>
			{
<span class="fc" id="L2984">				groupIds.append(',').append(grp.getGroupId());</span>
			}
<span class="fc" id="L2986">		}</span>

<span class="pc bpc" id="L2988" title="1 of 2 branches missed.">		if (Tools.isEmpty(groupIds.toString())) return &quot;-1&quot;;</span>

<span class="fc" id="L2990">		return groupIds.toString();</span>
	}

	/**
	 * expanduje zadany zoznam skupin na podadresare (vratane rodica), neprejde cez interne adresare
	 * @param rootGroups
	 * @return
	 */
	public int[] expandGroupIdsToChilds(int[] rootGroups)
	{
<span class="fc" id="L3000">		return expandGroupIdsToChilds(rootGroups, false);</span>
	}

	/**
	 * expanduje zadany zoznam skupin na podadresare (vratane rodica)
	 * @param rootGroups
	 * @param includeInternal
	 * @return
	 */
	public int[] expandGroupIdsToChilds(int[] rootGroups, boolean includeInternal)
	{
<span class="pc bpc" id="L3011" title="1 of 4 branches missed.">		if (rootGroups == null || rootGroups.length==0) return new int[0];</span>

<span class="fc" id="L3013">		StringBuilder searchGroups = null;</span>
<span class="fc bfc" id="L3014" title="All 2 branches covered.">		for (int searchRootGroupId : rootGroups)</span>
		{
<span class="fc" id="L3016">			List&lt;GroupDetails&gt; searchGroupsArray = getGroupsTree(searchRootGroupId, true, true);</span>
<span class="fc bfc" id="L3017" title="All 2 branches covered.">			for (GroupDetails group : searchGroupsArray)</span>
			{
<span class="pc bpc" id="L3019" title="1 of 6 branches missed.">				if (group != null &amp;&amp; (includeInternal || group.isInternal()==false))</span>
				{
					//hladaj iba v grupach co nie su pass protected
<span class="fc bfc" id="L3022" title="All 2 branches covered.">					if (searchGroups == null)</span>
					{
<span class="fc" id="L3024">						searchGroups = new StringBuilder(String.valueOf(group.getGroupId()));</span>
					}
					else
					{
<span class="fc" id="L3028">						searchGroups.append(&quot;,&quot;).append(String.valueOf(group.getGroupId()));</span>
					}
				}
<span class="fc" id="L3031">			}</span>
		}

<span class="fc bfc" id="L3034" title="All 2 branches covered.">		if (searchGroups == null) return new int[0];</span>

<span class="fc" id="L3036">		return Tools.getTokensInt(searchGroups.toString(), &quot;,&quot;);</span>
	}

	/**
	 * Vypocita hodnotu sortPriority pre novy adresar v zadanom sub adresari
	 * @param parentGroupId
	 * @return
	 */
	public int getDefaultSortPriority(int parentGroupId)
	{
<span class="pc bpc" id="L3046" title="3 of 4 branches missed.">		if (parentGroupId &lt; 1 &amp;&amp; Constants.getBoolean(&quot;enableStaticFilesExternalDir&quot;))</span>
		{
			//pre multidomain s externymi vraciame pre root natvrdo 100 aby sa sortovali podla abecedy
<span class="nc" id="L3049">			return 100;</span>
		}

<span class="fc" id="L3052">		int maxSortOrder = 0;</span>
<span class="pc bpc" id="L3053" title="1 of 2 branches missed.">		if (Constants.getBoolean(&quot;sortPriorityIncremental&quot;))</span>
		{
<span class="fc" id="L3055">			GroupDetails parentGroup = getGroup(parentGroupId);</span>
<span class="pc bpc" id="L3056" title="1 of 2 branches missed.">			if (parentGroup!=null)</span>
			{
<span class="fc" id="L3058">				maxSortOrder = (int)Math.ceil(parentGroup.getSortPriority()/10.0f) * 100;</span>
			}
		}

<span class="fc bfc" id="L3062" title="All 2 branches covered.">		for (GroupDetails grp : getGroups(parentGroupId))</span>
		{
<span class="fc bfc" id="L3064" title="All 2 branches covered.">			if (grp.getSortPriority() &gt; maxSortOrder) maxSortOrder = grp.getSortPriority();</span>
<span class="fc" id="L3065">		}</span>
<span class="fc" id="L3066">		return maxSortOrder + Constants.getInt(&quot;sortPriorityIncrementGroup&quot;);</span>
	}

	/**
	 * Removes a group from current cache
	 *
	 * @param group group, which will be erased from cache
	 */
	private void removeGroupFromCache(GroupDetails group, boolean isUpdateProcess)
	{
		try
		{
<span class="fc" id="L3078">			synchronized(groups)</span>
			{
<span class="pc bpc" id="L3080" title="1 of 2 branches missed.">				if (groups.remove(group)==false)</span>
				{
<span class="nc" id="L3082">					int index = Collections.binarySearch(groups, group, groupsDbSorter);</span>
<span class="nc bnc" id="L3083" title="All 2 branches missed.">					if (index &gt; 0)</span>
<span class="nc" id="L3084">						groups.remove(index);</span>
					else
					{
						//zmenilo sa jej sort priority - nemozeme vyhladat binarne, musime sekvencne
<span class="nc" id="L3088">						group = getGroup(group.getGroupId());</span>
<span class="nc" id="L3089">						index = groups.indexOf(group);</span>
<span class="nc" id="L3090">						groups.remove(index);</span>
					}
				}
<span class="fc" id="L3093">			}</span>
<span class="fc" id="L3094">			getGroupDetailsMap().remove(group.getGroupId());</span>

			//zresetuj all tree cache
<span class="fc" id="L3097">			groupsTreeAllCache = null;</span>

<span class="fc" id="L3099">			idToGroups.remove(group.getGroupId());</span>

<span class="pc bpc" id="L3101" title="2 of 6 branches missed.">			if(Tools.isNotEmpty(group.getDomainName()) &amp;&amp; group.getParentGroupId() == 0 &amp;&amp; isUpdateProcess==false)</span>
			{
				//najdi najnizsie groupId v tejto domene (domainId je najnizsie groupId v domene)
<span class="nc" id="L3104">				int lowestGroupId = group.getGroupId();</span>
<span class="nc bnc" id="L3105" title="All 2 branches missed.">				for (GroupDetails domainGroup : groups) {</span>
<span class="nc bnc" id="L3106" title="All 4 branches missed.">					if (domainGroup.getParentGroupId()==0 &amp;&amp; group.getDomainName().equals(domainGroup.getDomainName())) {</span>
<span class="nc bnc" id="L3107" title="All 2 branches missed.">						if (domainGroup.getGroupId()&lt;lowestGroupId) lowestGroupId = domainGroup.getGroupId();</span>
					}
<span class="nc" id="L3109">				}</span>
				//ak mazana grupa je s najnizsim groupId, zmazme aj so zoznamu domen
<span class="nc bnc" id="L3111" title="All 2 branches missed.">				if (lowestGroupId==group.getGroupId()) {</span>
<span class="nc" id="L3112">					domainIds.remove(group.getDomainName());</span>
					//musime aj tak spravit reload, lebo hladame teraz nove domainId
<span class="nc" id="L3114">					GroupsDB.getInstance(true);</span>
				}
			}
		}
<span class="nc" id="L3118">		catch (ConcurrentModificationException|ArrayIndexOutOfBoundsException e)</span>
		{
			//nastala nam chyba, najrozumnejsie je spravit nacitanie novej instancie
<span class="nc" id="L3121">			GroupsDB.getInstance(true);</span>
<span class="fc" id="L3122">		}</span>
<span class="fc" id="L3123">	}</span>

	/**
	 * Inserts a group into cache, preserving GroupsDB sort invariant
	 *
	 * @param newGroup a group to be inserted
	 */
	private void insertGroupInCache(GroupDetails newGroup)
	{
		try
		{
<span class="fc" id="L3134">			synchronized(groups)</span>
			{
<span class="fc" id="L3136">				int index = Collections.binarySearch(groups, newGroup, groupsDbSorter);</span>
				//vlastnost binarySearch - ak neobsahuje takyto prvok, tak vrati zaporny index
				//toho, kde by sa mal nachadzat zmenseny o 1
<span class="pc bpc" id="L3139" title="1 of 2 branches missed.">				if (index &lt; 0)</span>
<span class="fc" id="L3140">					index = - index - 1;</span>

				//double check
<span class="pc bpc" id="L3143" title="1 of 2 branches missed.">				Optional&lt;GroupDetails&gt; existing = groups.stream().filter(g -&gt; g.getGroupId()==newGroup.getGroupId()).findFirst();</span>
<span class="pc bpc" id="L3144" title="1 of 2 branches missed.">				if (existing.isPresent()==false) {</span>
<span class="fc" id="L3145">					groups.add(index, newGroup);</span>
				}
<span class="fc" id="L3147">			}</span>
<span class="fc" id="L3148">			getGroupDetailsMap().put(newGroup.getGroupId(), newGroup);</span>

			//zresetuj all tree cache
<span class="fc" id="L3151">			groupsTreeAllCache = null;</span>

<span class="pc bpc" id="L3153" title="1 of 4 branches missed.">			if(Tools.isNotEmpty(newGroup.getDomainName()) &amp;&amp; newGroup.getParentGroupId() == 0)</span>
			{
<span class="pc bpc" id="L3155" title="1 of 2 branches missed.">			   if (domainIds.get(newGroup.getDomainName())==null) domainIds.put(newGroup.getDomainName(), newGroup.getGroupId());</span>
			}
<span class="fc" id="L3157">			idToGroups.put(newGroup.getGroupId(), newGroup);</span>

<span class="pc bpc" id="L3159" title="1 of 2 branches missed.">			if (Tools.isNotEmpty(newGroup.getDomainName()))</span>
			{
				//oznam DocDB ze mame taku domenu (vytvori hash tabulku pre danu domenu)
<span class="fc" id="L3162">				DocDB docDB = DocDB.getInstance();</span>
<span class="fc" id="L3163">				docDB.getUrlsByUrlDomains(newGroup.getDomainName(), true);</span>
			}
		}
<span class="nc" id="L3166">		catch (ConcurrentModificationException|ArrayIndexOutOfBoundsException ex)</span>
		{
			//nastala nam chyba, najrozumnejsie je spravit nacitanie novej instancie
<span class="nc" id="L3169">			GroupsDB.getInstance(true);</span>
<span class="fc" id="L3170">		}</span>
<span class="fc" id="L3171">	}</span>

	/**
	 * Replaces a group already existing in cache with a new one, preserving
	 * their natural sort.
	 * @param inCache old one
	 * @param notInCache new one
	 */
	private static void replaceGroupInCache(GroupDetails inCache,GroupDetails notInCache)
	{
<span class="fc" id="L3181">		GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="fc" id="L3182">		groupsDB.removeGroupFromCache(inCache, true);</span>
<span class="fc" id="L3183">		groupsDB = GroupsDB.getInstance();</span>
<span class="fc" id="L3184">		groupsDB.insertGroupInCache(notInCache);</span>
<span class="fc" id="L3185">	}</span>

	private static Map&lt;Integer ,GroupDetails&gt; getGroupDetailsMap()
	{
<span class="fc" id="L3189">		return getInstance().idToGroups;</span>
	}

	/**
	 * Vrati korenove adresare
	 * @return
	 */
	public static List&lt;GroupDetails&gt; getRootGroups()
	{
<span class="fc" id="L3198">		return new ComplexQuery().setSql(&quot;SELECT * FROM groups WHERE parent_group_id &lt;= 0 ORDER BY sort_priority ASC, group_name ASC&quot;).list(new Mapper&lt;GroupDetails&gt;()</span>
<span class="fc" id="L3199">		{</span>
			public GroupDetails map(ResultSet rs) throws SQLException
			{
<span class="fc" id="L3202">				return fillFieldsByResultSet(rs);</span>
			}

		});
	}

	public void resetGroupsTreeAllCache()
	{
<span class="nc" id="L3210">		groupsTreeAllCache = null;</span>
<span class="nc" id="L3211">	}</span>

	/**
	 * Test if at least one groupId is editable by user
	 * @param user
	 * @param groupIds
	 * @return
	 */
	public static boolean isGroupsEditable(UserDetails user, String groupIds) {
<span class="fc" id="L3220">		int[] groupIdsInt = Tools.getTokensInt(groupIds, &quot;,&quot;);</span>
<span class="fc" id="L3221">		return isGroupsEditable(user, groupIdsInt);</span>
	}

	/**
	 * Test if at least one groupId is editable by user
	 * @param user
	 * @param groupIds
	 * @return
	 */
	public static boolean isGroupsEditable(UserDetails user, int[] groupIds) {
<span class="pc bpc" id="L3231" title="1 of 4 branches missed.">		if (groupIds == null || groupIds.length==0) return true;</span>

<span class="pc bpc" id="L3233" title="1 of 2 branches missed.">		if (user == null) return false;</span>

<span class="fc bfc" id="L3235" title="All 2 branches covered.">		for (int groupId : groupIds) {</span>
<span class="fc bfc" id="L3236" title="All 2 branches covered.">			if (isGroupEditable(user, groupId)) return true;</span>
		}

<span class="fc" id="L3239">		return false;</span>
	}

	/**
	 * Otestuje, ci zadany adresar je pouzivatelom nastaveny ako editovatelny (user.getEditableGroups)
	 * @param user
	 * @param groupId
	 * @return
	 */
	public static boolean isGroupEditable(UserDetails user, int groupId)
	{
<span class="fc bfc" id="L3250" title="All 2 branches covered.">		if (groupId &lt; 1) return true;</span>

<span class="pc bpc" id="L3252" title="1 of 2 branches missed.">		if (user == null) return false;</span>
<span class="fc bfc" id="L3253" title="All 2 branches covered.">		if (Tools.isNotEmpty(user.getEditableGroups(true)))</span>
		{
<span class="fc" id="L3255">			GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="fc" id="L3256">			String parentGroups = &quot;,&quot; + groupId + &quot;,&quot; + groupsDB.getParents(groupId)+&quot;,&quot;;</span>
<span class="fc" id="L3257">			StringTokenizer st = new StringTokenizer(user.getEditableGroups(true), &quot;,&quot;);</span>
			String id;
			int i_id;
<span class="fc bfc" id="L3260" title="All 2 branches covered.">			while (st.hasMoreTokens())</span>
			{
<span class="fc" id="L3262">				id = st.nextToken().trim();</span>
				try
				{
<span class="fc" id="L3265">					i_id = Integer.parseInt(id);</span>
<span class="fc bfc" id="L3266" title="All 2 branches covered.">					if (parentGroups.indexOf(&quot;,&quot; + i_id + &quot;,&quot;) != -1)</span>
					{
<span class="fc" id="L3268">						return true;</span>
					}
				}
<span class="nc" id="L3271">				catch (Exception ex)</span>
				{

<span class="pc" id="L3274">				}</span>
			}
<span class="fc" id="L3276">		}</span>
		else
		{
<span class="fc" id="L3279">			return true;</span>
		}
<span class="fc" id="L3281">		return false;</span>
	}

	/**
	 * Testuje, ci moze user vidiet adresar, pouziva sa na overenie ked ma editaciu az niekde
	 * do poadresara, ale v FE potrebujeme zobrazit aj parentov v stromovej strukture
	 * @param user
	 * @param groupId
	 * @return
	 */
    public static boolean isGroupViewable(UserDetails user, int groupId) {
<span class="fc bfc" id="L3292" title="All 2 branches covered.">        if (groupId &lt; 1) return true;</span>

<span class="pc bpc" id="L3294" title="1 of 2 branches missed.">        if (user == null) return false;</span>

<span class="pc bpc" id="L3296" title="1 of 4 branches missed.">        if (user.getEditableGroups() == null || user.getEditableGroups().isEmpty()) {</span>
<span class="fc" id="L3297">            return true;</span>
        }

<span class="fc" id="L3300">        List&lt;GroupDetails&gt; editableGroups = getGroupsList(user.getEditableGroups());</span>
<span class="fc" id="L3301">        GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="fc bfc" id="L3302" title="All 2 branches covered.">        for (GroupDetails editableGroup : editableGroups) {</span>
<span class="fc" id="L3303">            List&lt;GroupDetails&gt; parents = groupsDB.getParentGroups(editableGroup.getGroupId(), true);</span>
<span class="fc bfc" id="L3304" title="All 4 branches covered.">            if (parents.stream().anyMatch(groupDetails -&gt; groupDetails.getGroupId() == groupId)) {</span>
<span class="fc" id="L3305">                return true;</span>
            }
<span class="fc" id="L3307">        }</span>

        //over aj zoznam pridelenych stranok
<span class="fc bfc" id="L3310" title="All 2 branches covered.">        if (Tools.isNotEmpty(user.getEditablePages())) {</span>
<span class="fc" id="L3311">            List&lt;DocDetails&gt; docs = UserTools.getEditablePages(user.getEditablePages());</span>
<span class="fc bfc" id="L3312" title="All 2 branches covered.">            for (DocDetails doc : docs) {</span>
<span class="fc" id="L3313">                List&lt;GroupDetails&gt; parents = groupsDB.getParentGroups(doc.getGroupId());</span>
<span class="fc" id="L3314">                parents.add(doc.getGroup());</span>
<span class="fc bfc" id="L3315" title="All 4 branches covered.">                if (parents.stream().anyMatch(groupDetails -&gt; groupDetails.getGroupId() == groupId)) {</span>
<span class="fc" id="L3316">                    return true;</span>
                }
<span class="fc" id="L3318">            }</span>
        }

<span class="fc" id="L3321">        return false;</span>
    }

    /**
     * Vrati list GroupDetails na zaklade ciarkou oddeleneho zoznamu ID adresarov
     * @param tokens - ciarkou oddeleny zoznam adresarov (z UserDetails.editableGroups)
     * @return
     */
    public static List&lt;GroupDetails&gt; getGroupsList(String tokens) {
<span class="fc" id="L3330">        List&lt;GroupDetails&gt; result = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L3332" title="1 of 2 branches missed.">        if (Tools.isEmpty(tokens)) {</span>
<span class="nc" id="L3333">            return Collections.emptyList();</span>
        }

<span class="fc" id="L3336">        String[] ids = Tools.getTokens(tokens, &quot;,&quot;);</span>

<span class="pc bpc" id="L3338" title="1 of 2 branches missed.">        if (ids.length == 0) {</span>
<span class="nc" id="L3339">            return Collections.emptyList();</span>
        }

<span class="fc" id="L3342">        GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="fc bfc" id="L3343" title="All 2 branches covered.">        for (String id : ids) {</span>
<span class="fc" id="L3344">        	int intId = Tools.getIntValue(id, 0);</span>
<span class="fc" id="L3345">            GroupDetails group = groupsDB.getGroup(intId);</span>
<span class="fc bfc" id="L3346" title="All 2 branches covered.">            if (group != null) {</span>
<span class="fc" id="L3347">                result.add(group);</span>
            }
        }

<span class="fc" id="L3351">        return result;</span>
    }

	/**
	 * Zrusi z nazvu adresara nepovolene znaky
	 * @param groupName
	 * @return
	 */
	public static String sanitizeGroupName(String groupName, boolean alsoSlash)
	{
<span class="fc bfc" id="L3361" title="All 2 branches covered.">		if (isEmpty(groupName))</span>
<span class="fc" id="L3362">			return &quot;&quot;;</span>
		//znak / nemozeme nahradzat priamo v GroupDetails.setGroupName(), pretoze pre userov s obmedzenymi pravami sa potom zle zobrazoval adresar (lebo sa mu do nazvu klonuje cela cesta, napr. /Interway/Novinky/
<span class="fc bfc" id="L3364" title="All 2 branches covered.">		if (alsoSlash)</span>
		{
<span class="fc" id="L3366">			groupName = Tools.replace(Tools.replace(groupName, &quot;\\&quot;, &quot;-&quot;), &quot;/&quot;, &quot;-&quot;);</span>
		}

<span class="fc" id="L3369">		return groupName.replace(&quot;/\n/gi&quot;, &quot; &quot;).replaceAll(&quot;/\\s+/gi&quot;, &quot; &quot;).replace('\\', '/').trim();</span>
	}

	/**
	 * Vrati  id root adresara danej domeny
	 * @param domain meno domeny
	 * @return
	 */
	public static int getDomainId(String domain)
	{
<span class="fc" id="L3379">		Integer id = getInstance().domainIds.get(domain);</span>
<span class="pc bpc" id="L3380" title="1 of 2 branches missed.">		if(id == null) id = -1;</span>
<span class="fc" id="L3381">		return id;</span>
	}

	/**
	 * Vrati adresar System ktory je v root adresari aktualnej domeny, teda napr. /www.interway.sk/System/
	 * @return
	 */
	public GroupDetails getLocalSystemGroup()
	{
<span class="fc" id="L3390">		String groupName = &quot;System&quot;;</span>
<span class="fc" id="L3391">		RequestBean rb = SetCharacterEncodingFilter.getCurrentRequestBean();</span>
<span class="pc bpc" id="L3392" title="1 of 2 branches missed.">		if (rb == null)</span>
		{
<span class="nc" id="L3394">			return null;</span>
		}

<span class="fc" id="L3397">		String domain = rb.getDomain();</span>
<span class="pc bpc" id="L3398" title="1 of 2 branches missed.">		if (Tools.isEmpty(domain)) return null;</span>
<span class="fc" id="L3399">		int rootGroupId = GroupsDB.getDomainId(domain);</span>
<span class="pc bpc" id="L3400" title="1 of 2 branches missed.">		if (rootGroupId &lt; 1) return null;</span>

<span class="pc bpc" id="L3402" title="1 of 2 branches missed.">		for (GroupDetails group : groups)</span>
		{
<span class="fc bfc" id="L3404" title="All 4 branches covered.">			if (group.getParentGroupId()==rootGroupId &amp;&amp; groupName.equalsIgnoreCase(group.getGroupName()))</span>
			{
				//vratime adresar, System v hlavnom priecinku domeny (stary system)
<span class="fc" id="L3407">				return (group);</span>
			}
<span class="fc bfc" id="L3409" title="All 6 branches covered.">			else if (group.getParentGroupId()&lt;1 &amp;&amp; groupName.equalsIgnoreCase(group.getGroupName()) &amp;&amp; domain.equalsIgnoreCase(group.getDomainName()))</span>
			{
				//ak sa jedna o ROOT priecinok System v aktualnej domene, vrat ten (WJ9 rezim)
<span class="fc" id="L3412">				return group;</span>
			}
<span class="fc" id="L3414">		}</span>

<span class="nc" id="L3416">		return (null);</span>
	}

	/**
	 * Vrati ID adresara System ktory je v root adresari aktualnej domeny, teda napr. /www.interway.sk/System/
	 * @return
	 */
	public int getLocalSystemGroupId()
	{
<span class="fc" id="L3425">		GroupDetails localSystem = getLocalSystemGroup();</span>
<span class="pc bpc" id="L3426" title="1 of 2 branches missed.">		if (localSystem != null) return localSystem.getGroupId();</span>

<span class="nc" id="L3428">		return -1;</span>
	}

	/**
	 * Vytvori novy root adresar a nastavi mu domenu
	 * ak uz domena existuje, vrati -1
	 * @param localDomainName
	 * @return
	 */
	public int createLocalDomain(String localDomainName)
	{
<span class="nc bnc" id="L3439" title="All 2 branches missed.">		if (Tools.isEmpty(localDomainName)) return -1;</span>

<span class="nc" id="L3441">		localDomainName = localDomainName.toLowerCase();</span>

<span class="nc bnc" id="L3443" title="All 2 branches missed.">		if(GroupsDB.getInstance().domainIds.containsKey(localDomainName))</span>
		{
<span class="nc" id="L3445">			Logger.debug(getClass(), &quot;Domain already exists: &quot; + localDomainName);</span>
<span class="nc" id="L3446">			return -1;</span>
		}
<span class="nc" id="L3448">		Logger.debug(getClass(), &quot;Creating domain root folder for domain: &quot; + localDomainName);</span>
<span class="nc" id="L3449">		int actualParent = 0;</span>
		String actualGroupName;
		GroupDetails actualGroup;
<span class="nc" id="L3452">		actualGroupName = localDomainName;</span>
<span class="nc" id="L3453">		actualGroup = getGroup(actualGroupName, actualParent);</span>
<span class="nc bnc" id="L3454" title="All 2 branches missed.">		if (actualGroup == null)</span>
		{
<span class="nc" id="L3456">			actualGroup = new GroupDetails();</span>
<span class="nc" id="L3457">			actualGroup.setParentGroupId(0);</span>
<span class="nc" id="L3458">			actualGroup.setGroupId(-1);</span>
<span class="nc" id="L3459">			actualGroup.setDefaultDocId(-1);</span>
<span class="nc" id="L3460">			actualGroup.setGroupName(actualGroupName);</span>
<span class="nc" id="L3461">			actualGroup.setNavbar(actualGroupName);</span>
<span class="nc" id="L3462">			actualGroup.setUrlDirName(&quot;/&quot;);</span>
<span class="nc" id="L3463">			actualGroup.setSortPriority(getDefaultSortPriority(actualGroup.getParentGroupId()));</span>
<span class="nc" id="L3464">			actualGroup.setDomainName(localDomainName);</span>
<span class="nc" id="L3465">			setGroup(actualGroup);</span>
<span class="nc" id="L3466">			Logger.debug(getClass(), &quot;Domain root folder for domain: &quot; + localDomainName + &quot; created, id: &quot; + actualGroup.getGroupId());</span>
		}
		else
		{
<span class="nc" id="L3470">			Logger.debug(getClass(), &quot;Domain root folder for domain: &quot; + localDomainName + &quot; already exists, id: &quot; + actualGroup.getGroupId());</span>
		}
<span class="nc" id="L3472">		return actualGroup.getGroupId();</span>
	}

	/**
	 * Zmeni nazov hlavnej stranky groupy podla nazvu grupy, v ktorej sa stranka nachadza
	 * @param gd - ID grupy ktorej ktorej GroupName sa nastavi ako Title pre document.
	 * 				Ak je null, nic sa nevykona.
	 */
	private boolean changeDocTitle(GroupDetails gd)
	{
<span class="pc bpc" id="L3482" title="3 of 12 branches missed.">		if(gd != null &amp;&amp; gd.isInternal()==false &amp;&amp; gd.getMenuType()!=GroupDetails.MENU_TYPE_HIDDEN &amp;&amp; gd.getFullPath()!=null &amp;&amp; gd.getFullPath().indexOf(&quot;/System&quot;)==-1 &amp;&amp; gd.getParentGroupId()&gt;0)</span>
		{
<span class="fc" id="L3484">			DocDetails docDetails = DocDB.getInstance().getDoc(gd.getDefaultDocId());</span>
<span class="pc bpc" id="L3485" title="2 of 6 branches missed.">			if(docDetails != null &amp;&amp; (docDetails.getTitle() != null &amp;&amp; !gd.getGroupName().equals(docDetails.getTitle())))</span>
			{
<span class="fc" id="L3487">				Logger.debug(DocDB.class, &quot;Renaming document: &quot;+docDetails.getDocId()+&quot; to name :&quot;+gd.getGroupName());</span>
<span class="fc" id="L3488">				docDetails.setTitle(gd.getGroupName());</span>
<span class="fc" id="L3489">				docDetails.setNavbar(gd.getGroupName());</span>
<span class="fc" id="L3490">				DocDB.saveDoc(docDetails);</span>
<span class="fc" id="L3491">				return true;</span>
			}
<span class="fc" id="L3493">			return false;</span>
		}
		else
		{
<span class="fc" id="L3497">			return false;</span>
		}
	}

	/**
	 * Zmeni domenu pre adresar aj podadresare (pouzitie v cloud nodoch - zmena domeny
	 *
	 * @param oldDomain povodna domena
	 * @param newDomain nova domena
	 * @return
	 */
	public static boolean changeDomain(String oldDomain, String newDomain)
	{
<span class="nc" id="L3510">		GroupsDB groupsDb = GroupsDB.getInstance();</span>
<span class="nc" id="L3511">		DocDB docDb = DocDB.getInstance();</span>
<span class="nc" id="L3512">		GroupDetails group = groupsDb.getGroup(oldDomain, 0);</span>
<span class="nc" id="L3513">		StringBuilder messageToAdminlog = new StringBuilder();</span>
<span class="nc" id="L3514">		messageToAdminlog.append(&quot;Pozadovana zmena domeny OLD: '&quot;).append(oldDomain).append(&quot;', NEW: '&quot;).append(newDomain).append(&quot;' \n&quot;);</span>
<span class="nc" id="L3515">	 	String groupIds = GroupsDB.getInstance().getSubgroupsIds(group.getGroupId());</span>
<span class="nc" id="L3516">	 	messageToAdminlog.append(&quot;Zoznam ID adresarov: &quot;).append(groupIds).append(&quot;\n&quot;);</span>
<span class="nc" id="L3517">	 	int[] ids = Tools.getTokensInt(groupIds, &quot;,&quot;);</span>
<span class="nc" id="L3518">	 	List&lt;DocDetails&gt; oldDocs = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L3520" title="All 2 branches missed.">		for (int i=0;i&lt;ids.length;i++)</span>
		{
<span class="nc" id="L3522">			List&lt;DocDetails&gt; docsInGroup = docDb.getBasicDocDetailsByGroup(ids[i], DocDB.ORDER_PRIORITY);</span>
<span class="nc bnc" id="L3523" title="All 4 branches missed.">			if (docsInGroup!=null &amp;&amp; docsInGroup.size()&gt;0)</span>
<span class="nc" id="L3524">				oldDocs.addAll(docsInGroup);</span>
		}
<span class="nc bnc" id="L3526" title="All 2 branches missed.">		for (DocDetails doc : oldDocs)</span>
		{
<span class="nc" id="L3528">			messageToAdminlog.append(&quot;Zmena domeny pre Doc (docId) &quot;).append(doc.getDocId()).append(&quot; :&quot;);</span>
<span class="nc bnc" id="L3529" title="All 4 branches missed.">			if (doc.getFieldT()!=null &amp;&amp; doc.getFieldT().equals(oldDomain))</span>
			{
<span class="nc" id="L3531">				messageToAdminlog.append(&quot;-povolena\n&quot;);</span>
<span class="nc" id="L3532">				doc.setFieldT(newDomain);</span>
			} else
			{
<span class="nc" id="L3535">				messageToAdminlog.append(&quot;-zamietnuta\n&quot;);</span>
			}
<span class="nc" id="L3537">		}</span>

<span class="nc" id="L3539">		Adminlog.add(Adminlog.TYPE_CLIENT_SPECIFIC, messageToAdminlog.toString(), 0, 0);</span>
<span class="nc" id="L3540">		SimpleQuery sq = new SimpleQuery();</span>
<span class="nc" id="L3541">	  	sq.execute(&quot;UPDATE groups SET domain_name=? WHERE group_id IN (&quot;+groupIds+&quot;)&quot;, newDomain);</span>
<span class="nc" id="L3542">	  	sq.execute(&quot;UPDATE groups SET group_name=?, navbar=? WHERE group_id=?&quot;, newDomain, newDomain, group.getGroupId());</span>
<span class="nc" id="L3543">	  	sq.execute(&quot;UPDATE url_redirect SET domain_name=? WHERE domain_name=?&quot;, newDomain, oldDomain);</span>

	  	//premenovanie liniek
<span class="nc" id="L3546">	  	sq.execute(&quot;UPDATE documents SET external_link=REPLACE(external_link, ?, ?) WHERE group_id IN (&quot;+groupIds+&quot;)&quot;, &quot;http://&quot;+oldDomain, &quot;http://&quot;+newDomain);</span>
<span class="nc" id="L3547">	  	sq.execute(&quot;UPDATE documents SET data=REPLACE(data, ?, ?) WHERE group_id IN (&quot;+groupIds+&quot;)&quot;, &quot;http://&quot;+oldDomain, &quot;http://&quot;+newDomain);</span>

<span class="nc" id="L3549">	  	Adminlog.add(Adminlog.TYPE_CLIENT_SPECIFIC, &quot;Changed domain for cloud web, old domain: '&quot;+oldDomain+&quot;', new domain: '&quot;+newDomain+&quot;'&quot;, 0, 0);</span>

<span class="nc" id="L3551">	  	docDb.changeUrlInUrlmap(oldDomain, newDomain);</span>

<span class="nc" id="L3553">	  	IwcmFile oldDir = new IwcmFile(FilePathTools.getDomainBaseFolder(oldDomain));</span>
<span class="nc" id="L3554">	  	IwcmFile newDir = new IwcmFile(FilePathTools.getDomainBaseFolder(newDomain));</span>
<span class="nc" id="L3555">	  	newDir.mkdirs();</span>

	  	//toto asi nezbehne, kedze je to v roznych adresaroch, bude potrebne spravit move
	  	//oldDir.renameTo(newDir);
	  	try
		{
<span class="nc" id="L3561">	  		FileTools.copyDirectory(oldDir, newDir);</span>
<span class="nc" id="L3562">	  		Adminlog.add(Adminlog.TYPE_CLIENT_SPECIFIC, &quot;Changed domain, old domain: '&quot;+oldDomain+&quot;', new domain: '&quot;+newDomain+&quot;', files from &quot;+oldDir.getAbsolutePath()+&quot; to &quot;+newDir.getAbsolutePath(), 0, 0);</span>

<span class="nc" id="L3564">	  		FileTools.deleteDirTree(oldDir);</span>
		}
<span class="nc" id="L3566">		catch (Exception e)</span>
		{
<span class="nc" id="L3568">			sk.iway.iwcm.Logger.error(e);</span>
<span class="nc" id="L3569">		}</span>

	  	//reloadneme singletona aby sa nam prejavili vsetky zmeny
<span class="nc" id="L3572">	  	GroupsDB.getInstance(true);</span>
	  	//toto by asi ani nebolo treba, ale pre istotu pridavam
<span class="nc" id="L3574">	  	DocDB.getInstance(true);</span>

<span class="nc" id="L3576">	  	return true;</span>
	}

	/**
	 * Vrati zoznam hlavnych adresarov pre prava pouzivatela
	 * @param editableGroups
	 * @return
	 */
	public List&lt;GroupDetails&gt; getRootGroups(String editableGroups)
	{
<span class="fc" id="L3586">		List&lt;GroupDetails&gt; rootGroups = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L3588" title="All 2 branches covered.">		if (Tools.isNotEmpty(editableGroups))</span>
		{
<span class="fc" id="L3590">			StringTokenizer st = new StringTokenizer(editableGroups, &quot;,&quot;);</span>
			String id;
			int i_id;
<span class="fc bfc" id="L3593" title="All 2 branches covered.">			while (st.hasMoreTokens())</span>
			{
<span class="fc" id="L3595">				id = st.nextToken().trim();</span>
				try
				{
<span class="fc" id="L3598">					i_id = Integer.parseInt(id);</span>
					//pridaj to do stromu editovatelnych stranok
<span class="fc" id="L3600">					GroupDetails parentGroup = findGroup(i_id);</span>
<span class="fc" id="L3601">					GroupDetails parentGroupCopy = new GroupDetails(parentGroup);</span>
<span class="fc" id="L3602">					parentGroupCopy.setParentGroupId(0);</span>
<span class="pc bpc" id="L3603" title="1 of 2 branches missed.">					if (parentGroup.getFullPath().length() &gt; 200)</span>
					{
<span class="nc" id="L3605">						parentGroupCopy.setGroupName(&quot;...&quot;+parentGroup.getFullPath().substring(parentGroup.getFullPath().length()-198));</span>
					}
					else
					{
<span class="fc" id="L3609">						parentGroupCopy.setGroupName(parentGroup.getFullPath());</span>
					}

<span class="fc" id="L3612">					String userEditableTreeMenuType = Constants.getString(&quot;userEditableTreeMenuType&quot;, &quot;rows&quot;);</span>
<span class="pc bpc" id="L3613" title="1 of 2 branches missed.">					if (&quot;tree&quot;.equalsIgnoreCase(userEditableTreeMenuType)) {</span>

<span class="nc" id="L3615">						GroupDetails root = getGroup(getRoot(parentGroup.getGroupId()));</span>

<span class="nc bnc" id="L3617" title="All 4 branches missed.">						if (rootGroups.stream().noneMatch(r-&gt;r.getGroupId() == root.getGroupId())) {</span>
<span class="nc" id="L3618">							rootGroups.add(root);</span>
						}
<span class="nc" id="L3620">					}</span>
					else {
<span class="pc bpc" id="L3622" title="2 of 4 branches missed.">						if (rootGroups.stream().noneMatch(r-&gt;r.getGroupId() == parentGroupCopy.getGroupId())) {</span>
<span class="fc" id="L3623">							rootGroups.add(parentGroupCopy);</span>
						}
					}
				}
<span class="fc" id="L3627">				catch (Exception ex)</span>
				{

<span class="fc" id="L3630">				}</span>
			}
<span class="fc" id="L3632">		}</span>
		else
		{
<span class="fc" id="L3635">			rootGroups.addAll(getRootGroups());</span>
		}

<span class="fc" id="L3638">		return (rootGroups);</span>
	}

	/**
	 * vrati zoznam nazvov root domen pre ktore ma pouzivatel pravo
	 * @param editableGroups
	 * @return
	 */
	public List&lt;String&gt; getUserRootDomainNames(String editableGroups)
	{
<span class="fc" id="L3648">		List&lt;String&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L3649" title="All 2 branches covered.">		for(GroupDetails gd : getRootGroups(editableGroups))</span>
		{
<span class="fc bfc" id="L3651" title="All 4 branches covered.">			if(Tools.isNotEmpty(gd.getDomainName()) &amp;&amp; ret.contains(gd.getDomainName()) == false)</span>
<span class="fc" id="L3652">				ret.add(gd.getDomainName());</span>
<span class="fc" id="L3653">		}</span>

<span class="fc" id="L3655">		return ret;</span>
	}

	/**
	 * Otestuje ci ma adresar akehokolvek potomka - podadresar alebo web stranku
	 * @param groupId
	 * @return
	 */
	public boolean hasAnyChild(int groupId)
	{
<span class="nc" id="L3665">		return hasAnyChild(groupId, true);</span>
	}

	/**
	 * Otestuje, ci ma podadresar potomka
	 * @param groupId
	 * @param includePages - ak je true, testuju sa aj web stranky
	 * @return
	 */
	public boolean hasAnyChild(int groupId, boolean includePages)
	{
<span class="fc bfc" id="L3676" title="All 2 branches covered.">		for (GroupDetails group : groups)</span>
		{
<span class="fc bfc" id="L3678" title="All 2 branches covered.">			if (group.getParentGroupId() == groupId)</span>
			{
<span class="fc" id="L3680">				return true;</span>
			}
<span class="fc" id="L3682">		}</span>

<span class="fc bfc" id="L3684" title="All 2 branches covered.">		if (includePages)</span>
		{
<span class="fc" id="L3686">			List&lt;DocDetails&gt; docs = DocDB.getInstance().getBasicDocDetailsByGroup(groupId, -1);</span>
<span class="pc bpc" id="L3687" title="1 of 4 branches missed.">			if (docs != null &amp;&amp; docs.size() &gt; 0) return true;</span>
		}

<span class="fc" id="L3690">		return false;</span>
	}

	public GroupDetails addNewRootGroup(String newGroupName)
	{
<span class="nc" id="L3695">		GroupDetails ctxGroup = getNewGroupDetails(newGroupName, 0);</span>
<span class="nc" id="L3696">		GroupsDB.getInstance().setGroup(ctxGroup);</span>

<span class="nc" id="L3698">		return ctxGroup;</span>
	}

	/**
	 * Vytvori novy adresar so zadanym menom v danom parent adresari
	 * @param newGroupName
	 * @param parentGroupId
	 * @return
	 */
	public GroupDetails addNewGroup(String newGroupName, int parentGroupId)
	{
<span class="nc" id="L3709">		GroupDetails ctxGroup = getNewGroupDetails(newGroupName, parentGroupId);</span>
<span class="nc" id="L3710">		GroupsDB.getInstance().setGroup(ctxGroup);</span>

<span class="nc" id="L3712">		return ctxGroup;</span>
	}

	/**
	 * Pripravi groupDetails objekt pre ulozenie do zadaneho parenta
	 * Nastavi potrebne (dedene) atributy a objekty
	 */
	public GroupDetails getNewGroupDetails(String newGroupName, int parentGroupId) {
		GroupDetails parentGroup;
<span class="pc bpc" id="L3721" title="1 of 2 branches missed.">		if (parentGroupId&gt;0) parentGroup = getGroup(parentGroupId);</span>
<span class="nc" id="L3722">		else parentGroup = getGroup(Constants.getInt(&quot;rootGroupId&quot;));</span>

<span class="fc" id="L3724">		GroupDetails ctxGroup = null;</span>
		try
		{
<span class="fc" id="L3727">			ctxGroup = (GroupDetails)parentGroup.clone();</span>
<span class="fc" id="L3728">			ctxGroup.setParentGroupId(parentGroupId);</span>
<span class="fc" id="L3729">			ctxGroup.setDefaultDocId(-1);</span>
<span class="fc" id="L3730">			ctxGroup.setNewPageDocIdTemplate(-1);</span>
<span class="fc" id="L3731">			ctxGroup.setHtmlHead(&quot;&quot;);</span>
<span class="fc" id="L3732">			ctxGroup.setGroupName(newGroupName);</span>
<span class="fc" id="L3733">			ctxGroup.setNavbar(newGroupName);</span>
<span class="fc" id="L3734">			ctxGroup.setUrlDirName(newGroupName);</span>
<span class="fc" id="L3735">			ctxGroup.setUrlDirName(ctxGroup.getUrlDirName());</span>

<span class="fc" id="L3737">			ctxGroup.setSortPriority(GroupsDB.getInstance().getDefaultSortPriority(parentGroupId));</span>

<span class="pc bpc" id="L3739" title="1 of 2 branches missed.">			if (parentGroupId == 0) {</span>
				//pre root foldre toto dava zmysel
<span class="nc" id="L3741">				ctxGroup.setInternal(false);</span>
<span class="nc" id="L3742">				ctxGroup.setMenuType(GroupDetails.MENU_TYPE_ONLYDEFAULT);</span>
			}

<span class="fc" id="L3745">			ctxGroup.setLogonPageDocId(-1);</span>

<span class="fc" id="L3747">			ctxGroup.setGroupId(-1);</span>
<span class="fc" id="L3748">			ctxGroup.setSyncId(0);</span>
<span class="fc" id="L3749">			ctxGroup.setSyncStatus(0);</span>

			//ticket 11208
<span class="pc bpc" id="L3752" title="2 of 4 branches missed.">			if(Tools.isNotEmpty(ctxGroup.getDomainName()) &amp;&amp; ctxGroup.getParentGroupId() &lt; 1)</span>
			{
<span class="nc" id="L3754">				ctxGroup.setDomainName(&quot;www.&quot;+ctxGroup.getUrlDirName()+&quot;.sk&quot;);</span>
			}

<span class="pc bpc" id="L3757" title="1 of 2 branches missed.">			if (parentGroupId&gt;0) {</span>
				//nekopirujeme field_a az field_d pretoze to je nepotrebne (daju sa ziskat rekurzivne)
<span class="fc" id="L3759">				ctxGroup.setFieldA(&quot;&quot;);</span>
<span class="fc" id="L3760">				ctxGroup.setFieldB(&quot;&quot;);</span>
<span class="fc" id="L3761">				ctxGroup.setFieldC(&quot;&quot;);</span>
<span class="fc" id="L3762">				ctxGroup.setFieldD(&quot;&quot;);</span>
			}
		}
<span class="nc" id="L3765">		catch (CloneNotSupportedException e)</span>
		{
<span class="nc" id="L3767">			sk.iway.iwcm.Logger.error(e);</span>
<span class="fc" id="L3768">		}</span>

<span class="fc" id="L3770">		return ctxGroup;</span>
	}

	/**
	 * ziskanie vsetkych System adresarov
	 * @return
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public List&lt;GroupDetails&gt; getAllSystemFolders(boolean forceRefresh)
	{
<span class="pc bpc" id="L3780" title="1 of 2 branches missed.">		if(Constants.getBoolean(&quot;templatesUseRecursiveSystemFolder&quot;) == false) return null;</span>

<span class="nc" id="L3782">		String groupName = &quot;System&quot;;</span>
<span class="nc" id="L3783">		String cacheName = &quot;sk.iway.iwcm.doc.groupsdb.all-system-folders&quot;;</span>
<span class="nc" id="L3784">		int cacheInMinutes = Constants.getInt(&quot;allSystemFoldersCacheMinutes&quot;);</span>

<span class="nc" id="L3786">		Cache c = Cache.getInstance();</span>
<span class="nc bnc" id="L3787" title="All 2 branches missed.">		if(forceRefresh == false)</span>
		{
<span class="nc" id="L3789">			Object o = c.getObject(cacheName);</span>
<span class="nc bnc" id="L3790" title="All 2 branches missed.">			if (o instanceof List&lt;?&gt;)</span>
			{
<span class="nc" id="L3792">				Logger.debug(GroupsDB.class, &quot;citam vsetky system adresare z cache (forceRefresh=&quot;+forceRefresh+&quot;; cacheInMinutes=&quot;+cacheInMinutes+&quot;)&quot;);</span>
<span class="nc" id="L3793">				return (List&lt;GroupDetails&gt;)o;</span>
			}
		}

<span class="nc" id="L3797">		List&lt;GroupDetails&gt; systemFolders = null;</span>
<span class="nc bnc" id="L3798" title="All 2 branches missed.">		if(groups != null)</span>
		{
<span class="nc bnc" id="L3800" title="All 2 branches missed.">			for (GroupDetails group : groups)</span>
			{
<span class="nc bnc" id="L3802" title="All 4 branches missed.">				if (group.isInternal() &amp;&amp; groupName.equalsIgnoreCase(group.getGroupName()))</span>
				{
<span class="nc bnc" id="L3804" title="All 2 branches missed.">					if(systemFolders == null) systemFolders = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3805">					systemFolders.add(group);</span>
				}
<span class="nc" id="L3807">			}</span>
		}

<span class="nc" id="L3810">		Logger.debug(GroupsDB.class, &quot;pisem vsetky system adresare do cache (forceRefresh=&quot;+forceRefresh+&quot;; cacheInMinutes=&quot;+cacheInMinutes+&quot;)&quot;);</span>
<span class="nc bnc" id="L3811" title="All 2 branches missed.">		if(cacheInMinutes &gt; 0) c.setObjectSeconds(cacheName, systemFolders, cacheInMinutes*60, true);</span>

<span class="nc" id="L3813">		return systemFolders;</span>
	}

	/**
	 * Vrati prvy vyskyt adresara System od root adresara az po aktualny adresar groupId
	 * @return
	 */
	public GroupDetails getSystemGroupRecursive(int groupId)
	{
<span class="nc" id="L3822">		List&lt;GroupDetails&gt; pathListGroups = getPathList(groupId);</span>
<span class="nc bnc" id="L3823" title="All 2 branches missed.">		if(pathListGroups != null)</span>
		{
<span class="nc" id="L3825">			List&lt;GroupDetails&gt; getAllSystemFolders = getAllSystemFolders(false);</span>
<span class="nc bnc" id="L3826" title="All 2 branches missed.">			if(getAllSystemFolders != null)</span>
			{
<span class="nc bnc" id="L3828" title="All 2 branches missed.">				for (GroupDetails plGroup : pathListGroups)</span>
				{
<span class="nc bnc" id="L3830" title="All 2 branches missed.">					for (GroupDetails group : getAllSystemFolders)</span>
					{
<span class="nc bnc" id="L3832" title="All 2 branches missed.">						if (group.getParentGroupId() == plGroup.getGroupId())</span>
						{
<span class="nc" id="L3834">							return group;</span>
						}
<span class="nc" id="L3836">					}</span>
<span class="nc" id="L3837">				}</span>
			}
		}

<span class="nc" id="L3841">		return (null);</span>
	}

	/**
	 * Vrati list vsetkych domen
	 * @return
	 */
	public List&lt;String&gt; getAllDomainsList(){
<span class="fc" id="L3849">		HashSet&lt;String&gt; domainsSet=new HashSet&lt;&gt;();</span>

<span class="fc" id="L3851">		List&lt;GroupDetails&gt; allGroups = getGroupsAll();</span>
<span class="fc bfc" id="L3852" title="All 2 branches covered.">		for(GroupDetails g: allGroups){</span>
<span class="fc bfc" id="L3853" title="All 4 branches covered.">				if(g.getParentGroupId() == 0 &amp;&amp; !g.getDomainName().isEmpty()){</span>
<span class="fc" id="L3854">					domainsSet.add(g.getDomainName());</span>
				}
<span class="fc" id="L3856">		}</span>

<span class="fc" id="L3858">		return new ArrayList&lt;&gt;(domainsSet);</span>
	}

    /**
     * Nastav jazyk na podadresare
     *
     * @param parentGroupId
     * @param language
     */
    public void setLngToSubGroups(int parentGroupId, String language) {

<span class="fc" id="L3869">        Connection db_conn = null;</span>
<span class="fc" id="L3870">        PreparedStatement ps = null;</span>
<span class="fc" id="L3871">        String groupIds = this.getSubgroupsIds(parentGroupId);</span>

<span class="fc" id="L3873">        Adminlog.add(Adminlog.TYPE_GROUP, &quot;Force language [&quot; + language + &quot;] to subgroups: &quot; + groupIds, parentGroupId, -1);</span>
        try {
<span class="fc" id="L3875">			db_conn = DBPool.getConnection();</span>
<span class="fc" id="L3876">            ps = db_conn.prepareStatement(&quot;UPDATE groups SET lng=? WHERE group_id IN (&quot; + groupIds + &quot;)&quot;);</span>
<span class="fc" id="L3877">            ps.setString(1, language);</span>
<span class="fc" id="L3878">            ps.execute();</span>
<span class="nc" id="L3879">        } catch (Exception ex) {</span>
<span class="nc" id="L3880">            sk.iway.iwcm.Logger.error(ex);</span>
        } finally {
            try {
<span class="pc bpc" id="L3883" title="1 of 2 branches missed.">                if (ps != null)</span>
<span class="fc" id="L3884">                    ps.close();</span>
<span class="pc bpc" id="L3885" title="1 of 2 branches missed.">                if (db_conn != null)</span>
<span class="fc" id="L3886">                    db_conn.close();</span>
<span class="nc" id="L3887">            } catch (Exception ex) {</span>
<span class="nc" id="L3888">                sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L3889">            }</span>
        }
<span class="fc" id="L3891">    }</span>

    /**
     * nastav sposob zobrazovania a interny podadresarom
     * @param parentGroupId
     * @param internal
     * @param menuType
     * @param loggedMenuType
     */
    public void setInternalAndMenuTypeToSubgroups(int parentGroupId, boolean internal, int menuType, int loggedMenuType) {

<span class="nc" id="L3902">        String groupMenuIds = this.getSubgroupsIds(parentGroupId);</span>

<span class="nc bnc" id="L3904" title="All 2 branches missed.">        if (Tools.isNotEmpty(groupMenuIds)) {</span>
<span class="nc" id="L3905">            Connection db_conn = null;</span>
<span class="nc" id="L3906">            PreparedStatement ps = null;</span>

<span class="nc" id="L3908">            Adminlog.add(Adminlog.TYPE_GROUP, &quot;Force Show Menu Setings to subgroups: &quot; + groupMenuIds, parentGroupId, -1);</span>
            try {
<span class="nc" id="L3910">				db_conn = DBPool.getConnection();</span>
<span class="nc" id="L3911">                ps = db_conn.prepareStatement(&quot;UPDATE groups SET internal=?, menu_type=?, logged_menu_type=?  WHERE group_id IN (&quot; + groupMenuIds + &quot;)&quot;);</span>
<span class="nc" id="L3912">                ps.setBoolean(1, internal);</span>
<span class="nc" id="L3913">                ps.setInt(2, menuType);</span>
<span class="nc" id="L3914">                ps.setInt(3, loggedMenuType);</span>
<span class="nc" id="L3915">                ps.execute();</span>
<span class="nc" id="L3916">            } catch (Exception ex) {</span>
<span class="nc" id="L3917">                sk.iway.iwcm.Logger.error(ex);</span>
            } finally {
                try {
<span class="nc bnc" id="L3920" title="All 2 branches missed.">                    if (ps != null)</span>
<span class="nc" id="L3921">                        ps.close();</span>
<span class="nc bnc" id="L3922" title="All 2 branches missed.">                    if (db_conn != null)</span>
<span class="nc" id="L3923">                        db_conn.close();</span>
<span class="nc" id="L3924">                } catch (Exception ex) {</span>
<span class="nc" id="L3925">                    sk.iway.iwcm.Logger.error(ex);</span>
<span class="nc" id="L3926">                }</span>
            }
        }
<span class="nc" id="L3929">    }</span>

    /**
     * nastav prava podadresarom
     */
    public void setPermissionToSubgroups(int parentGroupId, String passwordProtectedString) {

<span class="fc" id="L3936">        Connection db_conn = null;</span>
<span class="fc" id="L3937">        PreparedStatement ps = null;</span>
<span class="fc" id="L3938">        String groupIds = this.getSubgroupsIds(parentGroupId);</span>

<span class="fc" id="L3940">        Adminlog.add(Adminlog.TYPE_GROUP, &quot;Force perms to subgroups: &quot; + groupIds + &quot; perms=&quot; + passwordProtectedString, parentGroupId, -1);</span>

        try {
<span class="fc" id="L3943">			db_conn = DBPool.getConnection();</span>
<span class="fc" id="L3944">            ps = db_conn.prepareStatement(&quot;UPDATE groups SET password_protected=? WHERE group_id IN (&quot; + groupIds + &quot;)&quot;);</span>
<span class="fc" id="L3945">            ps.setString(1, passwordProtectedString);</span>
<span class="fc" id="L3946">            ps.execute();</span>
<span class="nc" id="L3947">        } catch (Exception ex) {</span>
<span class="nc" id="L3948">            sk.iway.iwcm.Logger.error(ex);</span>
        } finally {
            try {
<span class="pc bpc" id="L3951" title="1 of 2 branches missed.">                if (ps != null)</span>
<span class="fc" id="L3952">                    ps.close();</span>
<span class="pc bpc" id="L3953" title="1 of 2 branches missed.">                if (db_conn != null)</span>
<span class="fc" id="L3954">                    db_conn.close();</span>
<span class="nc" id="L3955">            } catch (Exception ex) {</span>
<span class="nc" id="L3956">                sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L3957">            }</span>
		  }

		  //mame zmeny je najlepsie refreshnut celu GroupsDB
<span class="fc" id="L3961">		  GroupsDB.getInstance(true);</span>
<span class="fc" id="L3962">    }</span>

    /**
     * nastav sablonu podadresarom
     * @param parentGroupId
     */
    public void setTemplateToSubgroups(int parentGroupId, int templateId) {

<span class="fc" id="L3970">        Connection db_conn = null;</span>
<span class="fc" id="L3971">        PreparedStatement ps = null;</span>

<span class="fc" id="L3973">        String groupIds = this.getSubgroupsIds(parentGroupId);</span>
<span class="fc" id="L3974">        Adminlog.add(Adminlog.TYPE_GROUP, &quot;Force template to subgroups: &quot; + groupIds, parentGroupId, templateId);</span>

        try {
<span class="fc" id="L3977">			db_conn = DBPool.getConnection();</span>
<span class="fc" id="L3978">            ps = db_conn.prepareStatement(&quot;UPDATE groups SET temp_id=? WHERE group_id IN (&quot; + groupIds + &quot;)&quot;);</span>
<span class="fc" id="L3979">            ps.setInt(1, templateId);</span>
<span class="fc" id="L3980">            ps.execute();</span>
<span class="nc" id="L3981">        } catch (Exception ex) {</span>
<span class="nc" id="L3982">            sk.iway.iwcm.Logger.error(ex);</span>
        } finally {
            try {
<span class="pc bpc" id="L3985" title="1 of 2 branches missed.">                if (ps != null)</span>
<span class="fc" id="L3986">                    ps.close();</span>
<span class="pc bpc" id="L3987" title="1 of 2 branches missed.">                if (db_conn != null)</span>
<span class="fc" id="L3988">                    db_conn.close();</span>
<span class="nc" id="L3989">            } catch (Exception ex) {</span>
<span class="nc" id="L3990">                sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L3991">            }</span>
        }
<span class="fc" id="L3993">    }</span>

    /**
     * nastav sablonu podstrankam
     */
    public void setTemplateToSubpages(int parentGroupId, int templateId) {
<span class="fc" id="L3999">        Connection db_conn = null;</span>
<span class="fc" id="L4000">        PreparedStatement ps = null;</span>

<span class="fc" id="L4002">        String groupIds = this.getSubgroupsIds(parentGroupId);</span>
<span class="fc" id="L4003">        Adminlog.add(Adminlog.TYPE_GROUP, &quot;Force template to subpages: &quot; + groupIds, parentGroupId, templateId);</span>

        try {
<span class="fc" id="L4006">			db_conn = DBPool.getConnection();</span>
<span class="fc" id="L4007">            ps = db_conn.prepareStatement(&quot;UPDATE documents SET temp_id=? WHERE group_id IN (&quot; + groupIds + &quot;)&quot;);</span>
<span class="fc" id="L4008">            ps.setInt(1, templateId);</span>
<span class="fc" id="L4009">            ps.execute();</span>
<span class="nc" id="L4010">        } catch (Exception ex) {</span>
<span class="nc" id="L4011">            sk.iway.iwcm.Logger.error(ex);</span>
        } finally {
            try {
<span class="pc bpc" id="L4014" title="1 of 2 branches missed.">                if (ps != null)</span>
<span class="fc" id="L4015">                    ps.close();</span>
<span class="pc bpc" id="L4016" title="1 of 2 branches missed.">                if (db_conn != null)</span>
<span class="fc" id="L4017">                    db_conn.close();</span>
<span class="nc" id="L4018">            } catch (Exception ex) {</span>
<span class="nc" id="L4019">                sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L4020">            }</span>
        }
<span class="fc" id="L4022">    }</span>

    /**
     * nastav zobrazenie pre podstranky
     * @param parentGroupId
     * @param loggedMenuTypeSubdocs
     */
    public void setMenuVisibilityToSubpages(int parentGroupId, String loggedMenuTypeSubdocs) {
<span class="nc" id="L4030">        Connection db_conn = null;</span>
<span class="nc" id="L4031">        PreparedStatement ps = null;</span>

<span class="nc" id="L4033">        boolean allVisible = &quot;allVisible&quot;.equals(loggedMenuTypeSubdocs);</span>
<span class="nc bnc" id="L4034" title="All 2 branches missed.">        Adminlog.add(Adminlog.TYPE_GROUP, &quot;MenuVisibility: all dir documents set to &quot;+(!allVisible ? &quot;NOT&quot; : &quot;&quot;)+&quot; visible in menu&quot;, parentGroupId, -1);</span>
        try {
<span class="nc" id="L4036">			db_conn = DBPool.getConnection();</span>
<span class="nc" id="L4037">            ps = db_conn.prepareStatement(&quot;UPDATE documents SET show_in_menu=? WHERE group_id=?&quot;);</span>
<span class="nc" id="L4038">            ps.setBoolean(1, allVisible);</span>
<span class="nc" id="L4039">            ps.setInt(2,parentGroupId);</span>
<span class="nc" id="L4040">            ps.execute();</span>
<span class="nc" id="L4041">        } catch (Exception ex) {</span>
<span class="nc" id="L4042">            sk.iway.iwcm.Logger.error(ex);</span>
        } finally {
            try {
<span class="nc bnc" id="L4045" title="All 2 branches missed.">                if (ps != null)</span>
<span class="nc" id="L4046">                    ps.close();</span>
<span class="nc bnc" id="L4047" title="All 2 branches missed.">                if (db_conn != null)</span>
<span class="nc" id="L4048">                    db_conn.close();</span>
<span class="nc" id="L4049">            } catch (Exception ex) {</span>
<span class="nc" id="L4050">                sk.iway.iwcm.Logger.error(ex);</span>
<span class="nc" id="L4051">            }</span>
        }
<span class="nc" id="L4053">    }</span>

	/**
	 * Rekurzivne pregeneruje prioritu stranok a podadresarov.
	 * @param groupId
	 */
	public void regenerateSortPriority(int groupId) {

<span class="nc" id="L4061">		int priority = GroupsDB.getInstance().getGroup(groupId).getSortPriority();</span>

<span class="nc" id="L4063">    	List&lt;DocDetails&gt; docDetailsList = DocDB.getInstance().getDocByGroup(groupId, DocDB.ORDER_PRIORITY, true, 0, 0, false, false);</span>

<span class="nc bnc" id="L4065" title="All 2 branches missed.">		for (DocDetails docDetails : docDetailsList) {</span>
<span class="nc" id="L4066">			docDetails.setSortPriority(priority);</span>
<span class="nc" id="L4067">			priority += Constants.getInt(&quot;sortPriorityIncrementDoc&quot;);</span>
<span class="nc" id="L4068">			DocDB.saveDoc(docDetails);</span>
<span class="nc" id="L4069">		}</span>

<span class="nc" id="L4071">		List&lt;GroupDetails&gt; groupDetailsList = GroupsDB.getInstance().getGroups(groupId);</span>

<span class="nc" id="L4073">		priority = (int)Math.ceil(GroupsDB.getInstance().getGroup(groupId).getSortPriority()/10.0f) * 100;</span>

<span class="nc bnc" id="L4075" title="All 2 branches missed.">		for (GroupDetails groupDetails : groupDetailsList) {</span>
<span class="nc" id="L4076">			priority += Constants.getInt(&quot;sortPriorityIncrementGroup&quot;);</span>
<span class="nc" id="L4077">			groupDetails.setSortPriority(priority);</span>
<span class="nc" id="L4078">			GroupsDB.getInstance().setGroup(groupDetails);</span>
<span class="nc" id="L4079">			this.regenerateSortPriority(groupDetails.getGroupId());</span>
<span class="nc" id="L4080">		}</span>
<span class="nc" id="L4081">	}</span>

	/**
	 * Opravi poradie adresarov po presunuti zadaneho adresara cez drag&amp;drop v adresari (precisluje poradie nasledovnych adresarov)
	 * @param group
	 * @param position
	 */
	public void fixGroupSortOrder(GroupDetails group, int position)
	{
		//ziskaj pocet adresarov v tomto adresari, tie musime odpocitat
<span class="nc" id="L4091">		GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="nc" id="L4092">		List&lt;GroupDetails&gt; groupsList = groupsDB.getGroups(group.getParentGroupId());</span>
<span class="nc bnc" id="L4093" title="All 2 branches missed.">		if (position &lt; 0) position = 0;</span>

		//v adresari nic nie je, nemusime menit sort priority
<span class="nc bnc" id="L4096" title="All 2 branches missed.">		if (groupsList.size()==0) return;</span>

<span class="nc" id="L4098">		StringBuilder updateSortOrderList = null;</span>
<span class="nc" id="L4099">		int maxSortPriority = 0;</span>
<span class="nc bnc" id="L4100" title="All 2 branches missed.">		for (GroupDetails g : groupsList)</span>
		{
<span class="nc" id="L4102">			maxSortPriority = g.getSortPriority();</span>

<span class="nc bnc" id="L4104" title="All 2 branches missed.">			if (g.getGroupId() == group.getGroupId())</span>
			{
				//netreba nic menit
<span class="nc" id="L4107">				Logger.debug(GroupsDB.class, &quot;fixGroupSortOrder, ZHODA groupID, position=&quot;+position);</span>
<span class="nc bnc" id="L4108" title="All 2 branches missed.">				if (position == 0) return;</span>
				continue;
			}

<span class="nc" id="L4112">			position--;</span>

<span class="nc" id="L4114">			Logger.debug(GroupsDB.class, &quot;fixGroupSortOrder, group=&quot;+g.getGroupName()+&quot; &quot;+g.getGroupId()+&quot; position=&quot;+position);</span>

<span class="nc bnc" id="L4116" title="All 2 branches missed.">			if (position == -1)</span>
			{
<span class="nc" id="L4118">				Logger.debug(GroupsDB.class, &quot;fixGroupSortOrder, position==-1, setting priority: &quot;+g.getSortPriority());</span>
<span class="nc" id="L4119">				group.setSortPriority(g.getSortPriority());</span>
			}
<span class="nc bnc" id="L4121" title="All 2 branches missed.">			if (position &lt; 0)</span>
			{
<span class="nc bnc" id="L4123" title="All 2 branches missed.">				if (updateSortOrderList == null) updateSortOrderList = new StringBuilder(String.valueOf(g.getGroupId()));</span>
<span class="nc" id="L4124">				else updateSortOrderList.append(&quot;,&quot;).append(String.valueOf(g.getGroupId()));</span>

				//update cache hodnoty
<span class="nc" id="L4127">				g.setSortPriority(g.getSortPriority() + 10);</span>
<span class="nc" id="L4128">				setGroup(g);</span>
			}

<span class="nc" id="L4131">			Logger.debug(GroupsDB.class, &quot;fixGroupSortOrder, toUpdate=&quot;+updateSortOrderList);</span>
<span class="nc" id="L4132">		}</span>

<span class="nc bnc" id="L4134" title="All 2 branches missed.">		if (updateSortOrderList == null)</span>
		{
<span class="nc" id="L4136">			Logger.debug(GroupsDB.class, &quot;updateSortOrderList, updatujem self, maxSortPriority=&quot;+maxSortPriority);</span>
<span class="nc" id="L4137">			group.setSortPriority(maxSortPriority + 10);</span>
		}
<span class="nc" id="L4139">	}</span>

	/**
	 * Cached list of parentGroups
	 *
	 * @param groupId
	 * @return
	 */
	public static List&lt;GroupDetails&gt; getParentGroupsCached(int groupId)
	{
<span class="fc" id="L4149">		final String CACHE_KEY =  &quot;GroupsDB.getListParentGroups(&quot;+groupId+&quot;)&quot;;</span>
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L4151">		List&lt;GroupDetails&gt; listParentGroups = (List&lt;GroupDetails&gt;) Cache.getInstance().getObject(CACHE_KEY);</span>
<span class="fc bfc" id="L4152" title="All 2 branches covered.">		if(listParentGroups == null)</span>
		{
<span class="fc" id="L4154">			listParentGroups = GroupsDB.getInstance().getParentGroups(groupId);</span>
<span class="fc" id="L4155">			Cache.getInstance().setObject(CACHE_KEY, listParentGroups, Constants.getInt(&quot;GroupsDB.parentGroupsCacheMinutes&quot;, 10));</span>
		}
<span class="fc" id="L4157">		return listParentGroups;</span>
	}

	/**
	 * Returns GroupDetails of /System/Trash folder, for multidomain returns domain specific Trash folder
	 * @return
	 */
	public GroupDetails getTrashGroup() {
		//tu sa vytvara adresar podla default jazyka, nie podla prihlaseneho pouzivatela!
<span class="fc" id="L4166">		Prop propSystem = Prop.getInstance(Constants.getString(&quot;defaultLanguage&quot;));</span>
<span class="fc" id="L4167">		String trashDirName = propSystem.getText(&quot;config.trash_dir&quot;);</span>
<span class="fc" id="L4168">		GroupDetails trashGroupDetails = getCreateGroup(trashDirName);</span>
<span class="fc" id="L4169">		return trashGroupDetails;</span>
	}

	/**
	 * Check if group is in trash
	 * @param groupId
	 * @return
	 */
	public boolean isInTrash(int groupId) {
<span class="fc" id="L4178">		String path = getPath(groupId);</span>
<span class="fc" id="L4179">		GroupDetails group = getGroup(groupId);</span>
<span class="pc bpc" id="L4180" title="1 of 2 branches missed.">		if (group == null) return true;</span>

		//do not use getTrashGroup() here because it needs Request/Request bean to create missing trash group in domain folder
<span class="fc" id="L4183">		Prop propSystem = Prop.getInstance(Constants.getString(&quot;defaultLanguage&quot;));</span>
<span class="fc" id="L4184">		String trashDirName = propSystem.getText(&quot;config.trash_dir&quot;);</span>

<span class="fc" id="L4186">		boolean isInTrash =</span>
<span class="fc" id="L4187">			DB.internationalToEnglish(path).toLowerCase().startsWith(DB.internationalToEnglish(trashDirName).toLowerCase());</span>

<span class="fc" id="L4189">		return isInTrash;</span>
	}

	/**
	 * Expand domainId to root groups to use in SQL query WHERE root_group_l1 IN (...)
	 * @param domainId
	 * @return
	 */
	public String expandRootGroupL1(int domainId) {
<span class="fc" id="L4198">		GroupDetails rootGroup = getGroup(domainId);</span>
<span class="pc bpc" id="L4199" title="1 of 2 branches missed.">		if (rootGroup == null) return &quot;&quot;+domainId;</span>
<span class="fc" id="L4200">		String domainName = rootGroup.getDomainName();</span>
<span class="fc" id="L4201">		List&lt;GroupDetails&gt; rootGroups = getRootGroups();</span>
<span class="fc" id="L4202">		StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L4203" title="All 2 branches covered.">		for (GroupDetails group : rootGroups) {</span>
<span class="pc bpc" id="L4204" title="1 of 4 branches missed.">			if (Tools.isEmpty(domainName) || domainName.equals(group.getDomainName())) {</span>
<span class="fc bfc" id="L4205" title="All 2 branches covered.">				if (sb.isEmpty()==false) sb.append(&quot;,&quot;);</span>
<span class="fc" id="L4206">				sb.append(group.getGroupId());</span>
			}
<span class="fc" id="L4208">		}</span>
<span class="fc" id="L4209">		return sb.toString();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>