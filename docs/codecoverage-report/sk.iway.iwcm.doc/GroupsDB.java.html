<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="sk"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GroupsDB.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">webjet8v9</a> &gt; <a href="index.source.html" class="el_package">sk.iway.iwcm.doc</a> &gt; <span class="el_source">GroupsDB.java</span></div><h1>GroupsDB.java</h1><pre class="source lang-java linenums">package sk.iway.iwcm.doc;

import org.apache.commons.beanutils.BeanUtils;
import org.apache.struts.util.ResponseUtils;

import sk.iway.iwcm.*;
import sk.iway.iwcm.common.CloudToolsForCore;
import sk.iway.iwcm.common.FilePathTools;
import sk.iway.iwcm.common.UserTools;
import sk.iway.iwcm.database.ComplexQuery;
import sk.iway.iwcm.database.Mapper;
import sk.iway.iwcm.database.SimpleQuery;
import sk.iway.iwcm.editor.service.GroupsService;
import sk.iway.iwcm.helpers.BeanDiff;
import sk.iway.iwcm.helpers.BeanDiffPrinter;
import sk.iway.iwcm.i18n.Prop;
import sk.iway.iwcm.io.IwcmFile;
import sk.iway.iwcm.system.cluster.ClusterDB;
import sk.iway.iwcm.system.spring.events.WebjetEvent;
import sk.iway.iwcm.system.spring.events.WebjetEventType;
import sk.iway.iwcm.users.UserDetails;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

import static sk.iway.iwcm.Tools.isEmpty;

/**
 *  Drzi obsah tabulky groups
 *
 *@Title        Interway Content Management
 *@Company      Interway s.r.o. (www.interway.sk)
 *@Copyright    Interway s.r.o. (c) 2001-2002
 *@author       $Author: jeeff $
 *@version      $Revision: 1.18 $
 *@created      $Date: 2004/03/25 17:36:09 $
 *@modified     $Date: 2004/03/25 17:36:09 $
 */
@SuppressWarnings({&quot;java:S6905&quot;})
public class GroupsDB extends DB
{

	private List&lt;GroupDetails&gt; groups;
	//cache pre zobrazenie stromovej struktury stranok (pri velkych sidlach sa to dlho a zbytocne nacitavalo dookola)
<span class="fc" id="L51">	private List&lt;GroupDetails&gt; groupsTreeAllCache = null;</span>

	private Map&lt;Integer, GroupDetails&gt; idToGroups;
	private Map&lt;String,Integer&gt; domainIds;

	private final String serverName;

<span class="fc" id="L58">	public static final Comparator&lt;GroupDetails&gt; groupsDbSorter = new Comparator&lt;GroupDetails&gt;(){</span>
		@Override
		public int compare(GroupDetails group1, GroupDetails group2)
		{
<span class="fc bfc" id="L62" title="All 2 branches covered.">			return 	group1.getSortPriority() - group2.getSortPriority() != 0 ?</span>
<span class="fc" id="L63">						group1.getSortPriority() - group2.getSortPriority() :</span>
<span class="fc" id="L64">						group1.getGroupId() - group2.getGroupId();</span>
		}
	};

<span class="fc" id="L68">	public static final Comparator&lt;GroupDetails&gt; nameSorter = new Comparator&lt;GroupDetails&gt;()</span>
<span class="fc" id="L69">	{</span>
		@Override
		public int compare(GroupDetails group1, GroupDetails group2)
		{
<span class="nc" id="L73">			return Tools.slovakCollator.compare(group1.getGroupName(), group2.getGroupName());</span>
		}
	};


	/**
	 * vrati instanciu triedy
	 * @return
	 */
	public static GroupsDB getInstance()
	{
<span class="fc" id="L84">		return(getInstance(false));</span>
	}

	/**
	 * vrati instanciu triedy
	 * @param forceRefresh
	 * @return
	 */
	public static GroupsDB getInstance(boolean forceRefresh)
	{
<span class="fc" id="L94">		return(getInstance(Constants.getServletContext(), forceRefresh, &quot;iwcm&quot;)); //NOSONAR</span>
	}

	/**
	 *  Gets the instance attribute of the GroupsDB class
	 *
	 *@param  servletContext  Description of the Parameter
	 *@param  force_refresh   Description of the Parameter
	 *@param  serverName      Description of the Parameter
	 *@return                 The instance value
	 *@deprecated - pouzite verziu getInstance(boolean forceRefresh)
	 */
	@Deprecated
	public static GroupsDB getInstance(javax.servlet.ServletContext servletContext, boolean force_refresh, String serverName)
	{
		//try to get it from server space
<span class="fc bfc" id="L110" title="All 2 branches covered.">		if (force_refresh == false)</span>
		{
<span class="fc" id="L112">			GroupsDB groupsDB = ((GroupsDB) servletContext.getAttribute(Constants.A_GROUPS_DB));</span>
			//Logger.println(this,&quot;GroupsDB: getting from server space&quot;);
<span class="pc bpc" id="L114" title="1 of 4 branches missed.">			if (groupsDB != null &amp;&amp; groupsDB.groups!=null) // fix MBO: ak groups je null, zbehne force refresh</span>
			{
<span class="fc" id="L116">				return groupsDB;</span>
			}
		}
<span class="fc" id="L119">		synchronized (GroupsDB.class)</span>
		{
<span class="fc bfc" id="L121" title="All 2 branches covered.">			if (force_refresh)</span>
			{
<span class="fc" id="L123">				GroupsDB groupsDB = new GroupsDB(servletContext, serverName);</span>
				//	remove
<span class="fc" id="L125">				servletContext.removeAttribute(Constants.A_GROUPS_DB);</span>
				//save us to server space
<span class="fc" id="L127">				servletContext.setAttribute(Constants.A_GROUPS_DB, groupsDB);</span>

<span class="fc" id="L129">				return groupsDB;</span>
			}
			else
			{
<span class="fc" id="L133">				GroupsDB groupsDB = (GroupsDB) servletContext.getAttribute(Constants.A_GROUPS_DB);</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">				if (groupsDB == null)</span>
				{
<span class="fc" id="L136">					groupsDB = new GroupsDB(servletContext, serverName);</span>
					//	remove
<span class="fc" id="L138">					servletContext.removeAttribute(Constants.A_GROUPS_DB);</span>
					//save us to server space
<span class="fc" id="L140">					servletContext.setAttribute(Constants.A_GROUPS_DB, groupsDB);</span>

				}
<span class="fc" id="L143">				return groupsDB;</span>
			}
		}
	}

	/**
	 *  Constructor for the GroupsDB object
	 *
	 *@param  servletContext  Description of the Parameter
	 *@param  serverName      Description of the Parameter
	 */
	private GroupsDB(javax.servlet.ServletContext servletContext, String serverName)
<span class="fc" id="L155">	{</span>
<span class="fc" id="L156">		Logger.println(this,&quot;GroupsDB: constructor [&quot; + Constants.getInstallName()+&quot;]&quot;);</span>
<span class="fc" id="L157">		this.serverName = serverName;</span>

		try
		{
<span class="fc" id="L161">			reloadGroups();</span>
		}
<span class="nc" id="L163">		catch (Exception ex)</span>
		{
<span class="nc" id="L165">			sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L166">		}</span>

<span class="fc" id="L168">		ClusterDB.addRefresh(GroupsDB.class);</span>
<span class="fc" id="L169">		Cache.getInstance().removeObjectStartsWithName(&quot;GroupsDB.&quot;);</span>
<span class="fc" id="L170">	}</span>

	/**
	 *  Description of the Method
	 *
	 *@exception  Exception  Description of the Exception
	 */
	public void reloadGroups() throws Exception
	{
<span class="fc" id="L179">		DebugTimer dt = new DebugTimer(&quot;GroupsDB.reloadGroups&quot;);</span>

		//ak vieme predchadzajucu velkost, tak si ju vopred predalokujeme
<span class="fc" id="L182">		List&lt;GroupDetails&gt; groupsHolderWhileLoading = new CopyOnWriteArrayList&lt;&gt;(); //Collections.synchronizedList(new ArrayList&lt;&gt;(groups!=null?groups.size():300));</span>
		//ak existuje, tak si vopred predalokuj dost miesta pre kluce
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">		Map&lt;Integer, GroupDetails&gt; idToGroupsHolderWhileLoading = Collections.synchronizedMap(new HashMap&lt;Integer, GroupDetails&gt;(idToGroups!=null?idToGroups.size():300));</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">		Map&lt;String,GroupDetails&gt; domainIdsGroups = Collections.synchronizedMap(new HashMap&lt;String, GroupDetails&gt;(domainIds!=null?domainIds.size():100));</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">		Map&lt;String,Integer&gt; domainIdsHolderWhileLoading = Collections.synchronizedMap(new HashMap&lt;String, Integer&gt;(domainIds!=null?domainIds.size():100));</span>

<span class="fc" id="L188">		java.sql.Connection db_conn = null;</span>
<span class="fc" id="L189">		java.sql.PreparedStatement ps = null;</span>
<span class="fc" id="L190">		java.sql.ResultSet rs = null;</span>
		try
		{
<span class="fc" id="L193">			dt.diff(&quot;after objects&quot;);</span>

<span class="fc" id="L195">			db_conn = DBPool.getConnection(serverName);</span>
<span class="fc" id="L196">			String sql = &quot;SELECT * FROM groups ORDER BY sort_priority, group_name&quot;;</span>
<span class="fc" id="L197">			ps = db_conn.prepareStatement(sql);</span>
<span class="fc" id="L198">			rs = ps.executeQuery();</span>

<span class="fc" id="L200">			dt.diff(&quot;after rs&quot;);</span>

<span class="fc bfc" id="L202" title="All 2 branches covered.">			while (rs.next())</span>
			{
<span class="fc" id="L204">				GroupDetails group = fillFieldsByResultSet(rs);</span>

<span class="fc" id="L206">				groupsHolderWhileLoading.add(group);</span>
<span class="fc" id="L207">				idToGroupsHolderWhileLoading.put(group.getGroupId(), group);</span>
<span class="fc bfc" id="L208" title="All 4 branches covered.">				if(Tools.isNotEmpty(group.getDomainName()) &amp;&amp; group.getParentGroupId() == 0)</span>
				{
<span class="fc" id="L210">					GroupDetails domainGroup = domainIdsGroups.get(group.getDomainName());</span>
					//ako domainId bereme groupId, ktore ma najnizsie ID, aby sa prvo vytvoreny priecinok v domene zachoval
<span class="fc bfc" id="L212" title="All 4 branches covered.">					if (domainGroup==null || group.getGroupId()&lt;domainGroup.getGroupId())</span>
					{

<span class="fc" id="L215">						domainIdsGroups.put(group.getDomainName(), group);</span>
						//pomocou konf. premennej domainId-www.domena.sk je mozne nastavit fixne ID, napr. ak zmazeme povodny korenovy priecinok domeny
<span class="fc" id="L217">						int constantDomainId = Constants.getInt(&quot;domainId-&quot;+group.getDomainName());</span>
<span class="fc" id="L218">						int domainId = group.getGroupId();</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">						if (constantDomainId&gt;0) domainId = constantDomainId;</span>
<span class="fc" id="L220">						domainIdsHolderWhileLoading.put(group.getDomainName(), domainId);</span>
					}
				}
<span class="fc" id="L223">			}</span>
<span class="fc" id="L224">			rs.close();</span>
<span class="fc" id="L225">			ps.close();</span>
<span class="fc" id="L226">			db_conn.close();</span>
<span class="fc" id="L227">			db_conn = null;</span>
<span class="fc" id="L228">			ps = null;</span>
<span class="fc" id="L229">			rs = null;</span>

<span class="fc" id="L231">			groups = groupsHolderWhileLoading;</span>
<span class="fc" id="L232">			idToGroups = idToGroupsHolderWhileLoading;</span>
<span class="fc" id="L233">			domainIds = domainIdsHolderWhileLoading;</span>

<span class="fc" id="L235">			dt.diff(&quot;after db load&quot;);</span>

			//nastav full path
<span class="fc bfc" id="L238" title="All 2 branches covered.">			for (GroupDetails group : groups)</span>
			{
<span class="fc" id="L240">				group.setFullPath(getPath(group.getGroupId()));</span>
<span class="fc" id="L241">			}</span>

<span class="fc" id="L243">			dt.diff(&quot;after full path&quot;);</span>

<span class="fc" id="L245">			getAllSystemFolders(true);</span>

<span class="fc" id="L247">			dt.diff(&quot;after system folders&quot;);</span>
		}
<span class="nc" id="L249">		catch (Exception ex){sk.iway.iwcm.Logger.error(ex);}</span>
		finally{
			try{
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">				if (rs != null) rs.close();</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">				if (ps != null) ps.close();</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">				if (db_conn != null) db_conn.close();</span>
<span class="pc" id="L255">			}catch (Exception e) {sk.iway.iwcm.Logger.error(e);}</span>
		}

<span class="fc" id="L258">		dt.diff(&quot;done&quot;);</span>
<span class="fc" id="L259">	}</span>

	/**
	 * Naplni objekt z result setu
	 * @param rs
	 * @return
	 * @throws SQLException
	 */
	public static GroupDetails fillFieldsByResultSet(java.sql.ResultSet rs) throws SQLException
	{
		GroupDetails group;
<span class="fc" id="L270">		group = new GroupDetails();</span>
<span class="fc" id="L271">		group.setGroupId(rs.getInt(&quot;group_id&quot;));</span>
<span class="fc" id="L272">		group.setGroupName(getDbString(rs, &quot;group_name&quot;));</span>
<span class="fc" id="L273">		group.setInternal(rs.getBoolean(&quot;internal&quot;));</span>
<span class="fc" id="L274">		group.setParentGroupId(rs.getInt(&quot;parent_group_id&quot;));</span>
<span class="fc" id="L275">		group.setNavbar(getDbString(rs, &quot;navbar&quot;));</span>
<span class="fc" id="L276">		group.setDefaultDocId(rs.getInt(&quot;default_doc_id&quot;));</span>
<span class="fc" id="L277">		group.setTempId(rs.getInt(&quot;temp_id&quot;));</span>
<span class="fc" id="L278">		group.setSortPriority(rs.getInt(&quot;sort_priority&quot;));</span>
<span class="fc" id="L279">		group.setPasswordProtected(getDbString(rs, &quot;password_protected&quot;));</span>
<span class="fc" id="L280">		group.setMenuType(rs.getInt(&quot;menu_type&quot;));</span>
<span class="fc" id="L281">		group.setUrlDirName(getDbString(rs, &quot;url_dir_name&quot;));</span>
<span class="fc" id="L282">		group.setSyncId(rs.getInt(&quot;sync_id&quot;));</span>
<span class="fc" id="L283">		group.setSyncStatus(rs.getInt(&quot;sync_status&quot;));</span>
<span class="fc" id="L284">		group.setHtmlHead(DB.getDbString(rs, &quot;html_head&quot;));</span>
<span class="fc" id="L285">		group.setLogonPageDocId(rs.getInt(&quot;logon_page_doc_id&quot;));</span>

		//	domain_name, new_page_docid_template, install_name, field_a, field_b, field_c, field_d
<span class="fc" id="L288">		group.setDomainName(DB.getDbString(rs, &quot;domain_name&quot;));</span>
<span class="fc" id="L289">		group.setNewPageDocIdTemplate(rs.getInt(&quot;new_page_docid_template&quot;));</span>
<span class="fc" id="L290">		group.setInstallName(DB.getDbString(rs, &quot;install_name&quot;));</span>
<span class="fc" id="L291">		group.setFieldA(DB.getDbString(rs, &quot;field_a&quot;));</span>
<span class="fc" id="L292">		group.setFieldB(DB.getDbString(rs, &quot;field_b&quot;));</span>
<span class="fc" id="L293">		group.setFieldC(DB.getDbString(rs, &quot;field_c&quot;));</span>
<span class="fc" id="L294">		group.setFieldD(DB.getDbString(rs, &quot;field_d&quot;));</span>

<span class="fc" id="L296">		group.setLoggedMenuType(rs.getInt(&quot;logged_menu_type&quot;));</span>
<span class="fc" id="L297">		group.setLinkGroupId(rs.getInt(&quot;link_group_id&quot;));</span>
<span class="fc" id="L298">		group.setLng(rs.getString(&quot;lng&quot;));</span>
<span class="fc" id="L299">		group.setHiddenInAdmin(rs.getBoolean(&quot;hidden_in_admin&quot;));</span>
<span class="fc" id="L300">		group.setForceTheUseOfGroupTemplate(rs.getBoolean(&quot;force_group_template&quot;));</span>

<span class="fc" id="L302">		DataAccessHelper.groupLoadData(rs, group);</span>

<span class="fc" id="L304">		return group;</span>
	}


	/**
	 * Naplni objekt GroupSchedulerDetails z result setu
	 * @param rs
	 * @return
	 * @throws SQLException
	 */
	public static GroupSchedulerDetails fillFieldsByResultSetFromScheduler(java.sql.ResultSet rs) throws SQLException
	{
		GroupSchedulerDetails groupScheduler;
<span class="nc" id="L317">		groupScheduler = new GroupSchedulerDetails();</span>
<span class="nc" id="L318">		groupScheduler.setGroupId(rs.getInt(&quot;group_id&quot;));</span>
<span class="nc" id="L319">		groupScheduler.setGroupName(getDbString(rs, &quot;group_name&quot;));</span>
<span class="nc" id="L320">		groupScheduler.setInternal(rs.getBoolean(&quot;internal&quot;));</span>
<span class="nc" id="L321">		groupScheduler.setParentGroupId(rs.getInt(&quot;parent_group_id&quot;));</span>
<span class="nc" id="L322">		groupScheduler.setNavbar(getDbString(rs, &quot;navbar&quot;));</span>
<span class="nc" id="L323">		groupScheduler.setDefaultDocId(rs.getInt(&quot;default_doc_id&quot;));</span>
<span class="nc" id="L324">		groupScheduler.setTempId(rs.getInt(&quot;temp_id&quot;));</span>
<span class="nc" id="L325">		groupScheduler.setSortPriority(rs.getInt(&quot;sort_priority&quot;));</span>
<span class="nc" id="L326">		groupScheduler.setPasswordProtected(getDbString(rs, &quot;password_protected&quot;));</span>
<span class="nc" id="L327">		groupScheduler.setMenuType(rs.getInt(&quot;menu_type&quot;));</span>
<span class="nc" id="L328">		groupScheduler.setUrlDirName(getDbString(rs, &quot;url_dir_name&quot;));</span>
<span class="nc" id="L329">		groupScheduler.setSyncId(rs.getInt(&quot;sync_id&quot;));</span>
<span class="nc" id="L330">		groupScheduler.setSyncStatus(rs.getInt(&quot;sync_status&quot;));</span>
<span class="nc" id="L331">		groupScheduler.setHtmlHead(DB.getDbString(rs, &quot;html_head&quot;));</span>
<span class="nc" id="L332">		groupScheduler.setLogonPageDocId(rs.getInt(&quot;logon_page_doc_id&quot;));</span>

		//	domain_name, new_page_docid_template, install_name, field_a, field_b, field_c, field_d
<span class="nc" id="L335">		groupScheduler.setDomainName(DB.getDbString(rs, &quot;domain_name&quot;));</span>
<span class="nc" id="L336">		groupScheduler.setNewPageDocIdTemplate(rs.getInt(&quot;new_page_docid_template&quot;));</span>
<span class="nc" id="L337">		groupScheduler.setInstallName(DB.getDbString(rs, &quot;install_name&quot;));</span>
<span class="nc" id="L338">		groupScheduler.setFieldA(DB.getDbString(rs, &quot;field_a&quot;));</span>
<span class="nc" id="L339">		groupScheduler.setFieldB(DB.getDbString(rs, &quot;field_b&quot;));</span>
<span class="nc" id="L340">		groupScheduler.setFieldC(DB.getDbString(rs, &quot;field_c&quot;));</span>
<span class="nc" id="L341">		groupScheduler.setFieldD(DB.getDbString(rs, &quot;field_d&quot;));</span>

<span class="nc" id="L343">		groupScheduler.setLoggedMenuType(rs.getInt(&quot;logged_menu_type&quot;));</span>
<span class="nc" id="L344">		groupScheduler.setLinkGroupId(rs.getInt(&quot;link_group_id&quot;));</span>

		//groupScheduler
<span class="nc" id="L347">		groupScheduler.setUserId(rs.getInt(&quot;user_id&quot;));</span>
<span class="nc" id="L348">		groupScheduler.setSaveDate(rs.getTimestamp(&quot;save_date&quot;));</span>
<span class="nc" id="L349">		groupScheduler.setScheduleId(rs.getInt(&quot;schedule_id&quot;));</span>
<span class="nc" id="L350">		groupScheduler.setWhenToPublish(rs.getTimestamp(&quot;when_to_publish&quot;));</span>

<span class="nc" id="L352">		groupScheduler.setLng(rs.getString(&quot;lng&quot;));</span>
<span class="nc" id="L353">		groupScheduler.setHiddenInAdmin(rs.getBoolean(&quot;hidden_in_admin&quot;));</span>
<span class="nc" id="L354">		groupScheduler.setForceTheUseOfGroupTemplate(rs.getBoolean(&quot;force_group_template&quot;));</span>

<span class="nc" id="L356">		DataAccessHelper.groupLoadData(rs, groupScheduler);</span>

<span class="nc" id="L358">		return groupScheduler;</span>
	}

	/**
	 *  Vrati zoznam skupin v danej skupine
	 *
	 *@param  parent  Description of the Parameter
	 *@return         The groups value
	 */
	public List&lt;GroupDetails&gt; getGroups(int parent)
	{
<span class="fc" id="L369">		List&lt;GroupDetails&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">		for (GroupDetails group : groups)</span>
		{
<span class="fc bfc" id="L372" title="All 2 branches covered.">			if (group.getParentGroupId() == parent)</span>
			{
<span class="fc" id="L374">				ret.add(group);</span>
			}
<span class="fc" id="L376">		}</span>
<span class="fc" id="L377">		return (ret);</span>
	}

	/**
	 * Vrati zoznam skupin v danej skupine dostupnych v menu
	 * @param parent
	 * @return
	 */
	public List&lt;GroupDetails&gt; getGroupsAvailableInMenu(int parent)
	{
<span class="nc" id="L387">		return getGroupsAvailableInMenu(parent, null);</span>
	}

	 /**
	  * Vrati zoznam skupin v danej skupine dostupnych v menu, testuje menuType pre prihlaseneho usera
	  * @param parent
	  * @param session
	  * @return
	  */
	 public List&lt;GroupDetails&gt; getGroupsAvailableInMenu(int parent, HttpSession session)
	 {
<span class="nc" id="L398">		  List&lt;GroupDetails&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">		 for (GroupDetails group : groups)</span>
		  {
<span class="nc bnc" id="L401" title="All 6 branches missed.">				if (group.getParentGroupId() == parent &amp;&amp; group.isInternal()==false &amp;&amp; group.getMenuType(session)!=GroupDetails.MENU_TYPE_HIDDEN)</span>
				{
<span class="nc" id="L403">					 ret.add(group);</span>
				}
<span class="nc" id="L405">		  }</span>
<span class="nc" id="L406">		  return (ret);</span>
	 }

	/**
	 *  Vrati GroupDetails so zadanym ID
	 *
	 *@param  group_id - id adresara
	 *@return           The group value
	 */
	public GroupDetails getGroup(int group_id)
	{
<span class="fc" id="L417">		return idToGroups.get(group_id);</span>
	}

	/**
	 * Ziska adresar podla zadanej full path
	 * @param fullPath
	 * @return
	 */
	public GroupDetails getGroupByPath(String fullPath)
	{
<span class="pc bpc" id="L427" title="3 of 4 branches missed.">		if (fullPath.endsWith(&quot;/&quot;) &amp;&amp; fullPath.length()&gt;1)</span>
		{
			//odstran koncove lomitko
<span class="nc" id="L430">			fullPath = fullPath.substring(0, fullPath.length()-1);</span>
		}

<span class="fc" id="L433">		RequestBean rb = SetCharacterEncodingFilter.getCurrentRequestBean();</span>
<span class="fc" id="L434">		GroupDetails firstGroup = null;</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">		for (GroupDetails group : getGroupsAll())</span>
		{
<span class="fc bfc" id="L437" title="All 2 branches covered.">			if (group.getFullPath().equals(fullPath))</span>
			{
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">				if (firstGroup == null) firstGroup = group;</span>
<span class="pc bpc" id="L440" title="3 of 6 branches missed.">				if (rb != null &amp;&amp; Tools.isNotEmpty(rb.getDomain()) &amp;&amp; Constants.getBoolean(&quot;multiDomainEnabled&quot;)==true) {</span>
					//mame presnu zhodu aj podla domenoveho mena
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">					if (rb.getDomain().equals(group.getDomainName())) return group;</span>
				}
			}
<span class="fc" id="L445">		}</span>
<span class="fc" id="L446">		return firstGroup;</span>
	}



	/**
	 *  Gets the group attribute of the GroupsDB object
	 *
	 *@param  groupName  Description of the Parameter
	 *@return           The group value
	 */
	public GroupDetails getGroup(String groupName)
	{
<span class="nc" id="L459">		return getGroup(groupName,false);</span>
	}

	/**
	 *  Gets the group attribute of the GroupsDB object
	 *
	 *@param  groupName  Description of the Parameter
	 *@param internationalToEnglish ci sa maju nazvy adresarov upravit z international do english
	 *@return           The group value
	 */
	public GroupDetails getGroup(String groupName, boolean internationalToEnglish)
	{
<span class="nc" id="L471">		groupName = sanitizeGroupName(groupName, true);</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">		if (Tools.isNotEmpty(groupName))</span>
		{
<span class="nc bnc" id="L474" title="All 2 branches missed.">			for (GroupDetails group : getGroupsAll())</span>
			{
<span class="nc bnc" id="L476" title="All 2 branches missed.">				if(internationalToEnglish)</span>
				{
<span class="nc bnc" id="L478" title="All 2 branches missed.">					if (DB.internationalToEnglish(groupName).equalsIgnoreCase(DB.internationalToEnglish(group.getGroupName())))</span>
					{
<span class="nc" id="L480">						return (group);</span>
					}
				}
				else
				{
<span class="nc bnc" id="L485" title="All 2 branches missed.">					if (groupName.equalsIgnoreCase(group.getGroupName()))</span>
					{
<span class="nc" id="L487">						return (group);</span>
					}
				}
<span class="nc" id="L490">			}</span>
		}
<span class="nc" id="L492">		return (null);</span>
	}

	/**
	 * Ziska adresar so zadanym menom v zadanom adresari
	 * @param groupName
	 * @param parentGroupId
	 * @return
	 */
	public GroupDetails getGroup(String groupName, int parentGroupId)
	{
<span class="fc" id="L503">		GroupDetails firstGroup = null;</span>
<span class="fc" id="L504">		RequestBean rb = SetCharacterEncodingFilter.getCurrentRequestBean();</span>
<span class="fc" id="L505">		groupName = sanitizeGroupName(groupName, true);</span>
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">		if (Tools.isNotEmpty(groupName))</span>
		{
<span class="fc bfc" id="L508" title="All 2 branches covered.">			for (GroupDetails group : getGroupsAll())</span>
			{
<span class="fc bfc" id="L510" title="All 4 branches covered.">				if (group.getParentGroupId() == parentGroupId &amp;&amp; groupName.equalsIgnoreCase(group.getGroupName()))</span>
				{
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">					if (firstGroup==null) firstGroup = group;</span>
<span class="pc bpc" id="L513" title="3 of 6 branches missed.">					if (rb != null &amp;&amp; Tools.isNotEmpty(rb.getDomain()) &amp;&amp; Constants.getBoolean(&quot;multiDomainEnabled&quot;)==true) {</span>
						//mame presnu zhodu aj podla domenoveho mena
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">						if (rb.getDomain().equals(group.getDomainName())) return group;</span>
					}
				}
<span class="fc" id="L518">			}</span>
		}
<span class="fc" id="L520">		return (firstGroup);</span>
	}

	 /**
	  * Ziska adresar so zadanym menom v zadanom adresari, ak neexistuje tak ho vytvori
	  * @param groupName
	  * @param parentGroupId
	  * @return
	  */
	public GroupDetails getOrCreateGroup(String groupName, int parentGroupId)
	{
<span class="nc" id="L531">		 GroupDetails group = getGroup(groupName, parentGroupId);</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">		 if (group == null) {</span>
<span class="nc" id="L533">			  group = addNewGroup(groupName, parentGroupId);</span>
		 }
<span class="nc" id="L535">		 return group;</span>
	}


	/**
	 *  Ziska stromovu strukturu adresarov
	 *
	 *@return    The groupsTree value
	 */
	public List&lt;GroupDetails&gt; getGroupsTree()
	{
<span class="nc" id="L546">		List&lt;GroupDetails&gt; p_groups = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L547">		getGroupsTree(0, p_groups, true);</span>
<span class="nc" id="L548">		return (p_groups);</span>
	}

	/**
	 * Ziska stromovu strukturu adresarov iba pre userom editovatelne adresare
	 * @param editableGroups
	 * @return
	 */
	public List&lt;GroupDetails&gt; getGroupsTree(String editableGroups)
	{
		//cache pre groupslist-tree.jsp
<span class="pc bpc" id="L559" title="2 of 4 branches missed.">		if (Tools.isEmpty(editableGroups) &amp;&amp; groupsTreeAllCache!=null)</span>
		{
<span class="nc" id="L561">			Logger.debug(GroupsDB.class, &quot;getGroupsTree - returning from cache&quot;);</span>
<span class="nc" id="L562">			List&lt;GroupDetails&gt; cloned = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L563">			cloned.addAll(groupsTreeAllCache);</span>
<span class="nc" id="L564">			return cloned;</span>
		}

<span class="fc" id="L567">		List&lt;GroupDetails&gt; p_groups = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L569" title="2 of 4 branches missed.">		if (editableGroups != null &amp;&amp; editableGroups.length() &gt; 0)</span>
		{
<span class="nc" id="L571">			StringTokenizer st = new StringTokenizer(editableGroups, &quot;,&quot;);</span>
			String id;
			int i_id;
<span class="nc bnc" id="L574" title="All 2 branches missed.">			while (st.hasMoreTokens())</span>
			{
<span class="nc" id="L576">				id = st.nextToken().trim();</span>
				try
				{
<span class="nc" id="L579">					i_id = Integer.parseInt(id);</span>
					//pridaj to do stromu editovatelnych stranok
<span class="nc" id="L581">					GroupDetails parentGroup = findGroup(i_id);</span>
<span class="nc" id="L582">					GroupDetails parentGroupCopy = new GroupDetails(parentGroup);</span>
<span class="nc" id="L583">					parentGroupCopy.setParentGroupId(0);</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">					if (parentGroup.getFullPath().length() &gt; 200)</span>
					{
<span class="nc" id="L586">						parentGroupCopy.setGroupName(&quot;...&quot;+parentGroup.getFullPath().substring(parentGroup.getFullPath().length()-198));</span>
					}
					else
					{
<span class="nc" id="L590">						parentGroupCopy.setGroupName(parentGroup.getFullPath());</span>
					}
<span class="nc" id="L592">					p_groups.add(parentGroupCopy);</span>
<span class="nc" id="L593">					getGroupsTree(i_id, p_groups, true);</span>
				}
<span class="nc" id="L595">				catch (Exception ex)</span>
				{

<span class="nc" id="L598">				}</span>
			}
<span class="nc" id="L600">		}</span>
		else
		{
<span class="fc" id="L603">			getGroupsTree(0, p_groups, true);</span>

<span class="pc bpc" id="L605" title="1 of 2 branches missed.">			if (Tools.isEmpty(editableGroups))</span>
			{
<span class="fc" id="L607">				groupsTreeAllCache = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L608">				groupsTreeAllCache.addAll(p_groups);</span>
<span class="fc" id="L609">				Logger.debug(GroupsDB.class, &quot;getGroupsTree - SETTING cache&quot;);</span>
			}
		}

<span class="fc" id="L613">		return (p_groups);</span>
	}


	/**
	 *  Ziska stromovu strukturu adresarov
	 *
	 *@param  parent          rodicovsky adresar
	 *@param  includeParent  ak true, vratane rodica
	 *@param  includeInternals ak true, vratane internych adresarov
	 *@return                 The groupsTree value
	 */
	public List&lt;GroupDetails&gt; getGroupsTree(int parent, boolean includeParent, boolean includeInternals)
	{
<span class="fc" id="L627">		return getGroupsTree(parent, includeParent, includeInternals, false);</span>
	}

	/**
	 * Ziska stromovu strukturu adresarov
	 * @param parent -  rodicovsky adresar
	 * @param includeParent - ak true, vratane rodica
	 * @param includeInternals - ak true, vratane internych adresarov
	 * @param onlyAvailableInMenu - ak true, iba dostupne v menu
	 * @return
	 */
	public List&lt;GroupDetails&gt; getGroupsTree(int parent, boolean includeParent, boolean includeInternals, boolean onlyAvailableInMenu)
	{
<span class="fc" id="L640">		List&lt;GroupDetails&gt; p_groups = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">		if (includeParent)</span>
		{
<span class="fc" id="L643">			GroupDetails parentGroup = findGroup(parent);</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">			if (parentGroup != null) p_groups.add(parentGroup);</span>
		}
<span class="fc" id="L646">		getGroupsTree(parent, p_groups, includeInternals, onlyAvailableInMenu);</span>
<span class="fc" id="L647">		return (p_groups);</span>
	}

	/**
	 * Ziska stromovu strukturu adresarov. Rekurzivna metoda!
	 * @param parent
	 * @param p_groups
	 */
	public void getGroupsTree(int parent, List&lt;GroupDetails&gt; p_groups)
	{
<span class="nc" id="L657">		getGroupsTree(parent, p_groups, true);</span>
<span class="nc" id="L658">	}</span>

	/**
	 *  Ziska stromovu strukturu adresarov. Rekurzivna metoda!
	 *
	 *@param  parent    rodicovsky adresar
	 *@param  p_groups  array list, do ktoreho sa to plni
	 *@param  includeInternals ak true, vratane internych adresarov
	 */
	public void getGroupsTree(int parent, List&lt;GroupDetails&gt; p_groups, boolean includeInternals)
	{
<span class="fc" id="L669">		getGroupsTree(parent, p_groups, includeInternals, false);</span>
<span class="fc" id="L670">	}</span>

	/**
	 *
	 * @param parent
	 * @param p_groups
	 * @param includeInternals
	 * @param onlyAvailableInMenu
	 */
	public void getGroupsTree(int parent, List&lt;GroupDetails&gt; p_groups, boolean includeInternals, boolean onlyAvailableInMenu)
	{
<span class="fc" id="L681">		Map&lt;Integer, List&lt;GroupDetails&gt;&gt; childsTable = prepareChildsTable();</span>
<span class="fc" id="L682">		getGroupsTree(childsTable, parent, p_groups, includeInternals, onlyAvailableInMenu, 1);</span>
<span class="fc" id="L683">	}</span>

	/**
	 * Pripravi hash tabulku kde klucom je groupId a hodnotou je zoznam childov
	 * @return
	 */
	private Map&lt;Integer, List&lt;GroupDetails&gt;&gt; prepareChildsTable()
	{
<span class="fc" id="L691">		Map&lt;Integer, List&lt;GroupDetails&gt;&gt; childsTable = new Hashtable&lt;&gt;();</span>

<span class="fc bfc" id="L693" title="All 2 branches covered.">		for (GroupDetails group : groups)</span>
		{
<span class="fc" id="L695">			List&lt;GroupDetails&gt; childsList = childsTable.get(group.getParentGroupId());</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">			if (childsList == null)</span>
			{
<span class="fc" id="L698">				childsList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L699">				childsTable.put(group.getParentGroupId(), childsList);</span>
			}
<span class="fc" id="L701">			childsList.add(group);</span>
<span class="fc" id="L702">		}</span>

<span class="fc" id="L704">		return childsTable;</span>
	}

	/**
	 * Do listu p_groups rekurzivne naplni zoznam childov pre zadane parent group id
	 * @param childsTable
	 * @param parent
	 * @param p_groups
	 * @param includeInternals
	 * @param onlyAvailableInMenu
	 */
	private void getGroupsTree(Map&lt;Integer, List&lt;GroupDetails&gt;&gt; childsTable, int parent, List&lt;GroupDetails&gt; p_groups, boolean includeInternals, boolean onlyAvailableInMenu, int iteration)
	{
<span class="fc" id="L717">		List&lt;GroupDetails&gt; childs = childsTable.get(parent);</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">		if (childs == null) return;</span>

<span class="pc bpc" id="L720" title="1 of 2 branches missed.">		if (iteration &gt; 500) return;</span>

<span class="fc" id="L722">		GroupDetails system = null;</span>

<span class="fc bfc" id="L724" title="All 2 branches covered.">		for (GroupDetails group : childs)</span>
		{
<span class="pc bpc" id="L726" title="1 of 4 branches missed.">			if (includeInternals == false &amp;&amp; group.isInternal()) continue;</span>
<span class="pc bpc" id="L727" title="3 of 4 branches missed.">			if (onlyAvailableInMenu &amp;&amp; group.getMenuType()==GroupDetails.MENU_TYPE_HIDDEN) continue;</span>

<span class="pc bpc" id="L729" title="3 of 4 branches missed.">			if (&quot;cloud&quot;.equals(Constants.getInstallName()) &amp;&amp; &quot;System&quot;.equals(group.getGroupName()))</span>
			{
				//system grupu presunieme uplne na koniec
<span class="nc" id="L732">				system = group;</span>
<span class="nc" id="L733">				continue;</span>
			}

<span class="fc" id="L736">			p_groups.add(group);</span>

<span class="pc bpc" id="L738" title="3 of 4 branches missed.">			if (onlyAvailableInMenu &amp;&amp; group.getMenuType()==GroupDetails.MENU_TYPE_NOSUB) continue;</span>

			//recursive call
<span class="fc" id="L741">			getGroupsTree(childsTable, group.getGroupId(), p_groups, includeInternals, onlyAvailableInMenu, iteration);</span>
<span class="fc" id="L742">		}</span>

<span class="pc bpc" id="L744" title="1 of 2 branches missed.">		if (system != null)</span>
		{
<span class="nc" id="L746">			p_groups.add(system);</span>
<span class="nc bnc" id="L747" title="All 4 branches missed.">			if (onlyAvailableInMenu &amp;&amp; system.getMenuType()==GroupDetails.MENU_TYPE_NOSUB)</span>
			{
				//continue;
			}
			else
			{
				//recursive call
<span class="nc" id="L754">				getGroupsTree(childsTable, system.getGroupId(), p_groups, includeInternals, onlyAvailableInMenu, iteration);</span>
			}
		}
<span class="fc" id="L757">	}</span>

	/**
	 * Vytvori List parent adresarov pre rendering v select boxe namiesto standardneho vyberu, kazde meno adresara je odsadene medzerami aby bola zrozumitelna struktura
	 * @param parent
	 * @param includeParent
	 * @param includeInternals
	 * @param onlyAvailableInMenu
	 * @return
	 */
	public List&lt;LabelValueDetails&gt; getGroupsTreeForSelect(int parent, boolean includeParent, boolean includeInternals, boolean onlyAvailableInMenu)
	{
<span class="nc" id="L769">		List&lt;LabelValueDetails&gt; list = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L771">		int level = 0;</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">		if (includeParent)</span>
		{
<span class="nc" id="L774">			GroupDetails parentGroup = findGroup(parent);</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">			if (parentGroup != null) list.add(new LabelValueDetails(parentGroup.getGroupName(), String.valueOf(parentGroup.getGroupId())));</span>
<span class="nc" id="L776">			level++;</span>
		}

<span class="nc" id="L779">		Map&lt;Integer, List&lt;GroupDetails&gt;&gt; childsTable = prepareChildsTable();</span>
<span class="nc" id="L780">		getGroupsTreeForSelect(childsTable, parent, list, includeInternals, onlyAvailableInMenu, level);</span>

<span class="nc" id="L782">		return list;</span>
	}

	/**
	 * Vytvori List parent adresarov pre rendering v select boxe namiesto standardneho vyberu, kazde meno adresara je odsadene medzerami aby bola zrozumitelna struktura
	 * @param childsTable
	 * @param parent
	 * @param list
	 * @param includeInternals
	 * @param onlyAvailableInMenu
	 * @param level
	 */
	private void getGroupsTreeForSelect(Map&lt;Integer, List&lt;GroupDetails&gt;&gt; childsTable, int parent, List&lt;LabelValueDetails&gt; list, boolean includeInternals, boolean onlyAvailableInMenu, int level)
	{
<span class="nc" id="L796">		List&lt;GroupDetails&gt; childs = childsTable.get(parent);</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">		if (childs == null) return;</span>

<span class="nc" id="L799">		GroupDetails system = null;</span>

<span class="nc" id="L801">		StringBuilder spacer = new StringBuilder();</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">		for (int i=0; i&lt;level; i++)</span>
		{
<span class="nc" id="L804">			spacer.append(Constants.NON_BREAKING_SPACE);</span>
<span class="nc" id="L805">			spacer.append(Constants.NON_BREAKING_SPACE);</span>
<span class="nc" id="L806">			spacer.append(Constants.NON_BREAKING_SPACE);</span>
<span class="nc" id="L807">			spacer.append(Constants.NON_BREAKING_SPACE);</span>
<span class="nc" id="L808">			spacer.append(Constants.NON_BREAKING_SPACE);</span>
		}

<span class="nc bnc" id="L811" title="All 2 branches missed.">		for (GroupDetails group : childs)</span>
		{
<span class="nc bnc" id="L813" title="All 4 branches missed.">			if (includeInternals == false &amp;&amp; group.isInternal()) continue;</span>
<span class="nc bnc" id="L814" title="All 4 branches missed.">			if (onlyAvailableInMenu &amp;&amp; group.getMenuType()==GroupDetails.MENU_TYPE_HIDDEN) continue;</span>

<span class="nc bnc" id="L816" title="All 4 branches missed.">			if (&quot;cloud&quot;.equals(Constants.getInstallName()) &amp;&amp; &quot;System&quot;.equals(group.getGroupName()))</span>
			{
				//system grupu presunieme uplne na koniec
<span class="nc" id="L819">				system = group;</span>
<span class="nc" id="L820">				continue;</span>
			}

<span class="nc" id="L823">			list.add(new LabelValueDetails(spacer.toString()+group.getGroupName(), String.valueOf(group.getGroupId())));</span>

<span class="nc bnc" id="L825" title="All 4 branches missed.">			if (onlyAvailableInMenu &amp;&amp; group.getMenuType()==GroupDetails.MENU_TYPE_NOSUB) continue;</span>

			//recursive call
<span class="nc" id="L828">			getGroupsTreeForSelect(childsTable, group.getGroupId(), list, includeInternals, onlyAvailableInMenu, level+1);</span>
<span class="nc" id="L829">		}</span>

<span class="nc bnc" id="L831" title="All 2 branches missed.">		if (system != null)</span>
		{
<span class="nc" id="L833">			list.add(new LabelValueDetails(spacer.toString()+system.getGroupName(), String.valueOf(system.getGroupId())));</span>
<span class="nc bnc" id="L834" title="All 4 branches missed.">			if (onlyAvailableInMenu &amp;&amp; system.getMenuType()==GroupDetails.MENU_TYPE_NOSUB)</span>
			{
				//continue;
			}
			else
			{
				//recursive call
<span class="nc" id="L841">				getGroupsTreeForSelect(childsTable, system.getGroupId(), list, includeInternals, onlyAvailableInMenu, level+1);</span>
			}
		}
<span class="nc" id="L844">	}</span>

	/**
	 *  najde GroupDetails pre zadane groupId
	 *
	 *@param  groupId  Description of the Parameter
	 *@return          Description of the Return Value
	 */
	public GroupDetails findGroup(int groupId)
	{
<span class="fc" id="L854">		return getGroup(groupId);</span>
	}

	public static GroupDetails findGroup(List&lt;GroupDetails&gt; allGroups, int groupId)
	{
<span class="nc bnc" id="L859" title="All 2 branches missed.">		for (GroupDetails group : allGroups)</span>
		{
<span class="nc bnc" id="L861" title="All 2 branches missed.">			if (group.getGroupId() == groupId)</span>
			{
<span class="nc" id="L863">				return (group);</span>
			}
<span class="nc" id="L865">		}</span>
<span class="nc" id="L866">		return (null);</span>
	}

	/**
	 * Ulozenie adresara do databazy
	 * @param group
	 * @return
	 */
	public boolean save(GroupDetails group)
	{
<span class="fc" id="L876">		return setGroup(group);</span>
	}

	/**
	 * Ulozenie adresara do databazy
	 * @param group
	 * @return
	 */
	public boolean setGroup(GroupDetails group)
	{
<span class="fc" id="L886">		return setGroup(group, true);</span>
	}

	/**
	 * Ulozenie adresara, ak je nastavene doNotPublishEvents na true nie su vyvolane udalosti
	 * @param group
	 * @param publishEvents - ak je true, su vyvolane udalosti (false potrebne ak napr. reagujeme na udalost a potrebujeme znova upravit adresar a nechceme aby doslo k zacykleniu)
	 * @return
	 */
	public boolean setGroup(GroupDetails group, boolean publishEvents)
	{
<span class="fc bfc" id="L897" title="All 2 branches covered.">		if (publishEvents) (new WebjetEvent&lt;GroupDetails&gt;(group, WebjetEventType.ON_START)).publishEvent();</span>

<span class="pc bpc" id="L899" title="5 of 6 branches missed.">		if (InitServlet.isTypeCloud() &amp;&amp; group.getGroupId()&gt;0 &amp;&amp; Tools.isNotEmpty(group.getDomainName()))</span>
		{
			//kontrola prav
<span class="nc" id="L902">			GroupDetails oldGroup = getGroup(group.getGroupId());</span>
<span class="nc bnc" id="L903" title="All 4 branches missed.">			if (oldGroup == null || oldGroup.getDomainName().equals(CloudToolsForCore.getDomainName())==false)</span>
			{
<span class="nc" id="L905">				return false;</span>
			}
		}

<span class="fc" id="L909">		java.sql.Connection db_conn = null;</span>
<span class="fc" id="L910">		java.sql.PreparedStatement ps = null;</span>
<span class="fc" id="L911">		ResultSet rs = null;</span>
		try
		{
<span class="fc" id="L914">			GroupDetails newGroup = (GroupDetails)group.clone();	//Hlasilo CloneNotSupportedException</span>

<span class="pc bpc" id="L916" title="1 of 2 branches missed.">			if (InitServlet.isTypeCloud())</span>
			{
<span class="nc" id="L918">				newGroup.setDomainName(CloudToolsForCore.getDomainName());</span>

<span class="nc bnc" id="L920" title="All 2 branches missed.">				if (newGroup.getParentGroupId()&gt;1)</span>
				{
<span class="nc" id="L922">					GroupDetails parentGroup = getGroup(newGroup.getParentGroupId());</span>
<span class="nc bnc" id="L923" title="All 4 branches missed.">					if (parentGroup == null || parentGroup.getDomainName().equals(newGroup.getDomainName())==false)</span>
					{
<span class="nc" id="L925">						newGroup.setParentGroupId(CloudToolsForCore.getDomainId());</span>
					}
				}
			}

			//nahradim vyskyty &quot;/&quot; a &quot;\&quot; za &quot;-&quot;
<span class="fc" id="L931">			newGroup.setGroupName(Tools.replace(Tools.replace(newGroup.getGroupName(), &quot;\\&quot;, &quot;-&quot;), &quot;/&quot;, &quot;&amp;#47;&quot;));</span>
<span class="fc" id="L932">			newGroup.setNavbar(Tools.replace(Tools.replace(newGroup.getNavbarName(), &quot;\\&quot;, &quot;-&quot;), &quot;/&quot;, &quot;&amp;#47;&quot;));</span>

			//premenovanie nazvu hlavnej stranky Grupy, podla nazvu Grupy
<span class="fc bfc" id="L935" title="All 4 branches covered.">			if(newGroup.getDefaultDocId() &gt; 0 &amp;&amp; GroupsService.canSyncTitle(newGroup)) {</span>
<span class="fc" id="L936">				changeDocTitle(newGroup);</span>
<span class="fc" id="L937">				DocDB.getInstance(true);</span>
			}

<span class="fc" id="L940">			Logger.println(this,&quot;GroupsDB.setGroup: &quot; + newGroup.getGroupName());</span>

<span class="fc" id="L942">			String[] additionalFields = DataAccessHelper.getGroupFields();</span>
<span class="fc" id="L943">			StringBuilder addFieldsInsert = new StringBuilder();</span>
<span class="fc" id="L944">			StringBuilder addFieldsInsertParams = new StringBuilder();</span>
<span class="fc" id="L945">			StringBuilder addFieldsUpdate = new StringBuilder();</span>
<span class="pc bpc" id="L946" title="2 of 4 branches missed.">			if (additionalFields != null &amp;&amp; additionalFields.length&gt;0) {</span>
<span class="fc bfc" id="L947" title="All 2 branches covered.">				for (String field : additionalFields) {</span>
<span class="fc" id="L948">					addFieldsInsert.append(&quot;, &quot;).append(field);</span>
<span class="fc" id="L949">					addFieldsInsertParams.append(&quot;, ?&quot;);</span>
<span class="fc" id="L950">					addFieldsUpdate.append(&quot;, &quot;).append(field).append(&quot;=?&quot;);</span>
				}
			}

<span class="fc" id="L954">			String sql = &quot;INSERT INTO groups (group_name, internal, parent_group_id, navbar, default_doc_id, temp_id, sort_priority, password_protected, menu_type, url_dir_name, html_head, logon_page_doc_id, domain_name, new_page_docid_template, install_name, field_a, field_b, field_c, field_d, logged_menu_type, link_group_id, lng, hidden_in_admin, force_group_template&quot;+addFieldsInsert.toString()+&quot;) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?&quot;+addFieldsInsertParams.toString()+&quot;)&quot;;</span>
<span class="fc bfc" id="L955" title="All 2 branches covered.">			if (newGroup.getGroupId()&gt;0)</span>
			{
<span class="fc" id="L957">				sql = &quot;UPDATE groups SET group_name=?, internal=?, parent_group_id=?, navbar=?, default_doc_id=?, temp_id=?, sort_priority=?, password_protected=?, menu_type=?, url_dir_name=?, sync_status=1, html_head=?, logon_page_doc_id=?, domain_name=?, new_page_docid_template=?, install_name=?, field_a=?, field_b=?, field_c=?, field_d=?, logged_menu_type=?, link_group_id=?, lng=?, hidden_in_admin=?, force_group_template=?&quot;+addFieldsUpdate.toString()+&quot; WHERE group_id=?&quot;;</span>
			}

<span class="fc" id="L960">			db_conn = DBPool.getConnection();</span>

<span class="fc" id="L962">			ps = db_conn.prepareStatement(sql);</span>
<span class="fc" id="L963">			ps.setString(1, newGroup.getGroupName());</span>
<span class="fc" id="L964">			ps.setBoolean(2, newGroup.isInternal());</span>
<span class="fc" id="L965">			ps.setInt(3, newGroup.getParentGroupId());</span>
<span class="fc" id="L966">			ps.setString(4, newGroup.getNavbarName());</span>
<span class="fc" id="L967">			ps.setInt(5, newGroup.getDefaultDocId());</span>
<span class="fc" id="L968">			ps.setInt(6, newGroup.getTempId());</span>
<span class="fc" id="L969">			ps.setInt(7, newGroup.getSortPriority());</span>
<span class="fc" id="L970">			ps.setString(8, newGroup.getPasswordProtected());</span>
			//#20018, #15784 - pre Plusku ak je nazov noveho adresara cislo, tak daj Nezobrazovat a URL nazov adresara na pomlcku
<span class="pc bpc" id="L972" title="3 of 4 branches missed.">			if(Tools.getIntValue(newGroup.getGroupName(),0) &gt; 0 &amp;&amp; Constants.getBoolean(&quot;editorGroupReplaceNumberWithDashInUrl&quot;))</span>
			{
<span class="nc" id="L974">				newGroup.setMenuType(0);</span>
<span class="nc" id="L975">				newGroup.setUrlDirName(&quot;-&quot;);</span>
<span class="nc" id="L976">				Logger.println(GroupsDB.class, &quot;nazov adresara &quot;+newGroup.getGroupName()+&quot; {id:&quot;+newGroup.getGroupId()+&quot;} je cislo, nastavujem urlDirName na pomlcku a menuType=0&quot;);</span>
			}

<span class="fc" id="L979">			ps.setInt(9, newGroup.getMenuType());</span>
<span class="fc" id="L980">			ps.setString(10, newGroup.getUrlDirName());</span>
<span class="fc" id="L981">			DB.setClob(ps, 11, newGroup.getHtmlHead());</span>
<span class="fc" id="L982">			ps.setInt(12, newGroup.getLogonPageDocId());</span>

			//domain_name, new_page_docid_template, install_name, field_a, field_b, field_c, field_d
<span class="pc bpc" id="L985" title="1 of 4 branches missed.">			if (Constants.getBoolean(&quot;multiDomainEnabled&quot;) &amp;&amp; newGroup.getParentGroupId()&gt;0)</span>
			{
<span class="pc bpc" id="L987" title="1 of 4 branches missed.">				if (Tools.isEmpty(newGroup.getDomainName()) || Constants.getBoolean(&quot;multiDomainEnableNested&quot;)==false) {</span>
					//ak sa niekde zabudla nastavit domena / alebo nie je zapnute nested, pouzijem parent
<span class="fc" id="L989">					GroupDetails parentGroup = getGroup(newGroup.getParentGroupId());</span>
<span class="pc bpc" id="L990" title="2 of 4 branches missed.">					if (parentGroup != null &amp;&amp; Tools.isNotEmpty(parentGroup.getDomainName()))</span>
					{
<span class="fc" id="L992">						newGroup.setDomainName(parentGroup.getDomainName());</span>
					}
				}
			}
<span class="fc" id="L996">			ps.setString(13, newGroup.getDomainName());</span>
<span class="fc" id="L997">			ps.setInt(14, newGroup.getNewPageDocIdTemplate());</span>
<span class="fc" id="L998">			ps.setString(15, newGroup.getInstallName());</span>
<span class="fc" id="L999">			ps.setString(16, newGroup.getFieldA());</span>
<span class="fc" id="L1000">			ps.setString(17, newGroup.getFieldB());</span>
<span class="fc" id="L1001">			ps.setString(18, newGroup.getFieldC());</span>
<span class="fc" id="L1002">			ps.setString(19, newGroup.getFieldD());</span>

<span class="fc" id="L1004">			ps.setInt(20, newGroup.getLoggedMenuType());</span>
<span class="fc" id="L1005">			ps.setInt(21, newGroup.getLinkGroupId());</span>

<span class="fc" id="L1007">			ps.setString(22, newGroup.getLng());</span>
<span class="fc" id="L1008">			ps.setBoolean(23, newGroup.isHiddenInAdmin());</span>

<span class="fc" id="L1010">			ps.setBoolean(24, newGroup.isForceTheUseOfGroupTemplate());</span>

<span class="fc" id="L1012">			int psCounter = DataAccessHelper.setGroupPreparedStatement(ps, newGroup, 25);</span>

<span class="fc bfc" id="L1014" title="All 2 branches covered.">			if (newGroup.getGroupId()&gt;0)</span>
			{
<span class="fc" id="L1016">				ps.setInt(psCounter++, newGroup.getGroupId());</span>
			}

<span class="fc" id="L1019">			ps.execute();</span>
<span class="fc" id="L1020">			ps.close();</span>
<span class="fc" id="L1021">			ps = null;</span>

<span class="fc bfc" id="L1023" title="All 2 branches covered.">			boolean isNew = newGroup.getGroupId()&lt;1;</span>
<span class="fc bfc" id="L1024" title="All 2 branches covered.">			if (isNew)</span>
			{
				//ziskaj group ID
<span class="fc" id="L1027">				sql = &quot;SELECT max(group_id) AS group_id FROM groups WHERE group_name=? AND parent_group_id=?&quot;;</span>
<span class="fc" id="L1028">				ps = db_conn.prepareStatement(sql);</span>
<span class="fc" id="L1029">				ps.setString(1, newGroup.getGroupName());</span>
<span class="fc" id="L1030">				ps.setInt(2, newGroup.getParentGroupId());</span>
<span class="fc" id="L1031">				rs = ps.executeQuery();</span>
<span class="pc bpc" id="L1032" title="1 of 2 branches missed.">				if (rs.next())</span>
				{
<span class="fc" id="L1034">					newGroup.setGroupId(rs.getInt(&quot;group_id&quot;));</span>
<span class="fc" id="L1035">					group.setGroupId(newGroup.getGroupId());</span>
				}
<span class="fc" id="L1037">				rs.close();</span>
<span class="fc" id="L1038">				ps.close();</span>
<span class="fc" id="L1039">				rs = null;</span>
<span class="fc" id="L1040">				ps = null;</span>
			}

<span class="fc" id="L1043">			db_conn.close();</span>
<span class="fc" id="L1044">			db_conn = null;</span>

			//ak su nastavene syncId tak zapis aj to, potrebne pre synchronizaciu struktury
<span class="fc bfc" id="L1047" title="All 2 branches covered.">			if (newGroup.getSyncId()&gt;0) {</span>
<span class="fc" id="L1048">				new SimpleQuery().execute(&quot;UPDATE groups SET sync_id=? WHERE group_id=?&quot;, newGroup.getSyncId(), newGroup.getGroupId());</span>
			}

			//groups_scheduler(history)
<span class="fc" id="L1052">			int userId = -1;</span>
<span class="fc" id="L1053">			RequestBean rb = SetCharacterEncodingFilter.getCurrentRequestBean();</span>
<span class="pc bpc" id="L1054" title="1 of 2 branches missed.">			if(rb != null)</span>
<span class="fc" id="L1055">				userId = rb.getUserId();</span>

<span class="fc" id="L1057">			GroupPublisher.addRecord(newGroup, null, userId);</span>
			//GroupPublisher.addRecord(newGroup, null);

<span class="fc" id="L1060">			StringBuilder logMessage = new StringBuilder();</span>
			//refresh data
<span class="fc bfc" id="L1062" title="All 2 branches covered.">			if (isNew)</span>
			{
<span class="fc" id="L1064">				insertGroupInCache(newGroup);</span>
				//nastavovanie full pathu musi byt aj v if aj v else kvoli logovaniu...
<span class="fc" id="L1066">				newGroup.setFullPath(getPath(newGroup.getGroupId()));</span>
<span class="fc" id="L1067">				group.setFullPath(newGroup.getFullPath());</span>
<span class="fc" id="L1068">				logMessage.append(&quot;Vytvoreny adresar &quot;).append(newGroup.getFullPath());</span>
			}
			else
			{
				//vymaz staru a vloz novu - mozu ist na ine miesto v zozname
<span class="fc" id="L1073">				GroupDetails oldGroup = getGroup(newGroup.getGroupId());</span>
<span class="fc" id="L1074">				replaceGroupInCache(oldGroup, newGroup);</span>
<span class="fc" id="L1075">				newGroup.setFullPath(getPath(newGroup.getGroupId()));</span>
<span class="fc" id="L1076">				group.setFullPath(newGroup.getFullPath());</span>

<span class="fc" id="L1078">				BeanDiff diff = new BeanDiff().setNew(newGroup).setOriginal(oldGroup).blacklist(&quot;syncStatus&quot;, &quot;groupIdName&quot;, &quot;fullPath&quot;);</span>
<span class="fc" id="L1079">				logMessage.append(&quot;Zmeneny adresar: &quot;).append(newGroup.getFullPath());</span>
<span class="fc" id="L1080">				logMessage.append('\n').append(new BeanDiffPrinter(diff).toString());</span>
			}
			//zresetuj all tree cache
<span class="fc" id="L1083">			groupsTreeAllCache = null;</span>

<span class="fc" id="L1085">			Adminlog.add(Adminlog.TYPE_GROUP, logMessage.toString(), newGroup.getGroupId(), newGroup.getParentGroupId());</span>
			//oznam ostatnym, ze nastala zmena
<span class="fc" id="L1087">			ClusterDB.addRefresh(GroupsDB.class);</span>

			//aktualizuj FT fieldy
<span class="fc" id="L1090">			DocDB.updateFileNameField(newGroup.getGroupId());</span>

			//ak sa jedna o system adresar, refreshnem zoznam tychto stranok
<span class="pc bpc" id="L1093" title="1 of 2 branches missed.">			if(&quot;System&quot;.equalsIgnoreCase(newGroup.getGroupName())) getAllSystemFolders(true);</span>

<span class="fc bfc" id="L1095" title="All 2 branches covered.">			if (publishEvents) (new WebjetEvent&lt;GroupDetails&gt;(newGroup, WebjetEventType.AFTER_SAVE)).publishEvent();</span>

<span class="fc" id="L1097">			return(true);</span>
		}
<span class="nc" id="L1099">		catch (Exception ex){sk.iway.iwcm.Logger.error(ex);}</span>
		finally{
			try{
<span class="pc bpc" id="L1102" title="1 of 2 branches missed.">				if (rs != null) rs.close();</span>
<span class="pc bpc" id="L1103" title="1 of 2 branches missed.">				if (ps != null) ps.close();</span>
<span class="pc bpc" id="L1104" title="1 of 2 branches missed.">				if (db_conn != null) db_conn.close();</span>
<span class="pc" id="L1105">			}catch (Exception e) {sk.iway.iwcm.Logger.error(e);}</span>
		}
<span class="nc" id="L1107">		return(false);</span>
	}

	/**
	 *  Vrati meno grupy pre zadane group_id
	 *
	 *@param  groupId  id grupy
	 *@return          nazov grupy
	 */
	public String getGroupName(int groupId)
	{
<span class="nc" id="L1118">		GroupDetails group = findGroup(groupId);</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">		if (group == null)</span>
<span class="nc" id="L1120">			return (&quot;&quot;);</span>
<span class="nc" id="L1121">		return group.getGroupName();</span>
	}

	/**
	 *  vrati zoznam potomkov
	 *
	 *@param  groupId     Description of the Parameter
	 *@param  noInternal  Description of the Parameter
	 *@return             Description of the Return Value
	 */
	public List&lt;GroupDetails&gt; findChilds(int groupId, boolean noInternal)
	{
<span class="nc" id="L1133">		List&lt;GroupDetails&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1134" title="All 2 branches missed.">		for (GroupDetails group : groups)</span>
		{
<span class="nc bnc" id="L1136" title="All 2 branches missed.">			if (group.getParentGroupId() == groupId)</span>
			{
<span class="nc bnc" id="L1138" title="All 2 branches missed.">				if (noInternal == true)</span>
				{
<span class="nc bnc" id="L1140" title="All 2 branches missed.">					if (!group.isInternal())</span>
					{
<span class="nc" id="L1142">						ret.add(group);</span>
					}
				}
				else
				{
<span class="nc" id="L1147">					ret.add(group);</span>
				}

			}
<span class="nc" id="L1151">		}</span>
<span class="nc" id="L1152">		return (ret);</span>
	}

	/**
	 *  vrati cestu k zadanej skupine napr.: /iwcm/Produkty
	 *
	 *@param  groupId  Description of the Parameter
	 *@return          The path value
	 */
	public String getPath(int groupId)
	{
<span class="fc bfc" id="L1163" title="All 2 branches covered.">		if (groupId &lt; 1) return(&quot;/&quot;);</span>
<span class="fc" id="L1164">		StringBuilder path = new StringBuilder();</span>
<span class="fc" id="L1165">		boolean finished = false;</span>
<span class="fc" id="L1166">		int currentGroupId = groupId;</span>
<span class="fc" id="L1167">		int depth = 0;</span>
<span class="fc" id="L1168">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc bfc" id="L1170" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L1172">			group = findGroup(currentGroupId);</span>
<span class="fc bfc" id="L1173" title="All 2 branches covered.">			if (group != null)</span>
			{
<span class="fc" id="L1175">				path.insert(0, &quot;/&quot; + group.getGroupName());</span>
<span class="fc" id="L1176">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="fc" id="L1181">				finished = true;</span>
			}
<span class="fc" id="L1183">			depth++;</span>
<span class="fc bfc" id="L1184" title="All 2 branches covered.">			if (depth &gt; max_depth)</span>
			{
<span class="fc" id="L1186">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L1189" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L1191">				finished = true;</span>
			}
		}
<span class="fc" id="L1194">		return (path.toString());</span>
	}

	/**
	 * Vrati zoznam GroupDetails ako cestu k zadanemu groupId
	 * @param groupId
	 * @return
	 */
	public List&lt;GroupDetails&gt; getPathList(int groupId)
	{
<span class="fc" id="L1204">		List&lt;GroupDetails&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L1205" title="1 of 2 branches missed.">		if (groupId &lt; 1) return(ret);</span>

<span class="fc" id="L1207">		boolean finished = false;</span>
<span class="fc" id="L1208">		int currentGroupId = groupId;</span>
<span class="fc" id="L1209">		int depth = 0;</span>
<span class="fc" id="L1210">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc bfc" id="L1212" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L1214">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L1215" title="1 of 2 branches missed.">			if (group != null)</span>
			{
				//pridavame na zaciatok
<span class="fc" id="L1218">				ret.add(0, group);</span>
<span class="fc" id="L1219">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L1224">				finished = true;</span>
			}
<span class="fc" id="L1226">			depth++;</span>
<span class="pc bpc" id="L1227" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L1229">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L1232" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L1234">				finished = true;</span>
			}
		}
<span class="fc" id="L1237">		return (ret);</span>
	}

	public String getPathLinkForward(int groupId, String forward)
	{
<span class="fc" id="L1242">		StringBuilder path = new StringBuilder();</span>
<span class="fc" id="L1243">		boolean finished = false;</span>
<span class="fc" id="L1244">		int currentGroupId = groupId;</span>
<span class="fc" id="L1245">		int depth = 0;</span>
<span class="fc" id="L1246">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc" id="L1248">		String forwardLink = &quot;&quot;;</span>
<span class="pc bpc" id="L1249" title="1 of 2 branches missed.">		if (forward!=null)</span>
		{
<span class="nc" id="L1251">			forwardLink = &quot;&amp;forward=&quot;+forward;</span>
		}
<span class="fc bfc" id="L1253" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L1255">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L1256" title="1 of 2 branches missed.">			if (group != null)</span>
			{
<span class="fc" id="L1258">				path.insert(0, &quot;/&lt;a class='groups' href='/admin/v9/webpages/web-pages-list/?groupid=&quot;+group.getGroupId()+forwardLink+&quot;'&gt;&quot; + ResponseUtils.filter(group.getGroupName()) + &quot;&lt;/a&gt;&quot;);</span>
<span class="fc" id="L1259">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L1264">				finished = true;</span>
			}
<span class="fc" id="L1266">			depth++;</span>
<span class="pc bpc" id="L1267" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L1269">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L1272" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L1274">				finished = true;</span>
			}
		}
<span class="fc" id="L1277">		return (path.toString());</span>
	}

	/**
	 * Vrati cestu k suboru ak je v subor v ListGroup inak vrati cestu s groupid = 0 (root)
	 * @param groupId
	 * @param forward
	 * @param listGroup
	 * @return
	 */
	public String getPathLinkForwardExceptNotAllow(int groupId, String forward, List&lt;GroupDetails&gt; listGroup)
	{
<span class="nc" id="L1289">		StringBuilder path = new StringBuilder();</span>
<span class="nc" id="L1290">		boolean finished = false;</span>
<span class="nc" id="L1291">		int currentGroupId = groupId;</span>
<span class="nc" id="L1292">		int depth = 0;</span>
<span class="nc" id="L1293">		int max_depth = 30;</span>
		GroupDetails group;
<span class="nc" id="L1295">		String forwardLink = &quot;&quot;;</span>
<span class="nc bnc" id="L1296" title="All 2 branches missed.">		if (forward!=null)</span>
		{
<span class="nc" id="L1298">			forwardLink = &quot;&amp;forward=&quot;+forward;</span>
		}
<span class="nc bnc" id="L1300" title="All 2 branches missed.">		while (finished == false)</span>
		{
<span class="nc" id="L1302">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L1303" title="All 2 branches missed.">			if (group != null)</span>
			{
				//is_allow
				String replaceID;
<span class="nc bnc" id="L1307" title="All 2 branches missed.">				if(  isAllow(listGroup, group.getGroupId())  )</span>
<span class="nc" id="L1308">					replaceID = group.getGroupId()+&quot;&quot;;</span>
				else
<span class="nc" id="L1310">					replaceID = &quot;0&quot; ;</span>
<span class="nc" id="L1311">				path.insert(0, &quot;/&lt;a class='groups' href='/admin/v9/webpages/web-pages-list/?groupid=&quot;+replaceID+forwardLink+&quot;'&gt;&quot; + group.getGroupName() + &quot;&lt;/a&gt;&quot;);</span>
<span class="nc" id="L1312">				currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1313">			}</span>
			else
			{
				//group doesn't exist
<span class="nc" id="L1317">				finished = true;</span>
			}
<span class="nc" id="L1319">			depth++;</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L1322">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L1325" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L1327">				finished = true;</span>
			}
		}
<span class="nc" id="L1330">		return (path.toString());</span>
	}

	/**
	 * Vrati true ak v danom ListGroup je adresar s ID =  groupId
	 * @param ListGroup - zoznam vsetkych suborov
	 * @param groupId - id aktualneho adresara
	 */
	private static boolean isAllow(List&lt;GroupDetails&gt; listGroup,int groupId)
	{
<span class="nc bnc" id="L1340" title="All 2 branches missed.">		if(groupId == 0)</span>
<span class="nc" id="L1341">			return true;</span>

<span class="nc" id="L1343">		boolean finded = false;</span>
<span class="nc bnc" id="L1344" title="All 2 branches missed.">		for(int i = 0; i &lt; listGroup.size() ; i++)</span>
		{
<span class="nc bnc" id="L1346" title="All 2 branches missed.">			if( (listGroup.get(i).getGroupId()+&quot;&quot;).equals(groupId+&quot;&quot;) )</span>
<span class="nc" id="L1347">				return true;</span>
		}
<span class="nc" id="L1349">		return finded;</span>
	}
	/**
	 * Vrati naformatovanu cestu priorit k danemu adresaru (napr. 1.20.14)
	 * @param groupId
	 * @return
	 */
	public String getPathPriorityNumbers(int groupId)
	{
<span class="nc" id="L1358">		StringBuilder path = new StringBuilder();</span>
<span class="nc" id="L1359">		boolean finished = false;</span>
<span class="nc" id="L1360">		int currentGroupId = groupId;</span>
<span class="nc" id="L1361">		int depth = 0;</span>
<span class="nc" id="L1362">		int max_depth = 30;</span>
		GroupDetails group;
<span class="nc bnc" id="L1364" title="All 2 branches missed.">		while (finished == false)</span>
		{
<span class="nc" id="L1366">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L1367" title="All 2 branches missed.">			if (group != null)</span>
			{
<span class="nc" id="L1369">				path.insert(0, group.getSortPriority() + &quot;.&quot;);</span>
<span class="nc" id="L1370">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L1375">				finished = true;</span>
			}
<span class="nc" id="L1377">			depth++;</span>
<span class="nc bnc" id="L1378" title="All 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L1380">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L1383" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L1385">				finished = true;</span>
			}
		}
<span class="nc" id="L1388">		return (path.toString());</span>
	}

	/**
	 * Vrati retazec s cestou k adresaru (napr. /sk/nieco/podnieco).
	 * Pouziva UrlDirName groupDetails
	 * @param groupId
	 * @return
	 */
	public String getURLPath(int groupId)
	{
<span class="fc" id="L1399">		return(getURLPathGroup(groups, groupId));</span>
	}

	/**
	 * Vrati retazec s cestou k adresaru (napr. /sk/nieco/podnieco).
	 * @param allGroups
	 * @param groupId
	 * @return
	 */
	public static String getURLPathGroup(List&lt;GroupDetails&gt; allGroups, int groupId)
	{
<span class="fc" id="L1410">		String[] retData = getURLPathDomainGroup(allGroups, groupId);</span>
<span class="fc" id="L1411">		return retData[0];</span>
	}

	/**
	 * Vrati domenu pre zadane groupId
	 * @param groupId
	 * @return
	 */
	public String getDomain(int groupId)
	{
<span class="pc bpc" id="L1421" title="1 of 2 branches missed.">		if (InitServlet.isTypeCloud())</span>
		{
<span class="nc" id="L1423">			GroupDetails group = getGroup(groupId);</span>
<span class="nc bnc" id="L1424" title="All 4 branches missed.">			if (group != null &amp;&amp; Tools.isNotEmpty(group.getDomainName())) return group.getDomainName();</span>
		}

<span class="fc" id="L1427">		return(getDomain(groups, groupId));</span>
	}

	/**
	 * Vrati domenu pre zadane groupId a zadany list
	 * @param allGroups
	 * @param groupId
	 * @return
	 */
	public static String getDomain(List&lt;GroupDetails&gt; allGroups, int groupId)
	{
<span class="fc" id="L1438">		String[] retData = getURLPathDomainGroup(allGroups, groupId);</span>
<span class="fc" id="L1439">		return retData[1];</span>
	}

	public static String[] getURLPathDomainGroup(List&lt;GroupDetails&gt; allGroups, int groupId)
	{
<span class="fc" id="L1444">		Map&lt;Integer, GroupDetails&gt; table = new Hashtable&lt;&gt;();</span>
<span class="fc bfc" id="L1445" title="All 2 branches covered.">		for (GroupDetails group : allGroups)</span>
		{
<span class="fc" id="L1447">			table.put(group.getGroupId(), group);</span>
<span class="fc" id="L1448">		}</span>

<span class="fc" id="L1450">		return getURLPathDomainGroup(table, groupId);</span>
	}

	/**
	 * Vrati pole stringov, kde ret[0]=URL cesta k adresaru a ret[1]=nazov domeny root adresara
	 * @param allGroups
	 * @param groupId
	 * @return
	 */
	public static String[] getURLPathDomainGroup(Map&lt;Integer, GroupDetails&gt; allGroups, int groupId)
	{
<span class="fc" id="L1461">		String[] retData = new String[2];</span>

<span class="fc" id="L1463">		StringBuilder path = new StringBuilder();</span>
<span class="fc" id="L1464">		boolean finished = false;</span>
<span class="fc" id="L1465">		int currentGroupId = groupId;</span>
<span class="fc" id="L1466">		int depth = 0;</span>
<span class="fc" id="L1467">		int max_depth = 30;</span>
		GroupDetails group;

<span class="fc" id="L1470">		String domain = null;</span>
		//pouzije sa ak je nastavene multiDomainEnableNested
<span class="fc" id="L1472">		String domainOnFirstGroup = null;</span>

<span class="fc bfc" id="L1474" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L1476">			group = allGroups.get(Integer.valueOf(currentGroupId));</span>

<span class="fc bfc" id="L1478" title="All 2 branches covered.">			if (group==null)</span>
			{
<span class="fc" id="L1480">				retData[0] = &quot;--------------------------&quot;;</span>
<span class="fc" id="L1481">				retData[1] = &quot;&quot;;</span>
<span class="fc" id="L1482">				return(retData);</span>
			}
			else
			{
<span class="fc bfc" id="L1486" title="All 4 branches covered.">				if (domainOnFirstGroup == null &amp;&amp; Tools.isNotEmpty(group.getDomainName()))</span>
				{
<span class="fc" id="L1488">					domainOnFirstGroup = group.getDomainName();</span>
<span class="fc" id="L1489">					domain = domainOnFirstGroup;</span>
				}

				//Logger.println(this,&quot;group=&quot;+group.getGroupId()+&quot; p=&quot;+group.getParentGroupId()+&quot; n=&quot;+group.getNavbarName());

<span class="fc bfc" id="L1494" title="All 2 branches covered.">				if (group.getUrlDirName().startsWith(&quot;/&quot;))</span>
				{
					//ak sa adresaru nastavi cesta zacinajuca / tak sa zrusi predchadzajuca URL cesta
<span class="fc" id="L1497">					path.insert(0, group.getUrlDirName());</span>
<span class="fc" id="L1498">					finished = true;</span>
				}
<span class="fc bfc" id="L1500" title="All 2 branches covered.">				else if(&quot;-&quot;.equals(group.getUrlDirName())==false)</span>
				{
<span class="fc" id="L1502">					path.insert(0, &quot;/&quot; + group.getUrlDirName());</span>
				}
<span class="fc" id="L1504">				currentGroupId = group.getParentGroupId();</span>
			}


			//Logger.println(this,&quot;path=&quot;+path);

<span class="fc" id="L1510">			depth++;</span>
<span class="fc bfc" id="L1511" title="All 2 branches covered.">			if (depth &gt; max_depth)</span>
			{
<span class="fc" id="L1513">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L1516" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L1518">				finished = true;</span>
<span class="pc bpc" id="L1519" title="1 of 2 branches missed.">				if (group != null) domain = group.getDomainName();</span>
			}
		}

		//ak sme skoncili iteraciu predcasne
<span class="pc bpc" id="L1524" title="3 of 4 branches missed.">		while (domain == null &amp;&amp; depth++ &lt; max_depth)</span>
		{
<span class="nc" id="L1526">			group = allGroups.get(Integer.valueOf(currentGroupId));</span>
<span class="nc bnc" id="L1527" title="All 2 branches missed.">			if (group == null)</span>
			{
<span class="nc" id="L1529">				domain = &quot;&quot;;</span>
<span class="nc" id="L1530">				break;</span>
			}
			else
			{
<span class="nc" id="L1534">				currentGroupId = group.getParentGroupId();</span>

<span class="nc bnc" id="L1536" title="All 2 branches missed.">				if (currentGroupId == 0)</span>
				{
<span class="nc" id="L1538">					domain = group.getDomainName();</span>
				}
			}
		}

<span class="pc bpc" id="L1543" title="1 of 2 branches missed.">		if (domain == null) domain=&quot;&quot;;</span>

<span class="pc bpc" id="L1545" title="1 of 2 branches missed.">		if (Constants.getBoolean(&quot;multiDomainEnableNested&quot;)) domain = domainOnFirstGroup;</span>

<span class="fc" id="L1547">		retData[0] = Tools.replace(path.toString(), &quot;//&quot;, &quot;/&quot;);</span>
<span class="fc" id="L1548">		retData[1] = domain;</span>
<span class="fc" id="L1549">		return(retData);</span>
	}

	/**
	 * Vrati cestu k adresaru s pouzitim NavbarName (napr. /Slovensky/O Ns/Kontakt)
	 * @param groupId
	 * @return
	 */
	public String getNavbarPath(int groupId)
	{
<span class="nc" id="L1559">		StringBuilder path = new StringBuilder();</span>
<span class="nc" id="L1560">		boolean finished = false;</span>
<span class="nc" id="L1561">		int currentGroupId = groupId;</span>
<span class="nc" id="L1562">		int depth = 0;</span>
<span class="nc" id="L1563">		int max_depth = 30;</span>
		GroupDetails group;

<span class="nc bnc" id="L1566" title="All 2 branches missed.">		while (finished == false)</span>
		{
<span class="nc" id="L1568">			group = findGroup(currentGroupId);</span>


<span class="nc bnc" id="L1571" title="All 2 branches missed.">			if (group==null)</span>
			{
<span class="nc" id="L1573">				return(&quot;--------------------------&quot;);</span>
			}
			else
			{
<span class="nc bnc" id="L1577" title="All 2 branches missed.">				if (&quot;-&quot;.equals(group.getUrlDirName())==false)</span>
				{
<span class="nc" id="L1579">					path.insert(0, &quot;/&quot; + group.getNavbarName());</span>
				}
<span class="nc" id="L1581">				currentGroupId = group.getParentGroupId();</span>
			}


			//Logger.println(this,&quot;path=&quot;+path);

<span class="nc" id="L1587">			depth++;</span>
<span class="nc bnc" id="L1588" title="All 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L1590">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L1593" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L1595">				finished = true;</span>
			}
		}

<span class="nc" id="L1599">		return (path.toString());</span>
	}

	/**
	 * Vrati cestu k adresaru s pouzitim Title (napr. /Slovensky/O Ns/Kontakt)
	 * @param groupId
	 * @return
	 */
	public String getGroupNamePath(int groupId)
	{
<span class="fc" id="L1609">		StringBuilder path = new StringBuilder();</span>
<span class="fc" id="L1610">		boolean finished = false;</span>
<span class="fc" id="L1611">		int currentGroupId = groupId;</span>
<span class="fc" id="L1612">		int depth = 0;</span>
<span class="fc" id="L1613">		int max_depth = 30;</span>
		GroupDetails group;

<span class="fc bfc" id="L1616" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L1618">			group = findGroup(currentGroupId);</span>

<span class="fc bfc" id="L1620" title="All 2 branches covered.">			if (group==null)</span>
			{
<span class="fc" id="L1622">				return(&quot;--------------------------&quot;);</span>
			}
			else
			{
<span class="fc" id="L1626">				path.insert(0, &quot;/&quot; + group.getGroupName());</span>
<span class="fc" id="L1627">				currentGroupId = group.getParentGroupId();</span>
			}

			//Logger.println(this,&quot;path=&quot;+path);

<span class="fc" id="L1632">			depth++;</span>
<span class="pc bpc" id="L1633" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L1635">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L1638" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L1640">				finished = true;</span>
			}
		}

<span class="fc" id="L1644">		return (path.toString());</span>
	}

	/**
	 *  vrati navigacnu listu (podobne ako cestu) len je to iwcm &gt; Produkty
	 *
	 *@param  groupId  Description of the Parameter
	 *@return          The navbar value
	 */
	public String getNavbar(int groupId)
	{
<span class="fc" id="L1655">		return(getNavbar(groupId, -99, null));</span>
	}

	/**
	 * Vrati navigacnu listup, pre zadane docId (aktualne) nezrenderuje odkaz
	 * @param groupId
	 * @param docId
	 * @param session
	 * @return
	 */
	public String getNavbar(int groupId, int docId, HttpSession session)
	{
<span class="fc" id="L1667">		StringBuilder path = new StringBuilder();</span>
<span class="fc" id="L1668">		boolean finished = false;</span>
<span class="fc" id="L1669">		int currentGroupId = groupId;</span>
<span class="fc" id="L1670">		int depth = 0;</span>
<span class="fc" id="L1671">		int max_depth = 30;</span>
		GroupDetails group;
<span class="pc bpc" id="L1673" title="1 of 4 branches missed.">		while (finished == false &amp;&amp; depth++&lt;max_depth)</span>
		{
<span class="fc" id="L1675">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L1676" title="2 of 4 branches missed.">			if (group != null &amp;&amp; group.getGroupId()!=group.getParentGroupId())</span>
			{
<span class="pc bpc" id="L1678" title="1 of 4 branches missed.">				if (group.isInternal()==true || group.getMenuType(session)==GroupDetails.MENU_TYPE_HIDDEN)</span>
				{
<span class="fc" id="L1680">					currentGroupId = group.getParentGroupId();</span>
<span class="fc" id="L1681">					continue;</span>
				}

<span class="pc bpc" id="L1684" title="2 of 4 branches missed.">				if (group.getNavbar().length() &gt; 1 &amp;&amp; &quot;&amp;nbsp;&quot;.equals(group.getNavbarName())==false)</span>
				{
<span class="pc bpc" id="L1686" title="3 of 4 branches missed.">					if (Constants.getBoolean(&quot;navbarRenderAllLinks&quot;)==false &amp;&amp; group.getDefaultDocId()==docId)</span>
					{
<span class="nc" id="L1688">						String newPath = &quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot; + group.getNavbarName().replaceAll(&quot;(?i)&lt;aparam.*&gt;&quot;,&quot;&quot;);</span>
						//ochrana pred duplikovanim cesty (ak mame root a v nom mame hlavnu stranku v podadresari s rovnakym nazvom)
<span class="nc bnc" id="L1690" title="All 2 branches missed.">						if (path.indexOf(newPath)!=0) path.insert(0, newPath);</span>
<span class="nc" id="L1691">					}</span>
					else
					{
<span class="fc" id="L1694">						String navbarName = group.getNavbar();</span>
<span class="pc bpc" id="L1695" title="1 of 2 branches missed.">						if (navbarName.contains(&quot;*||&quot;)) navbarName = Tools.replace(navbarName, &quot;*||&quot;, &quot;&lt;/&quot;);</span>
<span class="pc bpc" id="L1696" title="1 of 2 branches missed.">						if (navbarName.contains(&quot;*|&quot;)) navbarName = Tools.replace(navbarName, &quot;*|&quot;, &quot;&lt;&quot;);</span>
<span class="pc bpc" id="L1697" title="1 of 2 branches missed.">						if (navbarName.contains(&quot;|*&quot;)) navbarName = Tools.replace(navbarName, &quot;|*&quot;, &quot;&gt;&quot;);</span>
<span class="fc" id="L1698">						String newPath = &quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot; + navbarName;</span>
<span class="pc bpc" id="L1699" title="1 of 2 branches missed.">						if (path.indexOf(newPath)!=0) path.insert(0, newPath);</span>
					}
				}
<span class="fc" id="L1702">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L1707">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L1710" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L1712">				finished = true;</span>
			}
		}
		try
		{
			//odstran zobak na zaciatku
<span class="pc bpc" id="L1718" title="1 of 2 branches missed.">			if (path.indexOf(&quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot;)==0)</span>
			{
<span class="fc" id="L1720">				return path.toString().substring(Constants.getString(&quot;navbarSeparator&quot;).length() + 2).trim();</span>
			}
		}
<span class="nc" id="L1723">		catch (Exception ex)</span>
		{
<span class="nc" id="L1725">		}</span>
<span class="nc" id="L1726">		return (path.toString());</span>
	}
	/**
	 * Vrati HTML kod pre Breadcrumb navigaciu vo formate schema.org
	 * @param groupId - ID adresara
	 * @param docId - ID aktualnej web stranky
	 * @param session
	 * @return
	 */
	public String getNavbarSchema(int groupId, int docId, HttpSession session)
	{
<span class="nc" id="L1737">		StringBuilder htmlCode = new StringBuilder();</span>
<span class="nc" id="L1738">		DocDB docDB = DocDB.getInstance();</span>

<span class="nc" id="L1740">		boolean finished = false;</span>
<span class="nc" id="L1741">		int currentGroupId = groupId;</span>
<span class="nc" id="L1742">		int depth = 0;</span>
<span class="nc" id="L1743">		int max_depth = 30;</span>
		GroupDetails group;
<span class="nc" id="L1745">		int realMaxDepth = 1;</span>

		// potrebujem zistit realny pocet urovni
<span class="nc bnc" id="L1748" title="All 4 branches missed.">		while (finished == false &amp;&amp; depth++&lt;max_depth)</span>
		{
<span class="nc" id="L1750">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L1751" title="All 4 branches missed.">			if (group != null &amp;&amp; group.getGroupId()!=group.getParentGroupId())</span>
			{
<span class="nc bnc" id="L1753" title="All 4 branches missed.">				if (group.isInternal()==true || group.getMenuType(session)==GroupDetails.MENU_TYPE_HIDDEN)</span>
				{
<span class="nc" id="L1755">					currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1756">					continue;</span>
				}

<span class="nc" id="L1759">				Map&lt;String, String&gt; aparams = parseAparam(group.getNavbarName());</span>
<span class="nc bnc" id="L1760" title="All 8 branches missed.">				if (group.getDefaultDocId() &gt; 0 &amp;&amp; (!aparams.containsKey(&quot;class&quot;) || aparams.containsKey(&quot;class&quot;) &amp;&amp; !aparams.get(&quot;class&quot;).equalsIgnoreCase(&quot;is-headline&quot;))) {</span>
<span class="nc" id="L1761">					realMaxDepth++;</span>
				}
<span class="nc" id="L1763">				currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1764">			}</span>
			else
			{
				//group doesn't exist
<span class="nc" id="L1768">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L1771" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L1773">				finished = true;</span>
			}
		}

<span class="nc" id="L1777">		depth = 0;</span>
<span class="nc" id="L1778">		currentGroupId = groupId;</span>
<span class="nc" id="L1779">		finished = false;</span>
<span class="nc" id="L1780">		int skippedCount = 0;</span>

<span class="nc bnc" id="L1782" title="All 4 branches missed.">		while (finished == false &amp;&amp; depth++&lt;max_depth)</span>
		{
<span class="nc" id="L1784">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L1785" title="All 4 branches missed.">			if (group != null &amp;&amp; group.getGroupId()!=group.getParentGroupId())</span>
			{
<span class="nc bnc" id="L1787" title="All 4 branches missed.">				if (group.isInternal()==true || group.getMenuType(session)==GroupDetails.MENU_TYPE_HIDDEN)</span>
				{
<span class="nc" id="L1789">					currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1790">					skippedCount++;</span>
<span class="nc" id="L1791">					continue;</span>
				}

<span class="nc" id="L1794">				String groupNavbar = Tools.convertToHtmlTags(group.getNavbarName());</span>

<span class="nc" id="L1796">				Map&lt;String, String&gt; aparams = parseAparam(groupNavbar);</span>
<span class="nc bnc" id="L1797" title="All 6 branches missed.">				if (group.getDefaultDocId() &lt; 1 || aparams.containsKey(&quot;class&quot;) &amp;&amp; aparams.get(&quot;class&quot;).equalsIgnoreCase(&quot;is-headline&quot;)) {</span>
<span class="nc" id="L1798">					currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1799">					skippedCount++;</span>
<span class="nc" id="L1800">					continue;</span>
				}

<span class="nc bnc" id="L1803" title="All 8 branches missed.">				if (group.getDefaultDocId() &gt; 0 &amp;&amp; groupNavbar.length() &gt; 1 &amp;&amp; (groupNavbar.indexOf(&quot;&lt;a&quot;) &lt; 0 || groupNavbar.toLowerCase().indexOf(&quot;&lt;aparam&quot;) &gt;= 0))</span>
				{
					//odstrani &lt;aparam&gt;
<span class="nc" id="L1806">					String text = groupNavbar.replaceAll(&quot;(?i)&lt;aparam.*&gt;&quot;, &quot;&quot;);</span>
<span class="nc" id="L1807">					groupNavbar = &quot;\n\t&lt;li class=\&quot;is-item\&quot; itemprop=\&quot;itemListElement\&quot; itemscope itemtype=\&quot;http://schema.org/ListItem\&quot;&gt;&quot; +</span>
<span class="nc" id="L1808">							&quot;&lt;a href='&quot; + docDB.getDocLink(group.getDefaultDocId()) + &quot;' class='navbar' itemprop=\&quot;item\&quot;&gt;&quot; +</span>
<span class="nc" id="L1809">							&quot;&lt;span itemprop=\&quot;name\&quot;&gt;&quot; + Tools.convertToHtmlTags(text) + &quot;&lt;/span&gt;&quot; +</span>
							&quot;&lt;/a&gt;&quot; +
							&quot;&lt;meta itemprop=\&quot;position\&quot; content=\&quot;&quot; + (realMaxDepth - depth + skippedCount) + &quot;\&quot; /&gt;&lt;/li&gt;&quot;;
				}

<span class="nc bnc" id="L1814" title="All 4 branches missed.">				if (groupNavbar.length() &gt; 1 &amp;&amp; &quot;&amp;nbsp;&quot;.equals(group.getNavbarName())==false)</span>
				{
<span class="nc bnc" id="L1816" title="All 4 branches missed.">					if (Constants.getBoolean(&quot;navbarRenderAllLinks&quot;)==false &amp;&amp; group.getDefaultDocId()==docId)</span>
					{
<span class="nc" id="L1818">						String text = group.getNavbarName().replaceAll(&quot;(?i)&lt;aparam.*&gt;&quot;, &quot;&quot;);</span>
<span class="nc" id="L1819">						String newPath = Tools.convertToHtmlTags(text);</span>

						//ochrana pred duplikovanim cesty (ak mame root a v nom mame hlavnu stranku v podadresari s rovnakym nazvom)
<span class="nc bnc" id="L1822" title="All 2 branches missed.">						if (htmlCode.indexOf(newPath)!=0) htmlCode.insert(0, newPath);</span>
<span class="nc" id="L1823">					}</span>
					else
					{
						//tu nepotrebujeme nahradu, tu uz len pridavame moznosti dokopy
<span class="nc" id="L1827">						String newPath = groupNavbar;</span>

<span class="nc bnc" id="L1829" title="All 2 branches missed.">						if (htmlCode.indexOf(newPath)!=0) htmlCode.insert(0, newPath);</span>
					}
				}
<span class="nc" id="L1832">				currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1833">			}</span>
			else
			{
				//group doesn't exist
<span class="nc" id="L1837">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L1840" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L1842">				finished = true;</span>
			}
		}
		try
		{
			//odstran zobak na zaciatku
<span class="nc bnc" id="L1848" title="All 2 branches missed.">			if (htmlCode.indexOf(&quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot;)==0)</span>
			{
<span class="nc" id="L1850">				htmlCode = new StringBuilder(htmlCode.toString().substring(Constants.getString(&quot;navbarSeparator&quot;).length() + 2).trim());</span>
			}
		}
<span class="nc" id="L1853">		catch (Exception ex)</span>
		{
<span class="nc" id="L1855">		}</span>

<span class="nc" id="L1857">		htmlCode.insert(0, &quot;\n&lt;ol itemscope itemtype=\&quot;http://schema.org/BreadcrumbList\&quot;&gt;&quot;);</span>
<span class="nc" id="L1858">		htmlCode.append(&quot;\n&lt;/ol&gt;&quot;);</span>
<span class="nc" id="L1859">		return (htmlCode.toString());</span>
	}

	protected Map&lt;String, String&gt; parseAparam(String str) {
<span class="nc bnc" id="L1863" title="All 2 branches missed.">		if (!str.contains(&quot;&lt;aparam&quot;)) {</span>
<span class="nc" id="L1864">			return Collections.emptyMap();</span>
		}

		try {
<span class="nc" id="L1868">			String string = str.substring(str.indexOf(&quot;&lt;aparam&quot;), str.length());</span>
<span class="nc" id="L1869">			string = string.substring(0, string.indexOf(&quot;&gt;&quot;) - 1);</span>
<span class="nc" id="L1870">			string = string.substring(7, string.length()).trim();</span>

<span class="nc" id="L1872">			String[] arr = Tools.getTokens(string, &quot;&quot;);</span>
<span class="nc" id="L1873">			Map&lt;String, String&gt; result = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L1875" title="All 2 branches missed.">			for (String item : arr) {</span>
<span class="nc" id="L1876">				String[] items = Tools.getTokens(item, &quot;=&quot;);</span>
<span class="nc bnc" id="L1877" title="All 2 branches missed.">				String value = items[1] != null ? Tools.replace(items[1], &quot;\&quot;&quot;, &quot;&quot;) : &quot;&quot;;</span>
<span class="nc" id="L1878">				result.put(items[0], value);</span>
			}

<span class="nc" id="L1881">			return result;</span>
		}
<span class="nc" id="L1883">		catch (Exception ex) {</span>
<span class="nc" id="L1884">			sk.iway.iwcm.Logger.error(ex);</span>
<span class="nc" id="L1885">			return Collections.emptyMap();</span>
		}
	}

	/**
	 * Vrati HTML kod pre Breadcrumb navigaciu vo formate RDF
	 * http://support.google.com/webmasters/bin/answer.py?hl=en&amp;topic=1088474&amp;hlrm=en&amp;answer=185417&amp;ctx=topic
	 * @param groupId - ID adresara
	 * @param docId - ID aktualnej web stranky
	 * @param session
	 * @return
	 */
	public String getNavbarRDF(int groupId, int docId, HttpSession session)
	{
<span class="nc" id="L1899">		StringBuilder htmlCode = new StringBuilder();</span>
<span class="nc" id="L1900">		DocDB docDB = DocDB.getInstance();</span>

<span class="nc" id="L1902">		boolean finished = false;</span>
<span class="nc" id="L1903">		int currentGroupId = groupId;</span>
<span class="nc" id="L1904">		int depth = 0;</span>
<span class="nc" id="L1905">		int max_depth = 30;</span>
		GroupDetails group;
<span class="nc bnc" id="L1907" title="All 4 branches missed.">		while (finished == false &amp;&amp; depth++&lt;max_depth)</span>
		{
<span class="nc" id="L1909">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L1910" title="All 4 branches missed.">			if (group != null &amp;&amp; group.getGroupId()!=group.getParentGroupId())</span>
			{
<span class="nc bnc" id="L1912" title="All 4 branches missed.">				if (group.isInternal()==true || group.getMenuType(session)==GroupDetails.MENU_TYPE_HIDDEN)</span>
				{
<span class="nc" id="L1914">					currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1915">					continue;</span>
				}

<span class="nc" id="L1918">				String groupNavbar = group.getNavbarName();</span>
<span class="nc bnc" id="L1919" title="All 8 branches missed.">				if (group.getDefaultDocId() &gt; 0 &amp;&amp; groupNavbar.length() &gt; 1 &amp;&amp; (groupNavbar.indexOf(&quot;&lt;a&quot;) &lt; 0 || groupNavbar.toLowerCase().indexOf(&quot;&lt;aparam&quot;) &gt;= 0))</span>
				{
					//odstrani &lt;aparam&gt;
<span class="nc" id="L1922">					String text = groupNavbar.replaceAll(&quot;(?i)&lt;aparam.*&gt;&quot;,&quot;&quot;);</span>
<span class="nc" id="L1923">					groupNavbar = &quot;&lt;span typeof=\&quot;v:Breadcrumb\&quot;&gt;&lt;a href='&quot;+docDB.getDocLink(group.getDefaultDocId())+&quot;' class='navbar' rel=\&quot;v:url\&quot; property=\&quot;v:title\&quot;&gt;&quot; + text + &quot;&lt;/a&gt;&lt;/span&gt;&quot;;</span>
				}

<span class="nc bnc" id="L1926" title="All 4 branches missed.">				if (groupNavbar.length() &gt; 1 &amp;&amp; &quot;&amp;nbsp;&quot;.equals(group.getNavbarName())==false)</span>
				{
<span class="nc bnc" id="L1928" title="All 4 branches missed.">					if (Constants.getBoolean(&quot;navbarRenderAllLinks&quot;)==false &amp;&amp; group.getDefaultDocId()==docId)</span>
					{
<span class="nc" id="L1930">						String newPath = &quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot; + group.getNavbarName().replaceAll(&quot;(?i)&lt;aparam.*&gt;&quot;,&quot;&quot;);</span>
						//ochrana pred duplikovanim cesty (ak mame root a v nom mame hlavnu stranku v podadresari s rovnakym nazvom)
<span class="nc bnc" id="L1932" title="All 2 branches missed.">						if (htmlCode.indexOf(newPath)!=0) htmlCode.insert(0, newPath);</span>
<span class="nc" id="L1933">					}</span>
					else
					{
<span class="nc" id="L1936">						String newPath = &quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot; + groupNavbar;</span>
<span class="nc bnc" id="L1937" title="All 2 branches missed.">						if (htmlCode.indexOf(newPath)!=0) htmlCode.insert(0, newPath);</span>
					}
				}
<span class="nc" id="L1940">				currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1941">			}</span>
			else
			{
				//group doesn't exist
<span class="nc" id="L1945">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L1948" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L1950">				finished = true;</span>
			}
		}
		try
		{
			//odstran zobak na zaciatku
<span class="nc bnc" id="L1956" title="All 2 branches missed.">			if (htmlCode.indexOf(&quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot;)==0)</span>
			{
<span class="nc" id="L1958">				htmlCode = new StringBuilder(htmlCode.toString().substring(Constants.getString(&quot;navbarSeparator&quot;).length() + 2).trim());</span>
			}
		}
<span class="nc" id="L1961">		catch (Exception ex)</span>
		{
<span class="nc" id="L1963">		}</span>

<span class="nc" id="L1965">		htmlCode.insert(0, &quot;&lt;div class=\&quot;breadcrumbrdf\&quot; xmlns:v=\&quot;http://rdf.data-vocabulary.org/#\&quot;&gt;&quot;);</span>
<span class="nc" id="L1966">		htmlCode.append(&quot;&lt;/div&gt;&quot;);</span>
<span class="nc" id="L1967">		return (htmlCode.toString());</span>
	}


	/**
	 *  to iste ako getNavbar, len do ciest nedava linky (&lt;a href...)
	 *
	 *@param  groupId  Description of the Parameter
	 *@return          The navbarNoHref value
	 */
	public String getNavbarNoHref(int groupId)
	{
<span class="fc" id="L1979">		StringBuilder path = new StringBuilder();</span>
<span class="fc" id="L1980">		boolean finished = false;</span>
<span class="fc" id="L1981">		int currentGroupId = groupId;</span>
<span class="fc" id="L1982">		int depth = 0;</span>
<span class="fc" id="L1983">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc bfc" id="L1985" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L1987">			group = findGroup(currentGroupId);</span>
<span class="fc bfc" id="L1988" title="All 2 branches covered.">			if (group != null)</span>
			{
<span class="pc bpc" id="L1990" title="1 of 2 branches missed.">				if (group.getNavbar().length() &gt; 1)</span>
				{
<span class="fc" id="L1992">					path.insert(0, &quot; &gt; &quot; + group.getNavbarName());</span>
				}
<span class="fc" id="L1994">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="fc" id="L1999">				finished = true;</span>
			}
<span class="fc" id="L2001">			depth++;</span>
<span class="pc bpc" id="L2002" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2004">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L2007" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L2009">				finished = true;</span>
			}
		}
		try
		{
			//odstran zobak na zaciatku
<span class="fc bfc" id="L2015" title="All 2 branches covered.">			if (path.indexOf(&quot; &gt; &quot;)==0)</span>
			{
<span class="fc" id="L2017">				path = new StringBuilder(path.toString().substring(3).trim());</span>
			}
		}
<span class="nc" id="L2020">		catch (Exception ex)</span>
		{
<span class="fc" id="L2022">		}</span>

<span class="fc" id="L2024">		path = Tools.replace(path, &quot;href=&quot;, &quot;hrf=&quot;);</span>

<span class="fc" id="L2026">		return (path.toString());</span>
	}

	/**
	 *  vrati zoznam parent groups (pre pristupove prava)
	 *
	 *@param  groupId  Description of the Parameter
	 *@return          The parents value
	 */
	public String getParents(int groupId)
	{
<span class="fc" id="L2037">		StringBuilder path = new StringBuilder(&quot;&quot;);</span>
<span class="fc" id="L2038">		boolean finished = false;</span>
<span class="fc" id="L2039">		int currentGroupId = groupId;</span>
<span class="fc" id="L2040">		int depth = 0;</span>
<span class="fc" id="L2041">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc bfc" id="L2043" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L2045">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L2046" title="1 of 2 branches missed.">			if (group != null)</span>
			{
<span class="fc" id="L2048">				path.insert(0, group.getGroupId()).insert(0, &quot;,&quot;);</span>
<span class="fc" id="L2049">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L2054">				finished = true;</span>
			}
<span class="fc" id="L2056">			depth++;</span>
<span class="pc bpc" id="L2057" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2059">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L2062" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L2064">				finished = true;</span>
			}
		}
		try
		{
			//odstran zobak na zaciatku
<span class="pc bpc" id="L2070" title="1 of 2 branches missed.">			if (path.toString().startsWith(&quot;,&quot;))</span>
			{
<span class="fc" id="L2072">				path.deleteCharAt(0);</span>
			}
		}
<span class="nc" id="L2075">		catch (Exception ex)</span>
		{
<span class="fc" id="L2077">		}</span>
<span class="fc" id="L2078">		return (path.toString());</span>
	}

	/**
	 * Vrati htmlHead atribut, hlada ho aj v nadradenych adresaroch
	 * @param groupId
	 * @return
	 */
	public String getHtmlHeadRecursive(int groupId)
	{
<span class="fc" id="L2088">		String htmlHead = null;</span>
<span class="fc" id="L2089">		boolean finished = false;</span>
<span class="fc" id="L2090">		int currentGroupId = groupId;</span>
<span class="fc" id="L2091">		int depth = 0;</span>
<span class="fc" id="L2092">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc bfc" id="L2094" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L2096">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L2097" title="1 of 2 branches missed.">			if (group != null)</span>
			{
<span class="pc bpc" id="L2099" title="2 of 4 branches missed.">				if (group.getHtmlHead()!=null &amp;&amp; group.getHtmlHead().length() &gt; 1)</span>
				{
<span class="nc" id="L2101">					htmlHead = group.getHtmlHead();</span>
<span class="nc" id="L2102">					finished = true;</span>
				}
<span class="fc" id="L2104">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L2109">				finished = true;</span>
			}
<span class="fc" id="L2111">			depth++;</span>
<span class="pc bpc" id="L2112" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2114">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L2117" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L2119">				finished = true;</span>
			}
		}
<span class="pc bpc" id="L2122" title="1 of 2 branches missed.">		if (htmlHead==null)</span>
		{
<span class="fc" id="L2124">			htmlHead = &quot;&quot;;</span>
		}
<span class="fc" id="L2126">		return (htmlHead);</span>
	}

	/**
	 * Rekurzivne vrati akukolvek property pre zadany adresar
	 * @param groupId
	 * @param propertyName
	 * @return
	 */
	public String getPropertyRecursive(int groupId, String propertyName)
	{
<span class="fc" id="L2137">		boolean finished = false;</span>
<span class="fc" id="L2138">		int currentGroupId = groupId;</span>
<span class="fc" id="L2139">		int depth = 0;</span>
<span class="fc" id="L2140">		int max_depth = 30;</span>
		GroupDetails group;
		String value;
<span class="fc bfc" id="L2143" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L2145">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L2146" title="1 of 2 branches missed.">			if (group != null)</span>
			{
				try
				{
<span class="fc" id="L2150">					Object o = BeanUtils.getProperty(group, propertyName);</span>
					//Logger.debug(GroupsDB.class, &quot;o=&quot;+o.getClass());
<span class="fc" id="L2152">					value = (String)o;</span>
					//Logger.debug(GroupsDB.class, &quot;value=&quot;+value);
<span class="pc bpc" id="L2154" title="1 of 4 branches missed.">					if (Tools.isNotEmpty(value) &amp;&amp; &quot;0&quot;.equals(value)==false)</span>
					{
<span class="fc" id="L2156">						return(value);</span>
					}
				}
<span class="nc" id="L2159">				catch (Exception ex)</span>
				{
<span class="nc" id="L2161">					sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L2162">				}</span>
<span class="fc" id="L2163">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L2168">				finished = true;</span>
			}
<span class="fc" id="L2170">			depth++;</span>
<span class="pc bpc" id="L2171" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2173">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L2176" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L2178">				finished = true;</span>
			}
		}
<span class="fc" id="L2181">		return (&quot;&quot;);</span>
	}

	/**
	 * Rekurzivne vrati id adresara v ktorom zadana property nadobuda hladanu hodnotu
	 * @param groupId
	 * @param propertyName
	 * @param propertyValue
	 * @return
	 */
	public int getGroupIdByPropertyValue(int groupId, String propertyName, String propertyValue)
	{
<span class="nc" id="L2193">		boolean finished = false;</span>
<span class="nc" id="L2194">		int currentGroupId = groupId;</span>
<span class="nc" id="L2195">		int depth = 0;</span>
<span class="nc" id="L2196">		int max_depth = 30;</span>
		GroupDetails group;
		String value;
<span class="nc bnc" id="L2199" title="All 2 branches missed.">		while (finished == false)</span>
		{
<span class="nc" id="L2201">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L2202" title="All 2 branches missed.">			if (group != null)</span>
			{
				try
				{
<span class="nc" id="L2206">					Object o = BeanUtils.getProperty(group, propertyName);</span>
<span class="nc" id="L2207">					Logger.debug(GroupsDB.class, &quot;o=&quot;+o.getClass());</span>
<span class="nc" id="L2208">					value = (String)o;</span>
<span class="nc" id="L2209">					Logger.debug(GroupsDB.class, &quot;value=&quot;+value);</span>
<span class="nc bnc" id="L2210" title="All 6 branches missed.">					if (Tools.isNotEmpty(value) &amp;&amp; &quot;0&quot;.equals(value)==false &amp;&amp; propertyValue.indexOf(value) != -1)</span>
					{
<span class="nc" id="L2212">						return(currentGroupId);</span>
					}
				}
<span class="nc" id="L2215">				catch (Exception ex)</span>
				{
<span class="nc" id="L2217">					sk.iway.iwcm.Logger.error(ex);</span>
<span class="nc" id="L2218">				}</span>
<span class="nc" id="L2219">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L2224">				finished = true;</span>
			}
<span class="nc" id="L2226">			depth++;</span>
<span class="nc bnc" id="L2227" title="All 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2229">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L2232" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L2234">				finished = true;</span>
			}
		}
<span class="nc" id="L2237">		return -1;</span>
	}

	/**
	 * Rekurzivne ziska docid prihlasovacieho dialogu
	 * @param groupId
	 * @return
	 */
	public int getRecursiveLogonPageDocId(int groupId)
	{
<span class="fc" id="L2247">		int logonPageDocId = -1;</span>
<span class="fc" id="L2248">		boolean finished = false;</span>
<span class="fc" id="L2249">		int currentGroupId = groupId;</span>
<span class="fc" id="L2250">		int depth = 0;</span>
<span class="fc" id="L2251">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc bfc" id="L2253" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L2255">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L2256" title="1 of 2 branches missed.">			if (group != null)</span>
			{
<span class="fc bfc" id="L2258" title="All 2 branches covered.">				if (group.getLogonPageDocId() &gt; 0)</span>
				{
					//Logger.println(this,&quot;logonPageDocId=&quot;+logonPageDocId+&quot; gid=&quot;+group.getGroupId());
<span class="fc" id="L2261">					logonPageDocId = group.getLogonPageDocId();</span>
<span class="fc" id="L2262">					finished = true;</span>
				}
<span class="fc" id="L2264">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L2269">				finished = true;</span>
			}
<span class="fc" id="L2271">			depth++;</span>
<span class="pc bpc" id="L2272" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2274">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L2277" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L2279">				finished = true;</span>
			}
		}
<span class="fc" id="L2282">		return (logonPageDocId);</span>
	}

	/**
	 * vrati rootGrupu pre zadane groupId (pouziva sa koli jazykovym mutaciam)
	 * @param groupId
	 * @return
	 */
	public int getRoot(int groupId)
	{
<span class="nc" id="L2292">		int root = groupId;</span>
<span class="nc" id="L2293">		boolean finished = false;</span>
<span class="nc" id="L2294">		int currentGroupId = groupId;</span>
<span class="nc" id="L2295">		int depth = 0;</span>
<span class="nc" id="L2296">		int max_depth = 30;</span>
		GroupDetails group;
<span class="nc bnc" id="L2298" title="All 2 branches missed.">		while (finished == false)</span>
		{
<span class="nc" id="L2300">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L2301" title="All 2 branches missed.">			if (group != null)</span>
			{
<span class="nc bnc" id="L2303" title="All 2 branches missed.">				if (group.getNavbar().length() &gt; 1)</span>
				{
<span class="nc" id="L2305">					root = group.getGroupId();</span>
				}
<span class="nc" id="L2307">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L2312">				finished = true;</span>
			}
<span class="nc" id="L2314">			depth++;</span>
<span class="nc bnc" id="L2315" title="All 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2317">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L2320" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L2322">				finished = true;</span>
			}
		}
<span class="nc" id="L2325">		return (root);</span>
	}


	/**
	 *  Vrati List zo zoznamom rodicovskych skupin (cesta k root adresaru)
	 *  VYNECHA tie, ktore maju prazdnu hodnotu v poli navbar
	 *
	 *@param  groupId  Description of the Parameter
	 *@return          The parentGroups value
	 */
	public List&lt;GroupDetails&gt; getParentGroups(int groupId) {
<span class="fc" id="L2337">		return getParentGroups(groupId, false);</span>
	}

	/**
	 * Vrati zoznam rodicovskych adresarov (vratane zadaneho groupId)
	 * @param groupId
	 * @param includeWithEmptyNavbar - ak je false pridaju sa do zoznamu len adresare, ktore naju neprazdne pole navbar
	 * @return
	 */
	public List&lt;GroupDetails&gt; getParentGroups(int groupId, boolean includeWithEmptyNavbar)
	{
<span class="fc" id="L2348">		boolean finished = false;</span>
<span class="fc" id="L2349">		int currentGroupId = groupId;</span>
<span class="fc" id="L2350">		int depth = 0;</span>
<span class="fc" id="L2351">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc" id="L2353">		List&lt;GroupDetails&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2354" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L2356">			group = findGroup(currentGroupId);</span>
<span class="fc bfc" id="L2357" title="All 2 branches covered.">			if (group != null)</span>
			{
<span class="pc bpc" id="L2359" title="1 of 4 branches missed.">				if (includeWithEmptyNavbar || group.getNavbar().length() &gt; 1)</span>
				{
					//path = path + &quot;,&quot; + group.getGroupId();
<span class="fc" id="L2362">					ret.add(group);</span>
				}
<span class="fc" id="L2364">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="fc" id="L2369">				finished = true;</span>
			}
<span class="fc" id="L2371">			depth++;</span>
<span class="pc bpc" id="L2372" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2374">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L2377" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L2379">				finished = true;</span>
			}
		}

<span class="fc" id="L2383">		return (ret);</span>
	}

	/**
	 *  vrati nacitane skupiny, je to tu takto ako ArrayList kvoli legacy JSP kodu
	 *
	 *@return    The groups value
	 *@deprecated - pouzivajte verziu getGroupsAll
	 */
	@Deprecated
	public List&lt;GroupDetails&gt; getGroups()
	{
<span class="nc" id="L2395">		List&lt;GroupDetails&gt; arlist = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2396">		arlist.addAll(groups);</span>
<span class="nc" id="L2397">		return arlist;</span>
	}

	/**
	 * Vrati vsetky nacitane skupiny
	 * @return
	 */
	public List&lt;GroupDetails&gt; getGroupsAll()
	{
<span class="fc" id="L2406">		return groups;</span>
	}

	/**
	 *  skontroluje ci uz neexistuje skupina s danym menom v danej skupine
	 *
	 *@param  parentId  id rodica skupiny
	 *@param  name       meno novej skupiny
	 *@return            true ak uz existuje, false inak
	 */
	public boolean checkExist(int parentId, String name)
	{
<span class="fc bfc" id="L2418" title="All 2 branches covered.">		for (GroupDetails group : getGroupsAll())</span>
		{
<span class="fc bfc" id="L2420" title="All 4 branches covered.">			if (group.getParentGroupId() == parentId &amp;&amp; group.getGroupName().compareToIgnoreCase(name) == 0)</span>
			{
<span class="fc" id="L2422">				return (true);</span>
			}
<span class="fc" id="L2424">		}</span>
<span class="fc" id="L2425">		return (false);</span>
	}

	/**
	 *  skontroluje ci uz existuje skupina s danym menom v danej skupine a vrati
	 *  jej id (ak existuje)
	 *
	 *@param  name             meno novej skupiny
	 *@param  parent_group_id  Description of the Parameter
	 *@return                  id skupiny ak existuje, -1 inak
	 */
	public int checkExist2(int parent_group_id, String name)
	{
<span class="nc bnc" id="L2438" title="All 2 branches missed.">		for (GroupDetails group : getGroupsAll())</span>
		{
<span class="nc bnc" id="L2440" title="All 4 branches missed.">			if (group.getParentGroupId() == parent_group_id &amp;&amp; group.getGroupName().compareToIgnoreCase(name) == 0)</span>
			{
<span class="nc" id="L2442">				return group.getGroupId();</span>
			}
<span class="nc" id="L2444">		}</span>
<span class="nc" id="L2445">		return -1;</span>
	}

	/**
	 * Vrati String s rekurzivny zoznamom groupId, ktore mame zadane ako origPerexGroup. Pouziva sa v JSP
	 * strankach pri volani DocDB.getDocPerex()
	 * @param origGroupIds
	 * @return
	 */
	public static String getRecursiveGroupsSqlIn(String origGroupIds)
	{
		//ziskaj rekurzivne stranky
<span class="nc" id="L2457">		StringTokenizer st = new StringTokenizer(origGroupIds, &quot;,&quot;);</span>
		int groupId;
		List&lt;GroupDetails&gt; childs;
<span class="nc" id="L2460">		GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="nc" id="L2461">		StringBuilder groupIds = null;</span>
<span class="nc bnc" id="L2462" title="All 2 branches missed.">		while (st.hasMoreTokens())</span>
		{
			try
			{
<span class="nc" id="L2466">				groupId = Integer.parseInt(st.nextToken());</span>
<span class="nc" id="L2467">				childs = groupsDB.getGroupsTree(groupId, true, false);</span>
<span class="nc bnc" id="L2468" title="All 2 branches missed.">				for (GroupDetails group : childs)</span>
				{
<span class="nc bnc" id="L2470" title="All 2 branches missed.">					if (groupIds == null)</span>
					{
<span class="nc" id="L2472">						groupIds = new StringBuilder(String.valueOf(group.getGroupId()));</span>
					}
					else
					{
<span class="nc" id="L2476">						groupIds.append(&quot;,&quot;).append(String.valueOf(group.getGroupId()));</span>
					}
<span class="nc" id="L2478">				}</span>
			}
<span class="nc" id="L2480">			catch (Exception ex)</span>
			{
<span class="nc" id="L2482">				sk.iway.iwcm.Logger.error(ex);</span>
<span class="nc" id="L2483">			}</span>
		}
<span class="nc bnc" id="L2485" title="All 2 branches missed.">		if (groupIds==null) return null;</span>
<span class="nc" id="L2486">		return(groupIds.toString());</span>
	}

	/**
	 * Vrati grupu podla fullPath (ak je zadane) alebo podla syncId (ak nenajde podla fullPath)
	 * @param fullPath - hodnota fullPath na remote serveri (alebo null, ak chceme hladat len podla syncId)
	 * @param syncId - hodnota groupId na remote serveri
	 * @return
	 */
	public GroupDetails getGroupBySync(String fullPath, int syncId)
	{

<span class="nc bnc" id="L2498" title="All 2 branches missed.">		if (Tools.isNotEmpty(fullPath))</span>
		{
<span class="nc bnc" id="L2500" title="All 2 branches missed.">			for (GroupDetails group : groups)</span>
			{
<span class="nc bnc" id="L2502" title="All 2 branches missed.">				if (group.getFullPath().equalsIgnoreCase(fullPath))</span>
				{
<span class="nc" id="L2504">					return(group);</span>
				}
<span class="nc" id="L2506">			}</span>
		}

<span class="nc bnc" id="L2509" title="All 2 branches missed.">		if (syncId == 0) return(null);</span>

<span class="nc bnc" id="L2511" title="All 2 branches missed.">		for (GroupDetails group : groups)</span>
		{
<span class="nc bnc" id="L2513" title="All 2 branches missed.">			if (group.getSyncId() == syncId)</span>
			{
<span class="nc" id="L2515">				return(group);</span>
			}
<span class="nc" id="L2517">		}</span>
<span class="nc" id="L2518">		return (null);</span>
	}

	/**
	 * Vrati/vytvori skupinu podla zadanej cesty
	 * @param path - cesta vo formate /adresar1/adresar2
	 * @return
	 */
	public GroupDetails getCreateGroup(String path)
	{
		//check if path is number, then get GroupDetails by ID
		try {
<span class="nc" id="L2530">			int groupId = Integer.parseInt(path);</span>
<span class="nc" id="L2531">			return(getGroup(groupId));</span>
<span class="fc" id="L2532">		} catch(Exception ex) {</span>
			//not a number, continue
		}

<span class="fc" id="L2536">		int domainSeparatorIndex = path.indexOf(&quot;:&quot;);</span>
<span class="pc bpc" id="L2537" title="1 of 2 branches missed.">		if (domainSeparatorIndex&gt;0) {</span>
<span class="nc" id="L2538">			String domain = path.substring(0, domainSeparatorIndex);</span>
<span class="nc" id="L2539">			RequestBean rb = SetCharacterEncodingFilter.getCurrentRequestBean();</span>
<span class="nc bnc" id="L2540" title="All 2 branches missed.">			if (rb != null) {</span>
<span class="nc" id="L2541">				rb.setDomain(domain);</span>
			}
<span class="nc" id="L2543">			path = path.substring(domainSeparatorIndex+1);</span>
		}

<span class="pc bpc" id="L2546" title="1 of 2 branches missed.">		if (path.contains(&quot;/&quot;)==false) {</span>
<span class="nc" id="L2547">			return null;</span>
		}

<span class="fc" id="L2550">		int actualParent = 0;</span>
<span class="pc bpc" id="L2551" title="1 of 2 branches missed.">		if(InitServlet.isTypeCloud())</span>
		{
			//ak sa jedna napr. o /System/Kos tak sa nastavi parent na ID hlavneho adresara namiesto na 0 (globalny System folder)
<span class="nc bnc" id="L2554" title="All 2 branches missed.">			if (path.startsWith(&quot;/&quot;+CloudToolsForCore.getDomainName())==false)	actualParent = CloudToolsForCore.getDomainId();</span>
		}
<span class="pc bpc" id="L2556" title="1 of 4 branches missed.">		else if (Constants.getBoolean(&quot;templatesUseDomainLocalSystemFolder&quot;)==true &amp;&amp; path.startsWith(&quot;/System/&quot;))</span>
		{
			//overenie lokalneho /System/Kos adresara
<span class="fc" id="L2559">			Prop propSystem = Prop.getInstance(Constants.getString(&quot;defaultLanguage&quot;));</span>
<span class="fc" id="L2560">			String trashDirName = propSystem.getText(&quot;config.trash_dir&quot;);</span>
<span class="pc bpc" id="L2561" title="1 of 2 branches missed.">			if (path.equals(trashDirName))</span>
			{
<span class="fc" id="L2563">				GroupDetails localSystemGroup = getLocalSystemGroup();</span>
				//pre pripad ze je /System priecinok niekde v subdomene, napr. /English/System/ zaciname hladat v /English priecinku (povazujeme ho za root)
<span class="pc bpc" id="L2565" title="1 of 4 branches missed.">				if (localSystemGroup != null &amp;&amp; localSystemGroup.getParentGroupId()&gt;0) actualParent = localSystemGroup.getParentGroupId();</span>
			}
		}

<span class="fc" id="L2569">		RequestBean rb = SetCharacterEncodingFilter.getCurrentRequestBean();</span>
		String actualGroupName;
<span class="fc" id="L2571">		StringTokenizer st = new StringTokenizer(path, &quot;/&quot;);</span>
		GroupDetails actualGroup;
<span class="fc" id="L2573">		GroupDetails parentGroup = null;</span>
<span class="pc bpc" id="L2574" title="1 of 2 branches missed.">		while (st.hasMoreTokens())</span>
		{
<span class="fc" id="L2576">			actualGroupName = st.nextToken();</span>

			//ak by boli za sebou nahodou //
<span class="pc bpc" id="L2579" title="1 of 2 branches missed.">			if (Tools.isEmpty(actualGroupName)) continue;</span>

<span class="pc bpc" id="L2581" title="1 of 6 branches missed.">			if (&quot;System&quot;.equals(actualGroupName) &amp;&amp; actualParent==0 &amp;&amp; Constants.getBoolean(&quot;templatesUseDomainLocalSystemFolder&quot;)) actualGroup = getLocalSystemGroup();</span>
<span class="fc" id="L2582">            else actualGroup = getGroup(actualGroupName, actualParent);</span>

<span class="fc bfc" id="L2584" title="All 2 branches covered.">			if (actualGroup == null)</span>
			{
<span class="fc" id="L2586">				actualGroup = new GroupDetails();</span>
				//vytvor skupinu, nastav prava podla parenta
<span class="pc bpc" id="L2588" title="1 of 2 branches missed.">				if (parentGroup != null)</span>
				{
					try
					{
<span class="fc" id="L2592">						BeanUtils.copyProperties(actualGroup, parentGroup);</span>
					}
<span class="nc" id="L2594">					catch (Exception ex)</span>
					{
<span class="nc" id="L2596">						sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L2597">					}</span>
<span class="fc" id="L2598">					actualGroup.setParentGroupId(parentGroup.getGroupId());</span>
<span class="fc" id="L2599">					actualGroup.setSyncId(0);</span>
				} else {
<span class="nc bnc" id="L2601" title="All 6 branches missed.">					if (rb != null &amp;&amp; Tools.isNotEmpty(rb.getDomain()) &amp;&amp; Constants.getBoolean(&quot;multiDomainEnabled&quot;)==true) {</span>
						//nastav domenu
<span class="nc" id="L2603">						actualGroup.setDomainName(rb.getDomain());</span>
					}
				}

<span class="fc" id="L2607">				actualGroup.setGroupId(-1);</span>
<span class="fc" id="L2608">				actualGroup.setDefaultDocId(-1);</span>
<span class="fc" id="L2609">				actualGroup.setGroupName(actualGroupName);</span>
<span class="fc" id="L2610">				actualGroup.setNavbar(actualGroupName);</span>
<span class="fc" id="L2611">				actualGroup.setUrlDirName(actualGroupName);</span>

<span class="fc" id="L2613">				actualGroup.setSortPriority(getDefaultSortPriority(actualGroup.getParentGroupId()));</span>

<span class="fc" id="L2615">				setGroup(actualGroup);</span>
			}

<span class="fc bfc" id="L2618" title="All 2 branches covered.">			if (st.hasMoreTokens()==false)</span>
			{
				//sme na konci
<span class="fc" id="L2621">				return(actualGroup);</span>
			}

<span class="fc" id="L2624">			actualParent = actualGroup.getGroupId();</span>
<span class="fc" id="L2625">			parentGroup = actualGroup;</span>
		}
<span class="nc" id="L2627">		return(null);</span>
	}

	/**
	 * Ziska docId sablony novej stranky pre zadany adresar (zvycajne vrati -1 = prazdna stranka)
	 * @param groupId
	 * @return
	 */
	public static int getNewPageDocIdTemplate(int groupId)
	{
<span class="nc" id="L2637">		GroupsDB groupsDB = GroupsDB.getInstance();</span>

<span class="nc" id="L2639">		int newPageDocIdTemplate = Constants.getInt(&quot;newDocumentId&quot;);</span>
<span class="nc" id="L2640">		int groupNewPageDocIdTemplate = Tools.getIntValue(groupsDB.getPropertyRecursive(groupId, &quot;newPageDocIdTemplate&quot;), 0);</span>
<span class="nc bnc" id="L2641" title="All 2 branches missed.">		if (groupNewPageDocIdTemplate!=0)</span>
		{
<span class="nc bnc" id="L2643" title="All 2 branches missed.">			if (groupNewPageDocIdTemplate == -1)</span>
			{
				//prehladaj podla nazvu sablony
<span class="nc" id="L2646">				GroupDetails actualGroup = groupsDB.getGroup(groupId);</span>
<span class="nc" id="L2647">				int tempId = actualGroup.getTempId();</span>
<span class="nc" id="L2648">				TemplateDetails temp = TemplatesDB.getInstance().getTemplate(tempId);</span>
<span class="nc" id="L2649">				DocDB docDB = DocDB.getInstance();</span>
<span class="nc" id="L2650">				List&lt;DocDetails&gt; temps = docDB.getDocByGroup(Constants.getInt(&quot;tempGroupId&quot;));</span>
<span class="nc bnc" id="L2651" title="All 4 branches missed.">				if (temps!=null &amp;&amp; temp!=null)</span>
				{
<span class="nc" id="L2653">					String tempName = DB.internationalToEnglish(temp.getTempName());</span>
<span class="nc bnc" id="L2654" title="All 2 branches missed.">					for (DocDetails doc : temps)</span>
					{
<span class="nc bnc" id="L2656" title="All 2 branches missed.">						if (DB.internationalToEnglish(doc.getTitle()).equalsIgnoreCase(tempName))</span>
						{
<span class="nc" id="L2658">							newPageDocIdTemplate = -doc.getDocId();</span>
<span class="nc" id="L2659">							break;</span>
						}
<span class="nc" id="L2661">					}</span>
				}
<span class="nc" id="L2663">			}</span>
			else
			{
<span class="nc" id="L2666">				newPageDocIdTemplate = -groupNewPageDocIdTemplate;</span>
			}
		}
<span class="nc" id="L2669">		return(newPageDocIdTemplate);</span>
	}

	/**
	 * Vymazanie adresara
	 * @param groupId - id adresara
	 * @param request - request (treba kvoli admin logu, ale moze byt aj null)
	 * @return
	 */
	public static boolean deleteGroup(int groupId, HttpServletRequest request)
	{
<span class="fc" id="L2680">		return deleteGroup(groupId, request, true, false);</span>
	}
	/**
	 * Vymazanie adresara
	 * @param groupId - id adresara
	 * @param request - request (treba kvoli admin logu, ale moze byt aj null)
	 * @param includeParent - urci, ci ma pri vymazani brat aj rodicovsky adresar
	 * @param permanentlyDelete - nevlozi do kosa, ale priamo vymaze
	 * @return
	 */
	public static boolean deleteGroup(int groupId, HttpServletRequest request, boolean includeParent, boolean permanentlyDelete)
	{
<span class="fc" id="L2692">		return deleteGroup(groupId, includeParent, permanentlyDelete, true);</span>
	}

	private static void deleteGroupsApprove(String groups) {
<span class="fc" id="L2696">		(new SimpleQuery()).execute(&quot;DELETE FROM groups_approve WHERE group_id IN (&quot;+groups+&quot;)&quot;);</span>
<span class="fc" id="L2697">	}</span>

	/**
	 * Vymazanie adresara
	 * @param groupId - id adresara
	 * @param request - request (treba kvoli admin logu, ale moze byt aj null)
	 * @param includeParent - urci, ci ma pri vymazani brat aj rodicovsky adresar
	 * @param permanentlyDelete - nevlozi do kosa, ale priamo vymaze
	 * @param publishEvents - ak je true, su vyvolane udalosti (false potrebne ak napr. reagujeme na udalost a potrebujeme znova upravit adresar a nechceme aby doslo k zacykleniu)
	 * @return
	 */
	public static boolean deleteGroup(int groupId, boolean includeParent, boolean permanentlyDelete, boolean publishEvents)
	{
<span class="fc" id="L2710">		Connection db_conn = null;</span>
<span class="fc" id="L2711">		PreparedStatement ps = null;</span>
<span class="fc" id="L2712">		GroupsDB groupsDB = GroupsDB.getInstance();</span>

		//kontrola prav
<span class="fc" id="L2715">		GroupDetails group = groupsDB.getGroup(groupId);</span>

<span class="pc bpc" id="L2717" title="1 of 2 branches missed.">		if (InitServlet.isTypeCloud())</span>
		{
<span class="nc bnc" id="L2719" title="All 4 branches missed.">			if (group == null || group.getDomainName().equals(CloudToolsForCore.getDomainName())==false)</span>
			{
<span class="nc" id="L2721">				return false;</span>
			}
		}

		try
		{
<span class="pc bpc" id="L2727" title="1 of 4 branches missed.">			if (group!=null &amp;&amp; publishEvents) {</span>
<span class="fc" id="L2728">				(new WebjetEvent&lt;GroupDetails&gt;(group, WebjetEventType.ON_DELETE)).publishEvent();</span>
			}

			//	zmazanie grupy
<span class="fc" id="L2732">			db_conn = DBPool.getConnection();</span>

			// zisti ci sme v adresari /System/Trash (kos), ak nie presun, inak vymaz
<span class="fc" id="L2735">			Logger.debug(GroupsDB.class, &quot;MAZEM: &quot; + group);</span>

<span class="fc" id="L2737">			boolean foundSystemDir = false;</span>
<span class="fc" id="L2738">			GroupDetails trashGroupDetails = null;</span>
<span class="fc" id="L2739">			boolean disableHistory = Constants.getBoolean(&quot;editorDisableHistory&quot;);</span>
<span class="pc bpc" id="L2740" title="1 of 2 branches missed.">			if (disableHistory == false)  {</span>
<span class="fc" id="L2741">				trashGroupDetails = groupsDB.getTrashGroup();</span>
			}

<span class="pc bpc" id="L2744" title="3 of 8 branches missed.">			if (permanentlyDelete || trashGroupDetails == null || trashGroupDetails.getGroupId()==groupId || groupsDB.isInTrash(groupId))</span>
			{
      			// ziskaj zoznam groups (tejto a podskupin)
<span class="fc" id="L2747">				StringBuilder groups = new StringBuilder();</span>
				//List subGroups = groupsDB.getGroups(my_form.getGroupId());
<span class="fc" id="L2749">				List&lt;GroupDetails&gt; subGroups = groupsDB.getGroupsTree(groupId, includeParent, true);</span>

<span class="fc bfc" id="L2751" title="All 2 branches covered.">				for (GroupDetails element : subGroups)</span>
				{
<span class="fc bfc" id="L2753" title="All 2 branches covered.">					if (groups.length() &gt; 0)</span>
<span class="fc" id="L2754">						groups.append(',');</span>
<span class="fc" id="L2755">					groups.append(element.getGroupId());</span>
					//refresh cache
<span class="fc" id="L2757">					groupsDB.removeGroupFromCache(element, false);</span>

<span class="pc bpc" id="L2759" title="2 of 4 branches missed.">					if(foundSystemDir == false &amp;&amp; &quot;System&quot;.equalsIgnoreCase(element.getGroupName())) foundSystemDir = true;</span>
<span class="fc" id="L2760">				}</span>

<span class="pc bpc" id="L2762" title="1 of 2 branches missed.">				if(Tools.isNotEmpty(groups))	//ak nezaratam rodicovsky adresa, moze byt groups prazdne v pripade, ak rodicovsky adresar nemal ziadne podadresare</span>
				{
					//vymaz stranky
<span class="fc" id="L2765">					String sql = &quot;DELETE FROM documents WHERE group_id IN (&quot;+groups+&quot;)&quot;;</span>
<span class="fc" id="L2766">					ps = db_conn.prepareStatement(sql);</span>
<span class="fc" id="L2767">					ps.executeUpdate();</span>
<span class="fc" id="L2768">					ps.close();</span>
<span class="fc" id="L2769">					ps = null;</span>

					//vymaz adresare
<span class="fc" id="L2772">					sql = &quot;DELETE FROM groups WHERE group_id IN (&quot;+groups+&quot;)&quot;;</span>
<span class="fc" id="L2773">					ps = db_conn.prepareStatement(sql);</span>
<span class="fc" id="L2774">					ps.executeUpdate();</span>
<span class="fc" id="L2775">					ps.close();</span>
<span class="fc" id="L2776">					ps = null;</span>

					//Vymaz approve
<span class="fc" id="L2779">					deleteGroupsApprove(groups.toString());</span>
				}

<span class="fc" id="L2782">				Adminlog.add(Adminlog.TYPE_GROUP, &quot;Delete group: &quot; + group, groupId, -1);</span>
<span class="fc" id="L2783">			}</span>
			else
			{
      		// presun adresar do trashu
<span class="fc" id="L2787">				String sql = &quot;UPDATE groups SET parent_group_id=?, sync_status=1 WHERE group_id=?&quot;;</span>
<span class="fc" id="L2788">				ps = db_conn.prepareStatement(sql);</span>
<span class="fc" id="L2789">				ps.setInt(1, trashGroupDetails.getGroupId());</span>
<span class="fc" id="L2790">				ps.setInt(2, groupId);</span>
<span class="fc" id="L2791">				ps.executeUpdate();</span>
<span class="fc" id="L2792">				ps.close();</span>
<span class="fc" id="L2793">				ps = null;</span>

<span class="fc" id="L2795">				Adminlog.add(Adminlog.TYPE_GROUP, &quot;Delete group (move to trash): &quot; + group, groupId, -1);</span>

				//refresh cache
<span class="fc" id="L2798">				groupsDB.findGroup(groupId).setParentGroupId( trashGroupDetails.getGroupId() );</span>

				//deaktivuj vsetky stranky v tejto skupine a podskupinach
<span class="fc" id="L2801">				StringBuilder groups = new StringBuilder();</span>
<span class="fc" id="L2802">				List&lt;GroupDetails&gt; subGroups = groupsDB.getGroupsTree(groupId, true, true);</span>

<span class="fc bfc" id="L2804" title="All 2 branches covered.">				for (GroupDetails g : subGroups)</span>
				{
<span class="fc" id="L2806">					g.setFullPath(groupsDB.getPath(g.getGroupId()));</span>

<span class="fc bfc" id="L2808" title="All 2 branches covered.">					if (groups.length() &gt; 0)</span>
<span class="fc" id="L2809">						groups.append(',').append(g.getGroupId());</span>
					else
<span class="fc" id="L2811">						groups.append(g.getGroupId());</span>

<span class="pc bpc" id="L2813" title="2 of 4 branches missed.">					if(foundSystemDir == false &amp;&amp; &quot;System&quot;.equalsIgnoreCase(g.getGroupName())) foundSystemDir = true;</span>
<span class="fc" id="L2814">				}</span>
				// zakaz zobrazovanie stranok
<span class="fc" id="L2816">				sql = &quot;UPDATE documents SET available=?, sync_status=1 WHERE group_id IN (&quot;+groups.toString()+&quot;)&quot;;</span>
<span class="fc" id="L2817">				ps = db_conn.prepareStatement(sql);</span>
<span class="fc" id="L2818">				ps.setBoolean(1, false);</span>
<span class="fc" id="L2819">				ps.executeUpdate();</span>
<span class="fc" id="L2820">				ps.close();</span>
<span class="fc" id="L2821">				ps = null;</span>

				//aktualizuj FT stplce
<span class="fc" id="L2824">				DocDB.updateFileNameField(groupId);</span>
      		}

      		//ak sa jedna o system adresar, refreshnem zoznam tychto stranok
<span class="pc bpc" id="L2828" title="1 of 2 branches missed.">			if(foundSystemDir) groupsDB.getAllSystemFolders(true);</span>

<span class="fc" id="L2830">			db_conn.close();</span>
<span class="fc" id="L2831">			db_conn = null;</span>
			//oznam ostatnym Node-om, ze sa nieco zmenilo
<span class="fc" id="L2833">			ClusterDB.addRefresh(GroupsDB.class);</span>
<span class="fc" id="L2834">			ClusterDB.addRefresh(DocDB.class);</span>
<span class="fc" id="L2835">			GroupsDB.getInstance(true);</span>
<span class="fc" id="L2836">			DocDB.getInstance(true);</span>

<span class="pc bpc" id="L2838" title="1 of 4 branches missed.">			if (group!=null &amp;&amp; publishEvents) (new WebjetEvent&lt;GroupDetails&gt;(group, WebjetEventType.AFTER_DELETE)).publishEvent();</span>

<span class="fc" id="L2840">			return(true);</span>
		}
<span class="nc" id="L2842">		catch (Exception ex)</span>
		{
<span class="nc" id="L2844">			sk.iway.iwcm.Logger.error(ex);</span>
		}
		finally
		{
			try
			{
<span class="pc bpc" id="L2850" title="1 of 2 branches missed.">				if (ps != null)</span>
<span class="nc" id="L2851">					ps.close();</span>
<span class="pc bpc" id="L2852" title="1 of 2 branches missed.">				if (db_conn != null)</span>
<span class="nc" id="L2853">					db_conn.close();</span>
			}
<span class="nc" id="L2855">			catch (Exception ex2)</span>
			{
<span class="fc" id="L2857">			}</span>
		}
<span class="nc" id="L2859">		return(false);</span>
	}

	/**
	 * Vrati TreeMap so zoznamom = retazec id adresarov oddelenych ciarkami pridelenych ku skupine obsiahnutej v hodnote kluca
	 * @return
	 */
	public static Map&lt;Integer, String&gt; getProtectedGroups()
	{
<span class="nc" id="L2868">		GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="nc" id="L2869">		List&lt;GroupDetails&gt; groups = groupsDB.getGroupsAll();</span>
<span class="nc" id="L2870">		TreeMap&lt;Integer, String&gt; tm = new TreeMap&lt;&gt;();</span>
<span class="nc bnc" id="L2871" title="All 2 branches missed.">		for (GroupDetails groupDetails : groups)</span>
		{
<span class="nc bnc" id="L2873" title="All 2 branches missed.">			if(Tools.isNotEmpty(groupDetails.getPasswordProtected()))</span>
			{
<span class="nc bnc" id="L2875" title="All 2 branches missed.">				if(groupDetails.getPasswordProtected().indexOf(',') &lt; 0)</span>
				{
<span class="nc bnc" id="L2877" title="All 2 branches missed.">					if(tm.containsKey(Integer.valueOf(groupDetails.getPasswordProtected())))</span>
					{
<span class="nc" id="L2879">						String tmp = tm.get(Integer.valueOf(groupDetails.getPasswordProtected()));</span>
<span class="nc" id="L2880">						tm.put(Integer.valueOf(groupDetails.getPasswordProtected()), tmp.concat(groupDetails.getGroupId()+&quot;,&quot;));</span>

<span class="nc" id="L2882">					}else{</span>
<span class="nc" id="L2883">						tm.put(Integer.valueOf(groupDetails.getPasswordProtected()), groupDetails.getGroupId()+&quot;,&quot;);</span>
					}
				}else{
<span class="nc" id="L2886">					String[] tmp = groupDetails.getPasswordProtected().split(&quot;,&quot;);</span>
<span class="nc bnc" id="L2887" title="All 2 branches missed.">					for (int i = 0; i &lt; tmp.length; i++)</span>
					{
<span class="nc bnc" id="L2889" title="All 2 branches missed.">						if(tm.containsKey(Integer.valueOf(tmp[i])))</span>
						{
<span class="nc" id="L2891">							String tmp2 = tm.get(Integer.valueOf(tmp[i]));</span>
<span class="nc" id="L2892">							tm.put(Integer.valueOf(tmp[i]), tmp2.concat(groupDetails.getGroupId()+&quot;,&quot;));</span>

<span class="nc" id="L2894">						}else{</span>
<span class="nc" id="L2895">							tm.put(Integer.valueOf(tmp[i]), groupDetails.getGroupId()+&quot;,&quot;);</span>
						}
					}
				}
			}
<span class="nc" id="L2900">		}</span>
		/*
		for (Iterator iterator = tm.entrySet().iterator(); iterator.hasNext();)
		{
			Map.Entry&lt;Integer, String&gt; key = (Map.Entry&lt;Integer, String&gt;)iterator.next();
			System.out.println(&quot;&gt;&gt; KEY: &quot;+key.getKey()+&quot; &gt; VALUE: &quot;+key.getValue());
		}
		*/
<span class="nc" id="L2908">		return tm;</span>
	}

	/**
	 * Vrati zoznam ID podadresarov zadaneho adresara (vratane)
	 * napr 1,5,77,28
	 * @param groupId
	 * @return
	 */
	public String getSubgroupsIds(int groupId)
	{
<span class="fc" id="L2919">		List&lt;GroupDetails&gt; subGroups = getGroupsTree(groupId, false, true);</span>
<span class="fc" id="L2920">		StringBuilder groupIds = new StringBuilder().append(groupId);</span>
<span class="fc bfc" id="L2921" title="All 2 branches covered.">		for (GroupDetails grp : subGroups)</span>
		{
<span class="fc" id="L2923">			groupIds.append(',').append(grp.getGroupId());</span>
<span class="fc" id="L2924">		}</span>

<span class="fc" id="L2926">		return groupIds.toString();</span>
	}

	/**
	 * Vrati zoznam ID adresarov so zadanou domenou (pouzitelne pre IN select)
	 * @param domainName
	 * @return
	 */
	public String getSubgroupsIds(String domainName)
	{
<span class="pc bpc" id="L2936" title="1 of 2 branches missed.">		if (Tools.isEmpty(domainName)) domainName = &quot;&quot;;</span>

<span class="fc" id="L2938">		StringBuilder groupIds = new StringBuilder(&quot;-1&quot;);</span>
<span class="fc bfc" id="L2939" title="All 2 branches covered.">		for (GroupDetails grp : groups)</span>
		{
<span class="fc bfc" id="L2941" title="All 2 branches covered.">			if (domainName.equals(grp.getDomainName()))</span>
			{
<span class="fc" id="L2943">				groupIds.append(',').append(grp.getGroupId());</span>
			}
<span class="fc" id="L2945">		}</span>

<span class="pc bpc" id="L2947" title="1 of 2 branches missed.">		if (Tools.isEmpty(groupIds.toString())) return &quot;-1&quot;;</span>

<span class="fc" id="L2949">		return groupIds.toString();</span>
	}

	/**
	 * expanduje zadany zoznam skupin na podadresare (vratane rodica), neprejde cez interne adresare
	 * @param rootGroups
	 * @return
	 */
	public int[] expandGroupIdsToChilds(int[] rootGroups)
	{
<span class="fc" id="L2959">		return expandGroupIdsToChilds(rootGroups, false);</span>
	}

	/**
	 * expanduje zadany zoznam skupin na podadresare (vratane rodica)
	 * @param rootGroups
	 * @param includeInternal
	 * @return
	 */
	public int[] expandGroupIdsToChilds(int[] rootGroups, boolean includeInternal)
	{
<span class="pc bpc" id="L2970" title="1 of 4 branches missed.">		if (rootGroups == null || rootGroups.length==0) return new int[0];</span>

<span class="fc" id="L2972">		StringBuilder searchGroups = null;</span>
<span class="fc bfc" id="L2973" title="All 2 branches covered.">		for (int searchRootGroupId : rootGroups)</span>
		{
<span class="fc" id="L2975">			List&lt;GroupDetails&gt; searchGroupsArray = getGroupsTree(searchRootGroupId, true, true);</span>
<span class="fc bfc" id="L2976" title="All 2 branches covered.">			for (GroupDetails group : searchGroupsArray)</span>
			{
<span class="pc bpc" id="L2978" title="1 of 6 branches missed.">				if (group != null &amp;&amp; (includeInternal || group.isInternal()==false))</span>
				{
					//hladaj iba v grupach co nie su pass protected
<span class="fc bfc" id="L2981" title="All 2 branches covered.">					if (searchGroups == null)</span>
					{
<span class="fc" id="L2983">						searchGroups = new StringBuilder(String.valueOf(group.getGroupId()));</span>
					}
					else
					{
<span class="fc" id="L2987">						searchGroups.append(&quot;,&quot;).append(String.valueOf(group.getGroupId()));</span>
					}
				}
<span class="fc" id="L2990">			}</span>
		}

<span class="fc bfc" id="L2993" title="All 2 branches covered.">		if (searchGroups == null) return new int[0];</span>

<span class="fc" id="L2995">		return Tools.getTokensInt(searchGroups.toString(), &quot;,&quot;);</span>
	}

	/**
	 * Vypocita hodnotu sortPriority pre novy adresar v zadanom sub adresari
	 * @param parentGroupId
	 * @return
	 */
	public int getDefaultSortPriority(int parentGroupId)
	{
<span class="pc bpc" id="L3005" title="3 of 4 branches missed.">		if (parentGroupId &lt; 1 &amp;&amp; Constants.getBoolean(&quot;enableStaticFilesExternalDir&quot;))</span>
		{
			//pre multidomain s externymi vraciame pre root natvrdo 100 aby sa sortovali podla abecedy
<span class="nc" id="L3008">			return 100;</span>
		}

<span class="fc" id="L3011">		int maxSortOrder = 0;</span>
<span class="pc bpc" id="L3012" title="1 of 2 branches missed.">		if (Constants.getBoolean(&quot;sortPriorityIncremental&quot;))</span>
		{
<span class="fc" id="L3014">			GroupDetails parentGroup = getGroup(parentGroupId);</span>
<span class="pc bpc" id="L3015" title="1 of 2 branches missed.">			if (parentGroup!=null)</span>
			{
<span class="fc" id="L3017">				maxSortOrder = (int)Math.ceil(parentGroup.getSortPriority()/10.0f) * 100;</span>
			}
		}

<span class="fc bfc" id="L3021" title="All 2 branches covered.">		for (GroupDetails grp : getGroups(parentGroupId))</span>
		{
<span class="fc bfc" id="L3023" title="All 2 branches covered.">			if (grp.getSortPriority() &gt; maxSortOrder) maxSortOrder = grp.getSortPriority();</span>
<span class="fc" id="L3024">		}</span>
<span class="fc" id="L3025">		return maxSortOrder + 10;</span>
	}

	/**
	 * Removes a group from current cache
	 *
	 * @param group group, which will be erased from cache
	 */
	private void removeGroupFromCache(GroupDetails group, boolean isUpdateProcess)
	{
		try
		{
<span class="fc" id="L3037">			synchronized(groups)</span>
			{
<span class="fc bfc" id="L3039" title="All 2 branches covered.">				if (groups.remove(group)==false)</span>
				{
<span class="fc" id="L3041">					int index = Collections.binarySearch(groups, group, groupsDbSorter);</span>
<span class="pc bpc" id="L3042" title="1 of 2 branches missed.">					if (index &gt; 0)</span>
<span class="nc" id="L3043">						groups.remove(index);</span>
					else
					{
						//zmenilo sa jej sort priority - nemozeme vyhladat binarne, musime sekvencne
<span class="fc" id="L3047">						group = getGroup(group.getGroupId());</span>
<span class="fc" id="L3048">						index = groups.indexOf(group);</span>
<span class="fc" id="L3049">						groups.remove(index);</span>
					}
				}
<span class="fc" id="L3052">			}</span>
<span class="fc" id="L3053">			getGroupDetailsMap().remove(group.getGroupId());</span>

			//zresetuj all tree cache
<span class="fc" id="L3056">			groupsTreeAllCache = null;</span>

<span class="fc" id="L3058">			idToGroups.remove(group.getGroupId());</span>

<span class="pc bpc" id="L3060" title="2 of 6 branches missed.">			if(Tools.isNotEmpty(group.getDomainName()) &amp;&amp; group.getParentGroupId() == 0 &amp;&amp; isUpdateProcess==false)</span>
			{
				//najdi najnizsie groupId v tejto domene (domainId je najnizsie groupId v domene)
<span class="nc" id="L3063">				int lowestGroupId = group.getGroupId();</span>
<span class="nc bnc" id="L3064" title="All 2 branches missed.">				for (GroupDetails domainGroup : groups) {</span>
<span class="nc bnc" id="L3065" title="All 4 branches missed.">					if (domainGroup.getParentGroupId()==0 &amp;&amp; group.getDomainName().equals(domainGroup.getDomainName())) {</span>
<span class="nc bnc" id="L3066" title="All 2 branches missed.">						if (domainGroup.getGroupId()&lt;lowestGroupId) lowestGroupId = domainGroup.getGroupId();</span>
					}
<span class="nc" id="L3068">				}</span>
				//ak mazana grupa je s najnizsim groupId, zmazme aj so zoznamu domen
<span class="nc bnc" id="L3070" title="All 2 branches missed.">				if (lowestGroupId==group.getGroupId()) {</span>
<span class="nc" id="L3071">					domainIds.remove(group.getDomainName());</span>
					//musime aj tak spravit reload, lebo hladame teraz nove domainId
<span class="nc" id="L3073">					GroupsDB.getInstance(true);</span>
				}
			}
		}
<span class="fc" id="L3077">		catch (ConcurrentModificationException|ArrayIndexOutOfBoundsException e)</span>
		{
			//nastala nam chyba, najrozumnejsie je spravit nacitanie novej instancie
<span class="fc" id="L3080">			GroupsDB.getInstance(true);</span>
<span class="fc" id="L3081">		}</span>
<span class="fc" id="L3082">	}</span>

	/**
	 * Inserts a group into cache, preserving GroupsDB sort invariant
	 *
	 * @param newGroup a group to be inserted
	 */
	private void insertGroupInCache(GroupDetails newGroup)
	{
		try
		{
<span class="fc" id="L3093">			synchronized(groups)</span>
			{
<span class="fc" id="L3095">				int index = Collections.binarySearch(groups, newGroup, groupsDbSorter);</span>
				//vlastnost binarySearch - ak neobsahuje takyto prvok, tak vrati zaporny index
				//toho, kde by sa mal nachadzat zmenseny o 1
<span class="fc bfc" id="L3098" title="All 2 branches covered.">				if (index &lt; 0)</span>
<span class="fc" id="L3099">					index = - index - 1;</span>

				//double check
<span class="fc bfc" id="L3102" title="All 2 branches covered.">				Optional&lt;GroupDetails&gt; existing = groups.stream().filter(g -&gt; g.getGroupId()==newGroup.getGroupId()).findFirst();</span>
<span class="fc bfc" id="L3103" title="All 2 branches covered.">				if (existing.isPresent()==false) {</span>
<span class="fc" id="L3104">					groups.add(index, newGroup);</span>
				}
<span class="fc" id="L3106">			}</span>
<span class="fc" id="L3107">			getGroupDetailsMap().put(newGroup.getGroupId(), newGroup);</span>

			//zresetuj all tree cache
<span class="fc" id="L3110">			groupsTreeAllCache = null;</span>

<span class="pc bpc" id="L3112" title="1 of 4 branches missed.">			if(Tools.isNotEmpty(newGroup.getDomainName()) &amp;&amp; newGroup.getParentGroupId() == 0)</span>
			{
<span class="pc bpc" id="L3114" title="1 of 2 branches missed.">			   if (domainIds.get(newGroup.getDomainName())==null) domainIds.put(newGroup.getDomainName(), newGroup.getGroupId());</span>
			}
<span class="fc" id="L3116">			idToGroups.put(newGroup.getGroupId(), newGroup);</span>

<span class="pc bpc" id="L3118" title="1 of 2 branches missed.">			if (Tools.isNotEmpty(newGroup.getDomainName()))</span>
			{
				//oznam DocDB ze mame taku domenu (vytvori hash tabulku pre danu domenu)
<span class="fc" id="L3121">				DocDB docDB = DocDB.getInstance();</span>
<span class="fc" id="L3122">				docDB.getUrlsByUrlDomains(newGroup.getDomainName(), true);</span>
			}
		}
<span class="nc" id="L3125">		catch (ConcurrentModificationException|ArrayIndexOutOfBoundsException ex)</span>
		{
			//nastala nam chyba, najrozumnejsie je spravit nacitanie novej instancie
<span class="nc" id="L3128">			GroupsDB.getInstance(true);</span>
<span class="fc" id="L3129">		}</span>
<span class="fc" id="L3130">	}</span>

	/**
	 * Replaces a group already existing in cache with a new one, preserving
	 * their natural sort.
	 * @param inCache old one
	 * @param notInCache new one
	 */
	private static void replaceGroupInCache(GroupDetails inCache,GroupDetails notInCache)
	{
<span class="fc" id="L3140">		GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="fc" id="L3141">		groupsDB.removeGroupFromCache(inCache, true);</span>
<span class="fc" id="L3142">		groupsDB = GroupsDB.getInstance();</span>
<span class="fc" id="L3143">		groupsDB.insertGroupInCache(notInCache);</span>
<span class="fc" id="L3144">	}</span>

	private static Map&lt;Integer ,GroupDetails&gt; getGroupDetailsMap()
	{
<span class="fc" id="L3148">		return getInstance().idToGroups;</span>
	}


	/**
	 * Vrati korenove adresare
	 * @return
	 */
	public static List&lt;GroupDetails&gt; getRootGroups()
	{
<span class="fc" id="L3158">		return new ComplexQuery().setSql(&quot;SELECT * FROM groups WHERE parent_group_id &lt;= 0 ORDER BY sort_priority ASC, group_name ASC&quot;).list(new Mapper&lt;GroupDetails&gt;()</span>
<span class="fc" id="L3159">		{</span>
			public GroupDetails map(ResultSet rs) throws SQLException
			{
<span class="fc" id="L3162">				return fillFieldsByResultSet(rs);</span>
			}

		});
	}

	public void resetGroupsTreeAllCache()
	{
<span class="nc" id="L3170">		groupsTreeAllCache = null;</span>
<span class="nc" id="L3171">	}</span>

	/**
	 * Test if at least one groupId is editable by user
	 * @param user
	 * @param groupIds
	 * @return
	 */
	public static boolean isGroupsEditable(UserDetails user, String groupIds) {
<span class="fc" id="L3180">		int[] groupIdsInt = Tools.getTokensInt(groupIds, &quot;,&quot;);</span>
<span class="fc" id="L3181">		return isGroupsEditable(user, groupIdsInt);</span>
	}

	/**
	 * Test if at least one groupId is editable by user
	 * @param user
	 * @param groupIds
	 * @return
	 */
	public static boolean isGroupsEditable(UserDetails user, int[] groupIds) {
<span class="pc bpc" id="L3191" title="1 of 4 branches missed.">		if (groupIds == null || groupIds.length==0) return true;</span>

<span class="pc bpc" id="L3193" title="1 of 2 branches missed.">		if (user == null) return false;</span>

<span class="fc bfc" id="L3195" title="All 2 branches covered.">		for (int groupId : groupIds) {</span>
<span class="fc bfc" id="L3196" title="All 2 branches covered.">			if (isGroupEditable(user, groupId)) return true;</span>
		}

<span class="fc" id="L3199">		return false;</span>
	}

	/**
	 * Otestuje, ci zadany adresar je pouzivatelom nastaveny ako editovatelny (user.getEditableGroups)
	 * @param user
	 * @param groupId
	 * @return
	 */
	public static boolean isGroupEditable(UserDetails user, int groupId)
	{
<span class="fc bfc" id="L3210" title="All 2 branches covered.">		if (groupId &lt; 1) return true;</span>

<span class="pc bpc" id="L3212" title="1 of 2 branches missed.">		if (user == null) return false;</span>
<span class="fc bfc" id="L3213" title="All 2 branches covered.">		if (Tools.isNotEmpty(user.getEditableGroups(true)))</span>
		{
<span class="fc" id="L3215">			GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="fc" id="L3216">			String parentGroups = &quot;,&quot; + groupId + &quot;,&quot; + groupsDB.getParents(groupId)+&quot;,&quot;;</span>
<span class="fc" id="L3217">			StringTokenizer st = new StringTokenizer(user.getEditableGroups(true), &quot;,&quot;);</span>
			String id;
			int i_id;
<span class="fc bfc" id="L3220" title="All 2 branches covered.">			while (st.hasMoreTokens())</span>
			{
<span class="fc" id="L3222">				id = st.nextToken().trim();</span>
				try
				{
<span class="fc" id="L3225">					i_id = Integer.parseInt(id);</span>
<span class="fc bfc" id="L3226" title="All 2 branches covered.">					if (parentGroups.indexOf(&quot;,&quot; + i_id + &quot;,&quot;) != -1)</span>
					{
<span class="fc" id="L3228">						return true;</span>
					}
				}
<span class="nc" id="L3231">				catch (Exception ex)</span>
				{

<span class="pc" id="L3234">				}</span>
			}
<span class="fc" id="L3236">		}</span>
		else
		{
<span class="fc" id="L3239">			return true;</span>
		}
<span class="fc" id="L3241">		return false;</span>
	}

	/**
	 * Testuje, ci moze user vidiet adresar, pouziva sa na overenie ked ma editaciu az niekde
	 * do poadresara, ale v FE potrebujeme zobrazit aj parentov v stromovej strukture
	 * @param user
	 * @param groupId
	 * @return
	 */
    public static boolean isGroupViewable(UserDetails user, int groupId) {
<span class="fc bfc" id="L3252" title="All 2 branches covered.">        if (groupId &lt; 1) return true;</span>

<span class="pc bpc" id="L3254" title="1 of 2 branches missed.">        if (user == null) return false;</span>

<span class="pc bpc" id="L3256" title="1 of 4 branches missed.">        if (user.getEditableGroups() == null || user.getEditableGroups().isEmpty()) {</span>
<span class="fc" id="L3257">            return true;</span>
        }

<span class="fc" id="L3260">        List&lt;GroupDetails&gt; editableGroups = getGroupsList(user.getEditableGroups());</span>
<span class="fc" id="L3261">        GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="fc bfc" id="L3262" title="All 2 branches covered.">        for (GroupDetails editableGroup : editableGroups) {</span>
<span class="fc" id="L3263">            List&lt;GroupDetails&gt; parents = groupsDB.getParentGroups(editableGroup.getGroupId(), true);</span>
<span class="fc bfc" id="L3264" title="All 4 branches covered.">            if (parents.stream().anyMatch(groupDetails -&gt; groupDetails.getGroupId() == groupId)) {</span>
<span class="fc" id="L3265">                return true;</span>
            }
<span class="fc" id="L3267">        }</span>

        //over aj zoznam pridelenych stranok
<span class="fc bfc" id="L3270" title="All 2 branches covered.">        if (Tools.isNotEmpty(user.getEditablePages())) {</span>
<span class="fc" id="L3271">            List&lt;DocDetails&gt; docs = UserTools.getEditablePages(user.getEditablePages());</span>
<span class="fc bfc" id="L3272" title="All 2 branches covered.">            for (DocDetails doc : docs) {</span>
<span class="fc" id="L3273">                List&lt;GroupDetails&gt; parents = groupsDB.getParentGroups(doc.getGroupId());</span>
<span class="fc" id="L3274">                parents.add(doc.getGroup());</span>
<span class="fc bfc" id="L3275" title="All 4 branches covered.">                if (parents.stream().anyMatch(groupDetails -&gt; groupDetails.getGroupId() == groupId)) {</span>
<span class="fc" id="L3276">                    return true;</span>
                }
<span class="fc" id="L3278">            }</span>
        }

<span class="fc" id="L3281">        return false;</span>
    }

    /**
     * Vrati list GroupDetails na zaklade ciarkou oddeleneho zoznamu ID adresarov
     * @param tokens - ciarkou oddeleny zoznam adresarov (z UserDetails.editableGroups)
     * @return
     */
    public static List&lt;GroupDetails&gt; getGroupsList(String tokens) {
<span class="fc" id="L3290">        List&lt;GroupDetails&gt; result = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L3292" title="1 of 2 branches missed.">        if (Tools.isEmpty(tokens)) {</span>
<span class="nc" id="L3293">            return Collections.emptyList();</span>
        }

<span class="fc" id="L3296">        String[] ids = Tools.getTokens(tokens, &quot;,&quot;);</span>

<span class="pc bpc" id="L3298" title="1 of 2 branches missed.">        if (ids.length == 0) {</span>
<span class="nc" id="L3299">            return Collections.emptyList();</span>
        }

<span class="fc" id="L3302">        GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="fc bfc" id="L3303" title="All 2 branches covered.">        for (String id : ids) {</span>
<span class="fc" id="L3304">        	int intId = Tools.getIntValue(id, 0);</span>
<span class="fc" id="L3305">            GroupDetails group = groupsDB.getGroup(intId);</span>
<span class="fc bfc" id="L3306" title="All 2 branches covered.">            if (group != null) {</span>
<span class="fc" id="L3307">                result.add(group);</span>
            }
        }

<span class="fc" id="L3311">        return result;</span>
    }

	/**
	 * Zrusi z nazvu adresara nepovolene znaky
	 * @param groupName
	 * @return
	 */
	public static String sanitizeGroupName(String groupName, boolean alsoSlash)
	{
<span class="fc bfc" id="L3321" title="All 2 branches covered.">		if (isEmpty(groupName))</span>
<span class="fc" id="L3322">			return &quot;&quot;;</span>
		//znak / nemozeme nahradzat priamo v GroupDetails.setGroupName(), pretoze pre userov s obmedzenymi pravami sa potom zle zobrazoval adresar (lebo sa mu do nazvu klonuje cela cesta, napr. /Interway/Novinky/
<span class="fc bfc" id="L3324" title="All 2 branches covered.">		if (alsoSlash)</span>
		{
<span class="fc" id="L3326">			groupName = Tools.replace(Tools.replace(groupName, &quot;\\&quot;, &quot;-&quot;), &quot;/&quot;, &quot;-&quot;);</span>
		}

<span class="fc" id="L3329">		return groupName.replace(&quot;/\n/gi&quot;, &quot; &quot;).replaceAll(&quot;/\\s+/gi&quot;, &quot; &quot;).replace('\\', '/').trim();</span>
	}

	/**
	 * Vrati  id root adresara danej domeny
	 * @param domain meno domeny
	 * @return
	 */
	public static int getDomainId(String domain)
	{
<span class="fc" id="L3339">		Integer id = getInstance().domainIds.get(domain);</span>
<span class="pc bpc" id="L3340" title="1 of 2 branches missed.">		if(id == null) id = -1;</span>
<span class="fc" id="L3341">		return id;</span>
	}

	/**
	 * Vrati adresar System ktory je v root adresari aktualnej domeny, teda napr. /www.interway.sk/System/
	 * @return
	 */
	public GroupDetails getLocalSystemGroup()
	{
<span class="fc" id="L3350">		String groupName = &quot;System&quot;;</span>
<span class="fc" id="L3351">		RequestBean rb = SetCharacterEncodingFilter.getCurrentRequestBean();</span>
<span class="pc bpc" id="L3352" title="1 of 2 branches missed.">		if (rb == null)</span>
		{
<span class="nc" id="L3354">			return null;</span>
		}

<span class="fc" id="L3357">		String domain = rb.getDomain();</span>
<span class="pc bpc" id="L3358" title="1 of 2 branches missed.">		if (Tools.isEmpty(domain)) return null;</span>
<span class="fc" id="L3359">		int rootGroupId = GroupsDB.getDomainId(domain);</span>
<span class="pc bpc" id="L3360" title="1 of 2 branches missed.">		if (rootGroupId &lt; 1) return null;</span>

<span class="pc bpc" id="L3362" title="1 of 2 branches missed.">		for (GroupDetails group : groups)</span>
		{
<span class="fc bfc" id="L3364" title="All 4 branches covered.">			if (group.getParentGroupId()==rootGroupId &amp;&amp; groupName.equalsIgnoreCase(group.getGroupName()))</span>
			{
				//vratime adresar, System v hlavnom priecinku domeny (stary system)
<span class="fc" id="L3367">				return (group);</span>
			}
<span class="fc bfc" id="L3369" title="All 6 branches covered.">			else if (group.getParentGroupId()&lt;1 &amp;&amp; groupName.equalsIgnoreCase(group.getGroupName()) &amp;&amp; domain.equalsIgnoreCase(group.getDomainName()))</span>
			{
				//ak sa jedna o ROOT priecinok System v aktualnej domene, vrat ten (WJ9 rezim)
<span class="fc" id="L3372">				return group;</span>
			}
<span class="fc" id="L3374">		}</span>

<span class="nc" id="L3376">		return (null);</span>
	}

	/**
	 * Vrati ID adresara System ktory je v root adresari aktualnej domeny, teda napr. /www.interway.sk/System/
	 * @return
	 */
	public int getLocalSystemGroupId()
	{
<span class="fc" id="L3385">		GroupDetails localSystem = getLocalSystemGroup();</span>
<span class="pc bpc" id="L3386" title="1 of 2 branches missed.">		if (localSystem != null) return localSystem.getGroupId();</span>

<span class="nc" id="L3388">		return -1;</span>
	}

	/**
	 * Vytvori novy root adresar a nastavi mu domenu
	 * ak uz domena existuje, vrati -1
	 * @param localDomainName
	 * @return
	 */
	public int createLocalDomain(String localDomainName)
	{
<span class="nc bnc" id="L3399" title="All 2 branches missed.">		if (Tools.isEmpty(localDomainName)) return -1;</span>

<span class="nc" id="L3401">		localDomainName = localDomainName.toLowerCase();</span>

<span class="nc bnc" id="L3403" title="All 2 branches missed.">		if(GroupsDB.getInstance().domainIds.containsKey(localDomainName))</span>
		{
<span class="nc" id="L3405">			Logger.debug(getClass(), &quot;Domain already exists: &quot; + localDomainName);</span>
<span class="nc" id="L3406">			return -1;</span>
		}
<span class="nc" id="L3408">		Logger.debug(getClass(), &quot;Creating domain root folder for domain: &quot; + localDomainName);</span>
<span class="nc" id="L3409">		int actualParent = 0;</span>
		String actualGroupName;
		GroupDetails actualGroup;
<span class="nc" id="L3412">		actualGroupName = localDomainName;</span>
<span class="nc" id="L3413">		actualGroup = getGroup(actualGroupName, actualParent);</span>
<span class="nc bnc" id="L3414" title="All 2 branches missed.">		if (actualGroup == null)</span>
		{
<span class="nc" id="L3416">			actualGroup = new GroupDetails();</span>
<span class="nc" id="L3417">			actualGroup.setParentGroupId(0);</span>
<span class="nc" id="L3418">			actualGroup.setGroupId(-1);</span>
<span class="nc" id="L3419">			actualGroup.setDefaultDocId(-1);</span>
<span class="nc" id="L3420">			actualGroup.setGroupName(actualGroupName);</span>
<span class="nc" id="L3421">			actualGroup.setNavbar(actualGroupName);</span>
<span class="nc" id="L3422">			actualGroup.setUrlDirName(&quot;/&quot;);</span>
<span class="nc" id="L3423">			actualGroup.setSortPriority(getDefaultSortPriority(actualGroup.getParentGroupId()));</span>
<span class="nc" id="L3424">			actualGroup.setDomainName(localDomainName);</span>
<span class="nc" id="L3425">			setGroup(actualGroup);</span>
<span class="nc" id="L3426">			Logger.debug(getClass(), &quot;Domain root folder for domain: &quot; + localDomainName + &quot; created, id: &quot; + actualGroup.getGroupId());</span>
		}
		else
		{
<span class="nc" id="L3430">			Logger.debug(getClass(), &quot;Domain root folder for domain: &quot; + localDomainName + &quot; already exists, id: &quot; + actualGroup.getGroupId());</span>
		}
<span class="nc" id="L3432">		return actualGroup.getGroupId();</span>
	}

	/**
	 * Zmeni nazov hlavnej stranky groupy podla nazvu grupy, v ktorej sa stranka nachadza
	 * @param gd - ID grupy ktorej ktorej GroupName sa nastavi ako Title pre document.
	 * 				Ak je null, nic sa nevykona.
	 */
	private boolean changeDocTitle(GroupDetails gd)
	{
<span class="pc bpc" id="L3442" title="3 of 12 branches missed.">		if(gd != null &amp;&amp; gd.isInternal()==false &amp;&amp; gd.getMenuType()!=GroupDetails.MENU_TYPE_HIDDEN &amp;&amp; gd.getFullPath()!=null &amp;&amp; gd.getFullPath().indexOf(&quot;/System&quot;)==-1 &amp;&amp; gd.getParentGroupId()&gt;0)</span>
		{
<span class="fc" id="L3444">			DocDetails docDetails = DocDB.getInstance().getDoc(gd.getDefaultDocId());</span>
<span class="pc bpc" id="L3445" title="2 of 6 branches missed.">			if(docDetails != null &amp;&amp; (docDetails.getTitle() != null &amp;&amp; !gd.getGroupName().equals(docDetails.getTitle())))</span>
			{
<span class="fc" id="L3447">				Logger.debug(DocDB.class, &quot;Renaming document: &quot;+docDetails.getDocId()+&quot; to name :&quot;+gd.getGroupName());</span>
<span class="fc" id="L3448">				docDetails.setTitle(gd.getGroupName());</span>
<span class="fc" id="L3449">				docDetails.setNavbar(gd.getGroupName());</span>
<span class="fc" id="L3450">				DocDB.saveDoc(docDetails);</span>
<span class="fc" id="L3451">				return true;</span>
			}
<span class="fc" id="L3453">			return false;</span>
		}
		else
		{
<span class="fc" id="L3457">			return false;</span>
		}
	}

	/**
	 * Zmeni domenu pre adresar aj podadresare (pouzitie v cloud nodoch - zmena domeny
	 *
	 * @param oldDomain povodna domena
	 * @param newDomain nova domena
	 * @return
	 */
	public static boolean changeDomain(String oldDomain, String newDomain)
	{
<span class="nc" id="L3470">		GroupsDB groupsDb = GroupsDB.getInstance();</span>
<span class="nc" id="L3471">		DocDB docDb = DocDB.getInstance();</span>
<span class="nc" id="L3472">		GroupDetails group = groupsDb.getGroup(oldDomain, 0);</span>
<span class="nc" id="L3473">		StringBuilder messageToAdminlog = new StringBuilder();</span>
<span class="nc" id="L3474">		messageToAdminlog.append(&quot;Pozadovana zmena domeny OLD: '&quot;).append(oldDomain).append(&quot;', NEW: '&quot;).append(newDomain).append(&quot;' \n&quot;);</span>
<span class="nc" id="L3475">	 	String groupIds = GroupsDB.getInstance().getSubgroupsIds(group.getGroupId());</span>
<span class="nc" id="L3476">	 	messageToAdminlog.append(&quot;Zoznam ID adresarov: &quot;).append(groupIds).append(&quot;\n&quot;);</span>
<span class="nc" id="L3477">	 	int[] ids = Tools.getTokensInt(groupIds, &quot;,&quot;);</span>
<span class="nc" id="L3478">	 	List&lt;DocDetails&gt; oldDocs = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L3480" title="All 2 branches missed.">		for (int i=0;i&lt;ids.length;i++)</span>
		{
<span class="nc" id="L3482">			List&lt;DocDetails&gt; docsInGroup = docDb.getBasicDocDetailsByGroup(ids[i], DocDB.ORDER_PRIORITY);</span>
<span class="nc bnc" id="L3483" title="All 4 branches missed.">			if (docsInGroup!=null &amp;&amp; docsInGroup.size()&gt;0)</span>
<span class="nc" id="L3484">				oldDocs.addAll(docsInGroup);</span>
		}
<span class="nc bnc" id="L3486" title="All 2 branches missed.">		for (DocDetails doc : oldDocs)</span>
		{
<span class="nc" id="L3488">			messageToAdminlog.append(&quot;Zmena domeny pre Doc (docId) &quot;).append(doc.getDocId()).append(&quot; :&quot;);</span>
<span class="nc bnc" id="L3489" title="All 4 branches missed.">			if (doc.getFieldT()!=null &amp;&amp; doc.getFieldT().equals(oldDomain))</span>
			{
<span class="nc" id="L3491">				messageToAdminlog.append(&quot;-povolena\n&quot;);</span>
<span class="nc" id="L3492">				doc.setFieldT(newDomain);</span>
			} else
			{
<span class="nc" id="L3495">				messageToAdminlog.append(&quot;-zamietnuta\n&quot;);</span>
			}
<span class="nc" id="L3497">		}</span>

<span class="nc" id="L3499">		Adminlog.add(Adminlog.TYPE_CLIENT_SPECIFIC, messageToAdminlog.toString(), 0, 0);</span>
<span class="nc" id="L3500">		SimpleQuery sq = new SimpleQuery();</span>
<span class="nc" id="L3501">	  	sq.execute(&quot;UPDATE groups SET domain_name=? WHERE group_id IN (&quot;+groupIds+&quot;)&quot;, newDomain);</span>
<span class="nc" id="L3502">	  	sq.execute(&quot;UPDATE groups SET group_name=?, navbar=? WHERE group_id=?&quot;, newDomain, newDomain, group.getGroupId());</span>
<span class="nc" id="L3503">	  	sq.execute(&quot;UPDATE url_redirect SET domain_name=? WHERE domain_name=?&quot;, newDomain, oldDomain);</span>

	  	//premenovanie liniek
<span class="nc" id="L3506">	  	sq.execute(&quot;UPDATE documents SET external_link=REPLACE(external_link, ?, ?) WHERE group_id IN (&quot;+groupIds+&quot;)&quot;, &quot;http://&quot;+oldDomain, &quot;http://&quot;+newDomain);</span>
<span class="nc" id="L3507">	  	sq.execute(&quot;UPDATE documents SET data=REPLACE(data, ?, ?) WHERE group_id IN (&quot;+groupIds+&quot;)&quot;, &quot;http://&quot;+oldDomain, &quot;http://&quot;+newDomain);</span>

<span class="nc" id="L3509">	  	Adminlog.add(Adminlog.TYPE_CLIENT_SPECIFIC, &quot;Changed domain for cloud web, old domain: '&quot;+oldDomain+&quot;', new domain: '&quot;+newDomain+&quot;'&quot;, 0, 0);</span>

<span class="nc" id="L3511">	  	docDb.changeUrlInUrlmap(oldDomain, newDomain);</span>

<span class="nc" id="L3513">	  	IwcmFile oldDir = new IwcmFile(FilePathTools.getDomainBaseFolder(oldDomain));</span>
<span class="nc" id="L3514">	  	IwcmFile newDir = new IwcmFile(FilePathTools.getDomainBaseFolder(newDomain));</span>
<span class="nc" id="L3515">	  	newDir.mkdirs();</span>

	  	//toto asi nezbehne, kedze je to v roznych adresaroch, bude potrebne spravit move
	  	//oldDir.renameTo(newDir);
	  	try
		{
<span class="nc" id="L3521">	  		FileTools.copyDirectory(oldDir, newDir);</span>
<span class="nc" id="L3522">	  		Adminlog.add(Adminlog.TYPE_CLIENT_SPECIFIC, &quot;Changed domain, old domain: '&quot;+oldDomain+&quot;', new domain: '&quot;+newDomain+&quot;', files from &quot;+oldDir.getAbsolutePath()+&quot; to &quot;+newDir.getAbsolutePath(), 0, 0);</span>

<span class="nc" id="L3524">	  		FileTools.deleteDirTree(oldDir);</span>
		}
<span class="nc" id="L3526">		catch (Exception e)</span>
		{
<span class="nc" id="L3528">			sk.iway.iwcm.Logger.error(e);</span>
<span class="nc" id="L3529">		}</span>

	  	//reloadneme singletona aby sa nam prejavili vsetky zmeny
<span class="nc" id="L3532">	  	GroupsDB.getInstance(true);</span>
	  	//toto by asi ani nebolo treba, ale pre istotu pridavam
<span class="nc" id="L3534">	  	DocDB.getInstance(true);</span>

<span class="nc" id="L3536">	  	return true;</span>
	}

	/**
	 * Vrati zoznam hlavnych adresarov pre prava pouzivatela
	 * @param editableGroups
	 * @return
	 */
	public List&lt;GroupDetails&gt; getRootGroups(String editableGroups)
	{
<span class="fc" id="L3546">		List&lt;GroupDetails&gt; rootGroups = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L3548" title="All 2 branches covered.">		if (Tools.isNotEmpty(editableGroups))</span>
		{
<span class="fc" id="L3550">			StringTokenizer st = new StringTokenizer(editableGroups, &quot;,&quot;);</span>
			String id;
			int i_id;
<span class="fc bfc" id="L3553" title="All 2 branches covered.">			while (st.hasMoreTokens())</span>
			{
<span class="fc" id="L3555">				id = st.nextToken().trim();</span>
				try
				{
<span class="fc" id="L3558">					i_id = Integer.parseInt(id);</span>
					//pridaj to do stromu editovatelnych stranok
<span class="fc" id="L3560">					GroupDetails parentGroup = findGroup(i_id);</span>
<span class="fc" id="L3561">					GroupDetails parentGroupCopy = new GroupDetails(parentGroup);</span>
<span class="fc" id="L3562">					parentGroupCopy.setParentGroupId(0);</span>
<span class="pc bpc" id="L3563" title="1 of 2 branches missed.">					if (parentGroup.getFullPath().length() &gt; 200)</span>
					{
<span class="nc" id="L3565">						parentGroupCopy.setGroupName(&quot;...&quot;+parentGroup.getFullPath().substring(parentGroup.getFullPath().length()-198));</span>
					}
					else
					{
<span class="fc" id="L3569">						parentGroupCopy.setGroupName(parentGroup.getFullPath());</span>
					}

<span class="fc" id="L3572">					String userEditableTreeMenuType = Constants.getString(&quot;userEditableTreeMenuType&quot;, &quot;rows&quot;);</span>
<span class="pc bpc" id="L3573" title="1 of 2 branches missed.">					if (&quot;tree&quot;.equalsIgnoreCase(userEditableTreeMenuType)) {</span>

<span class="nc" id="L3575">						GroupDetails root = getGroup(getRoot(parentGroup.getGroupId()));</span>

<span class="nc bnc" id="L3577" title="All 4 branches missed.">						if (rootGroups.stream().noneMatch(r-&gt;r.getGroupId() == root.getGroupId())) {</span>
<span class="nc" id="L3578">							rootGroups.add(root);</span>
						}
<span class="nc" id="L3580">					}</span>
					else {
<span class="pc bpc" id="L3582" title="2 of 4 branches missed.">						if (rootGroups.stream().noneMatch(r-&gt;r.getGroupId() == parentGroupCopy.getGroupId())) {</span>
<span class="fc" id="L3583">							rootGroups.add(parentGroupCopy);</span>
						}
					}
				}
<span class="fc" id="L3587">				catch (Exception ex)</span>
				{

<span class="fc" id="L3590">				}</span>
			}
<span class="fc" id="L3592">		}</span>
		else
		{
<span class="fc" id="L3595">			rootGroups.addAll(getRootGroups());</span>
		}

<span class="fc" id="L3598">		return (rootGroups);</span>
	}

	/**
	 * vrati zoznam nazvov root domen pre ktore ma pouzivatel pravo
	 * @param editableGroups
	 * @return
	 */
	public List&lt;String&gt; getUserRootDomainNames(String editableGroups)
	{
<span class="fc" id="L3608">		List&lt;String&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L3609" title="All 2 branches covered.">		for(GroupDetails gd : getRootGroups(editableGroups))</span>
		{
<span class="fc bfc" id="L3611" title="All 4 branches covered.">			if(Tools.isNotEmpty(gd.getDomainName()) &amp;&amp; ret.contains(gd.getDomainName()) == false)</span>
<span class="fc" id="L3612">				ret.add(gd.getDomainName());</span>
<span class="fc" id="L3613">		}</span>

<span class="fc" id="L3615">		return ret;</span>
	}

	/**
	 * Otestuje ci ma adresar akehokolvek potomka - podadresar alebo web stranku
	 * @param groupId
	 * @return
	 */
	public boolean hasAnyChild(int groupId)
	{
<span class="nc" id="L3625">		return hasAnyChild(groupId, true);</span>
	}

	/**
	 * Otestuje, ci ma podadresar potomka
	 * @param groupId
	 * @param includePages - ak je true, testuju sa aj web stranky
	 * @return
	 */
	public boolean hasAnyChild(int groupId, boolean includePages)
	{
<span class="fc bfc" id="L3636" title="All 2 branches covered.">		for (GroupDetails group : groups)</span>
		{
<span class="fc bfc" id="L3638" title="All 2 branches covered.">			if (group.getParentGroupId() == groupId)</span>
			{
<span class="fc" id="L3640">				return true;</span>
			}
<span class="fc" id="L3642">		}</span>

<span class="fc bfc" id="L3644" title="All 2 branches covered.">		if (includePages)</span>
		{
<span class="fc" id="L3646">			List&lt;DocDetails&gt; docs = DocDB.getInstance().getBasicDocDetailsByGroup(groupId, -1);</span>
<span class="pc bpc" id="L3647" title="1 of 4 branches missed.">			if (docs != null &amp;&amp; docs.size() &gt; 0) return true;</span>
		}

<span class="fc" id="L3650">		return false;</span>
	}

	public GroupDetails addNewRootGroup(String newGroupName)
	{
<span class="nc" id="L3655">		GroupDetails ctxGroup = getNewGroupDetails(newGroupName, 0);</span>
<span class="nc" id="L3656">		GroupsDB.getInstance().setGroup(ctxGroup);</span>

<span class="nc" id="L3658">		return ctxGroup;</span>
	}

	/**
	 * Vytvori novy adresar so zadanym menom v danom parent adresari
	 * @param newGroupName
	 * @param parentGroupId
	 * @return
	 */
	public GroupDetails addNewGroup(String newGroupName, int parentGroupId)
	{
<span class="nc" id="L3669">		GroupDetails ctxGroup = getNewGroupDetails(newGroupName, parentGroupId);</span>
<span class="nc" id="L3670">		GroupsDB.getInstance().setGroup(ctxGroup);</span>

<span class="nc" id="L3672">		return ctxGroup;</span>
	}

	/**
	 * Pripravi groupDetails objekt pre ulozenie do zadaneho parenta
	 * Nastavi potrebne (dedene) atributy a objekty
	 */
	public GroupDetails getNewGroupDetails(String newGroupName, int parentGroupId) {
		GroupDetails parentGroup;
<span class="pc bpc" id="L3681" title="1 of 2 branches missed.">		if (parentGroupId&gt;0) parentGroup = getGroup(parentGroupId);</span>
<span class="nc" id="L3682">		else parentGroup = getGroup(Constants.getInt(&quot;rootGroupId&quot;));</span>

<span class="fc" id="L3684">		GroupDetails ctxGroup = null;</span>
		try
		{
<span class="fc" id="L3687">			ctxGroup = (GroupDetails)parentGroup.clone();</span>
<span class="fc" id="L3688">			ctxGroup.setParentGroupId(parentGroupId);</span>
<span class="fc" id="L3689">			ctxGroup.setDefaultDocId(-1);</span>
<span class="fc" id="L3690">			ctxGroup.setNewPageDocIdTemplate(-1);</span>
<span class="fc" id="L3691">			ctxGroup.setHtmlHead(&quot;&quot;);</span>
<span class="fc" id="L3692">			ctxGroup.setGroupName(newGroupName);</span>
<span class="fc" id="L3693">			ctxGroup.setNavbar(newGroupName);</span>
<span class="fc" id="L3694">			ctxGroup.setUrlDirName(newGroupName);</span>
<span class="fc" id="L3695">			ctxGroup.setUrlDirName(ctxGroup.getUrlDirName());</span>

<span class="fc" id="L3697">			ctxGroup.setSortPriority(GroupsDB.getInstance().getDefaultSortPriority(parentGroupId));</span>

<span class="pc bpc" id="L3699" title="1 of 2 branches missed.">			if (parentGroupId == 0) {</span>
				//pre root foldre toto dava zmysel
<span class="nc" id="L3701">				ctxGroup.setInternal(false);</span>
<span class="nc" id="L3702">				ctxGroup.setMenuType(GroupDetails.MENU_TYPE_ONLYDEFAULT);</span>
			}

<span class="fc" id="L3705">			ctxGroup.setLogonPageDocId(-1);</span>

<span class="fc" id="L3707">			ctxGroup.setGroupId(-1);</span>
<span class="fc" id="L3708">			ctxGroup.setSyncId(0);</span>
<span class="fc" id="L3709">			ctxGroup.setSyncStatus(0);</span>

			//ticket 11208
<span class="pc bpc" id="L3712" title="2 of 4 branches missed.">			if(Tools.isNotEmpty(ctxGroup.getDomainName()) &amp;&amp; ctxGroup.getParentGroupId() &lt; 1)</span>
			{
<span class="nc" id="L3714">				ctxGroup.setDomainName(&quot;www.&quot;+ctxGroup.getUrlDirName()+&quot;.sk&quot;);</span>
			}

<span class="pc bpc" id="L3717" title="1 of 2 branches missed.">			if (parentGroupId&gt;0) {</span>
				//nekopirujeme field_a az field_d pretoze to je nepotrebne (daju sa ziskat rekurzivne)
<span class="fc" id="L3719">				ctxGroup.setFieldA(&quot;&quot;);</span>
<span class="fc" id="L3720">				ctxGroup.setFieldB(&quot;&quot;);</span>
<span class="fc" id="L3721">				ctxGroup.setFieldC(&quot;&quot;);</span>
<span class="fc" id="L3722">				ctxGroup.setFieldD(&quot;&quot;);</span>
			}
		}
<span class="nc" id="L3725">		catch (CloneNotSupportedException e)</span>
		{
<span class="nc" id="L3727">			sk.iway.iwcm.Logger.error(e);</span>
<span class="fc" id="L3728">		}</span>

<span class="fc" id="L3730">		return ctxGroup;</span>
	}

	/**
	 * ziskanie vsetkych System adresarov
	 * @return
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public List&lt;GroupDetails&gt; getAllSystemFolders(boolean forceRefresh)
	{
<span class="pc bpc" id="L3740" title="1 of 2 branches missed.">		if(Constants.getBoolean(&quot;templatesUseRecursiveSystemFolder&quot;) == false) return null;</span>

<span class="nc" id="L3742">		String groupName = &quot;System&quot;;</span>
<span class="nc" id="L3743">		String cacheName = &quot;sk.iway.iwcm.doc.groupsdb.all-system-folders&quot;;</span>
<span class="nc" id="L3744">		int cacheInMinutes = Constants.getInt(&quot;allSystemFoldersCacheMinutes&quot;);</span>

<span class="nc" id="L3746">		Cache c = Cache.getInstance();</span>
<span class="nc bnc" id="L3747" title="All 2 branches missed.">		if(forceRefresh == false)</span>
		{
<span class="nc" id="L3749">			Object o = c.getObject(cacheName);</span>
<span class="nc bnc" id="L3750" title="All 2 branches missed.">			if (o instanceof List&lt;?&gt;)</span>
			{
<span class="nc" id="L3752">				Logger.debug(GroupsDB.class, &quot;citam vsetky system adresare z cache (forceRefresh=&quot;+forceRefresh+&quot;; cacheInMinutes=&quot;+cacheInMinutes+&quot;)&quot;);</span>
<span class="nc" id="L3753">				return (List&lt;GroupDetails&gt;)o;</span>
			}
		}

<span class="nc" id="L3757">		List&lt;GroupDetails&gt; systemFolders = null;</span>
<span class="nc bnc" id="L3758" title="All 2 branches missed.">		if(groups != null)</span>
		{
<span class="nc bnc" id="L3760" title="All 2 branches missed.">			for (GroupDetails group : groups)</span>
			{
<span class="nc bnc" id="L3762" title="All 4 branches missed.">				if (group.isInternal() &amp;&amp; groupName.equalsIgnoreCase(group.getGroupName()))</span>
				{
<span class="nc bnc" id="L3764" title="All 2 branches missed.">					if(systemFolders == null) systemFolders = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3765">					systemFolders.add(group);</span>
				}
<span class="nc" id="L3767">			}</span>
		}

<span class="nc" id="L3770">		Logger.debug(GroupsDB.class, &quot;pisem vsetky system adresare do cache (forceRefresh=&quot;+forceRefresh+&quot;; cacheInMinutes=&quot;+cacheInMinutes+&quot;)&quot;);</span>
<span class="nc bnc" id="L3771" title="All 2 branches missed.">		if(cacheInMinutes &gt; 0) c.setObjectSeconds(cacheName, systemFolders, cacheInMinutes*60, true);</span>

<span class="nc" id="L3773">		return systemFolders;</span>
	}

	/**
	 * Vrati prvy vyskyt adresara System od root adresara az po aktualny adresar groupId
	 * @return
	 */
	public GroupDetails getSystemGroupRecursive(int groupId)
	{
<span class="nc" id="L3782">		List&lt;GroupDetails&gt; pathListGroups = getPathList(groupId);</span>
<span class="nc bnc" id="L3783" title="All 2 branches missed.">		if(pathListGroups != null)</span>
		{
<span class="nc" id="L3785">			List&lt;GroupDetails&gt; getAllSystemFolders = getAllSystemFolders(false);</span>
<span class="nc bnc" id="L3786" title="All 2 branches missed.">			if(getAllSystemFolders != null)</span>
			{
<span class="nc bnc" id="L3788" title="All 2 branches missed.">				for (GroupDetails plGroup : pathListGroups)</span>
				{
<span class="nc bnc" id="L3790" title="All 2 branches missed.">					for (GroupDetails group : getAllSystemFolders)</span>
					{
<span class="nc bnc" id="L3792" title="All 2 branches missed.">						if (group.getParentGroupId() == plGroup.getGroupId())</span>
						{
<span class="nc" id="L3794">							return group;</span>
						}
<span class="nc" id="L3796">					}</span>
<span class="nc" id="L3797">				}</span>
			}
		}

<span class="nc" id="L3801">		return (null);</span>
	}

	/**
	 * Vrati list vsetkych domen
	 * @return
	 */
	public List&lt;String&gt; getAllDomainsList(){
<span class="fc" id="L3809">		HashSet&lt;String&gt; domainsSet=new HashSet&lt;&gt;();</span>

<span class="fc" id="L3811">		List&lt;GroupDetails&gt; allGroups = getGroupsAll();</span>
<span class="fc bfc" id="L3812" title="All 2 branches covered.">		for(GroupDetails g: allGroups){</span>
<span class="fc bfc" id="L3813" title="All 4 branches covered.">				if(g.getParentGroupId() == 0 &amp;&amp; !g.getDomainName().isEmpty()){</span>
<span class="fc" id="L3814">					domainsSet.add(g.getDomainName());</span>
				}
<span class="fc" id="L3816">		}</span>

<span class="fc" id="L3818">		return new ArrayList&lt;&gt;(domainsSet);</span>
	}

    /**
     * Nastav jazyk na podadresare
     *
     * @param parentGroupId
     * @param language
     */
    public void setLngToSubGroups(int parentGroupId, String language) {

<span class="fc" id="L3829">        Connection db_conn = null;</span>
<span class="fc" id="L3830">        PreparedStatement ps = null;</span>
<span class="fc" id="L3831">        String groupIds = this.getSubgroupsIds(parentGroupId);</span>

<span class="fc" id="L3833">        Adminlog.add(Adminlog.TYPE_GROUP, &quot;Force language [&quot; + language + &quot;] to subgroups: &quot; + groupIds, parentGroupId, -1);</span>
        try {
<span class="fc" id="L3835">			db_conn = DBPool.getConnection();</span>
<span class="fc" id="L3836">            ps = db_conn.prepareStatement(&quot;UPDATE groups SET lng=? WHERE group_id IN (&quot; + groupIds + &quot;)&quot;);</span>
<span class="fc" id="L3837">            ps.setString(1, language);</span>
<span class="fc" id="L3838">            ps.execute();</span>
<span class="nc" id="L3839">        } catch (Exception ex) {</span>
<span class="nc" id="L3840">            sk.iway.iwcm.Logger.error(ex);</span>
        } finally {
            try {
<span class="pc bpc" id="L3843" title="1 of 2 branches missed.">                if (ps != null)</span>
<span class="fc" id="L3844">                    ps.close();</span>
<span class="pc bpc" id="L3845" title="1 of 2 branches missed.">                if (db_conn != null)</span>
<span class="fc" id="L3846">                    db_conn.close();</span>
<span class="nc" id="L3847">            } catch (Exception ex) {</span>
<span class="nc" id="L3848">                sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L3849">            }</span>
        }
<span class="fc" id="L3851">    }</span>

    /**
     * nastav sposob zobrazovania a interny podadresarom
     * @param parentGroupId
     * @param internal
     * @param menuType
     * @param loggedMenuType
     */
    public void setInternalAndMenuTypeToSubgroups(int parentGroupId, boolean internal, int menuType, int loggedMenuType) {

<span class="nc" id="L3862">        String groupMenuIds = this.getSubgroupsIds(parentGroupId);</span>

<span class="nc bnc" id="L3864" title="All 2 branches missed.">        if (Tools.isNotEmpty(groupMenuIds)) {</span>
<span class="nc" id="L3865">            Connection db_conn = null;</span>
<span class="nc" id="L3866">            PreparedStatement ps = null;</span>

<span class="nc" id="L3868">            Adminlog.add(Adminlog.TYPE_GROUP, &quot;Force Show Menu Setings to subgroups: &quot; + groupMenuIds, parentGroupId, -1);</span>
            try {
<span class="nc" id="L3870">				db_conn = DBPool.getConnection();</span>
<span class="nc" id="L3871">                ps = db_conn.prepareStatement(&quot;UPDATE groups SET internal=?, menu_type=?, logged_menu_type=?  WHERE group_id IN (&quot; + groupMenuIds + &quot;)&quot;);</span>
<span class="nc" id="L3872">                ps.setBoolean(1, internal);</span>
<span class="nc" id="L3873">                ps.setInt(2, menuType);</span>
<span class="nc" id="L3874">                ps.setInt(3, loggedMenuType);</span>
<span class="nc" id="L3875">                ps.execute();</span>
<span class="nc" id="L3876">            } catch (Exception ex) {</span>
<span class="nc" id="L3877">                sk.iway.iwcm.Logger.error(ex);</span>
            } finally {
                try {
<span class="nc bnc" id="L3880" title="All 2 branches missed.">                    if (ps != null)</span>
<span class="nc" id="L3881">                        ps.close();</span>
<span class="nc bnc" id="L3882" title="All 2 branches missed.">                    if (db_conn != null)</span>
<span class="nc" id="L3883">                        db_conn.close();</span>
<span class="nc" id="L3884">                } catch (Exception ex) {</span>
<span class="nc" id="L3885">                    sk.iway.iwcm.Logger.error(ex);</span>
<span class="nc" id="L3886">                }</span>
            }
        }
<span class="nc" id="L3889">    }</span>

    /**
     * nastav prava podadresarom
     */
    public void setPermissionToSubgroups(int parentGroupId, String passwordProtectedString) {

<span class="fc" id="L3896">        Connection db_conn = null;</span>
<span class="fc" id="L3897">        PreparedStatement ps = null;</span>
<span class="fc" id="L3898">        String groupIds = this.getSubgroupsIds(parentGroupId);</span>

<span class="fc" id="L3900">        Adminlog.add(Adminlog.TYPE_GROUP, &quot;Force perms to subgroups: &quot; + groupIds + &quot; perms=&quot; + passwordProtectedString, parentGroupId, -1);</span>

        try {
<span class="fc" id="L3903">			db_conn = DBPool.getConnection();</span>
<span class="fc" id="L3904">            ps = db_conn.prepareStatement(&quot;UPDATE groups SET password_protected=? WHERE group_id IN (&quot; + groupIds + &quot;)&quot;);</span>
<span class="fc" id="L3905">            ps.setString(1, passwordProtectedString);</span>
<span class="fc" id="L3906">            ps.execute();</span>
<span class="nc" id="L3907">        } catch (Exception ex) {</span>
<span class="nc" id="L3908">            sk.iway.iwcm.Logger.error(ex);</span>
        } finally {
            try {
<span class="pc bpc" id="L3911" title="1 of 2 branches missed.">                if (ps != null)</span>
<span class="fc" id="L3912">                    ps.close();</span>
<span class="pc bpc" id="L3913" title="1 of 2 branches missed.">                if (db_conn != null)</span>
<span class="fc" id="L3914">                    db_conn.close();</span>
<span class="nc" id="L3915">            } catch (Exception ex) {</span>
<span class="nc" id="L3916">                sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L3917">            }</span>
		  }

		  //mame zmeny je najlepsie refreshnut celu GroupsDB
<span class="fc" id="L3921">		  GroupsDB.getInstance(true);</span>
<span class="fc" id="L3922">    }</span>

    /**
     * nastav sablonu podadresarom
     * @param parentGroupId
     */
    public void setTemplateToSubgroups(int parentGroupId, int templateId) {

<span class="fc" id="L3930">        Connection db_conn = null;</span>
<span class="fc" id="L3931">        PreparedStatement ps = null;</span>

<span class="fc" id="L3933">        String groupIds = this.getSubgroupsIds(parentGroupId);</span>
<span class="fc" id="L3934">        Adminlog.add(Adminlog.TYPE_GROUP, &quot;Force template to subgroups: &quot; + groupIds, parentGroupId, templateId);</span>

        try {
<span class="fc" id="L3937">			db_conn = DBPool.getConnection();</span>
<span class="fc" id="L3938">            ps = db_conn.prepareStatement(&quot;UPDATE groups SET temp_id=? WHERE group_id IN (&quot; + groupIds + &quot;)&quot;);</span>
<span class="fc" id="L3939">            ps.setInt(1, templateId);</span>
<span class="fc" id="L3940">            ps.execute();</span>
<span class="nc" id="L3941">        } catch (Exception ex) {</span>
<span class="nc" id="L3942">            sk.iway.iwcm.Logger.error(ex);</span>
        } finally {
            try {
<span class="pc bpc" id="L3945" title="1 of 2 branches missed.">                if (ps != null)</span>
<span class="fc" id="L3946">                    ps.close();</span>
<span class="pc bpc" id="L3947" title="1 of 2 branches missed.">                if (db_conn != null)</span>
<span class="fc" id="L3948">                    db_conn.close();</span>
<span class="nc" id="L3949">            } catch (Exception ex) {</span>
<span class="nc" id="L3950">                sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L3951">            }</span>
        }
<span class="fc" id="L3953">    }</span>

    /**
     * nastav sablonu podstrankam
     */
    public void setTemplateToSubpages(int parentGroupId, int templateId) {
<span class="fc" id="L3959">        Connection db_conn = null;</span>
<span class="fc" id="L3960">        PreparedStatement ps = null;</span>

<span class="fc" id="L3962">        String groupIds = this.getSubgroupsIds(parentGroupId);</span>
<span class="fc" id="L3963">        Adminlog.add(Adminlog.TYPE_GROUP, &quot;Force template to subpages: &quot; + groupIds, parentGroupId, templateId);</span>

        try {
<span class="fc" id="L3966">			db_conn = DBPool.getConnection();</span>
<span class="fc" id="L3967">            ps = db_conn.prepareStatement(&quot;UPDATE documents SET temp_id=? WHERE group_id IN (&quot; + groupIds + &quot;)&quot;);</span>
<span class="fc" id="L3968">            ps.setInt(1, templateId);</span>
<span class="fc" id="L3969">            ps.execute();</span>
<span class="nc" id="L3970">        } catch (Exception ex) {</span>
<span class="nc" id="L3971">            sk.iway.iwcm.Logger.error(ex);</span>
        } finally {
            try {
<span class="pc bpc" id="L3974" title="1 of 2 branches missed.">                if (ps != null)</span>
<span class="fc" id="L3975">                    ps.close();</span>
<span class="pc bpc" id="L3976" title="1 of 2 branches missed.">                if (db_conn != null)</span>
<span class="fc" id="L3977">                    db_conn.close();</span>
<span class="nc" id="L3978">            } catch (Exception ex) {</span>
<span class="nc" id="L3979">                sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L3980">            }</span>
        }
<span class="fc" id="L3982">    }</span>

    /**
     * nastav zobrazenie pre podstranky
     * @param parentGroupId
     * @param loggedMenuTypeSubdocs
     */
    public void setMenuVisibilityToSubpages(int parentGroupId, String loggedMenuTypeSubdocs) {
<span class="nc" id="L3990">        Connection db_conn = null;</span>
<span class="nc" id="L3991">        PreparedStatement ps = null;</span>

<span class="nc" id="L3993">        boolean allVisible = &quot;allVisible&quot;.equals(loggedMenuTypeSubdocs);</span>
<span class="nc bnc" id="L3994" title="All 2 branches missed.">        Adminlog.add(Adminlog.TYPE_GROUP, &quot;MenuVisibility: all dir documents set to &quot;+(!allVisible ? &quot;NOT&quot; : &quot;&quot;)+&quot; visible in menu&quot;, parentGroupId, -1);</span>
        try {
<span class="nc" id="L3996">			db_conn = DBPool.getConnection();</span>
<span class="nc" id="L3997">            ps = db_conn.prepareStatement(&quot;UPDATE documents SET show_in_menu=? WHERE group_id=?&quot;);</span>
<span class="nc" id="L3998">            ps.setBoolean(1, allVisible);</span>
<span class="nc" id="L3999">            ps.setInt(2,parentGroupId);</span>
<span class="nc" id="L4000">            ps.execute();</span>
<span class="nc" id="L4001">        } catch (Exception ex) {</span>
<span class="nc" id="L4002">            sk.iway.iwcm.Logger.error(ex);</span>
        } finally {
            try {
<span class="nc bnc" id="L4005" title="All 2 branches missed.">                if (ps != null)</span>
<span class="nc" id="L4006">                    ps.close();</span>
<span class="nc bnc" id="L4007" title="All 2 branches missed.">                if (db_conn != null)</span>
<span class="nc" id="L4008">                    db_conn.close();</span>
<span class="nc" id="L4009">            } catch (Exception ex) {</span>
<span class="nc" id="L4010">                sk.iway.iwcm.Logger.error(ex);</span>
<span class="nc" id="L4011">            }</span>
        }
<span class="nc" id="L4013">    }</span>

	/**
	 * Rekurzivne pregeneruje prioritu stranok a podadresarov.
	 * @param groupId
	 */
	public void regenerateSortPriority(int groupId) {

<span class="nc" id="L4021">		int priority = GroupsDB.getInstance().getGroup(groupId).getSortPriority();</span>

<span class="nc" id="L4023">    	List&lt;DocDetails&gt; docDetailsList = DocDB.getInstance().getDocByGroup(groupId, DocDB.ORDER_PRIORITY, true, 0, 0, false);</span>

<span class="nc bnc" id="L4025" title="All 2 branches missed.">		for (DocDetails docDetails : docDetailsList) {</span>
<span class="nc" id="L4026">			docDetails.setSortPriority(priority);</span>
<span class="nc" id="L4027">			priority += 10;</span>
<span class="nc" id="L4028">			DocDB.saveDoc(docDetails);</span>
<span class="nc" id="L4029">		}</span>

<span class="nc" id="L4031">		List&lt;GroupDetails&gt; groupDetailsList = GroupsDB.getInstance().getGroups(groupId);</span>

<span class="nc" id="L4033">		priority = (int)Math.ceil(GroupsDB.getInstance().getGroup(groupId).getSortPriority()/10.0f) * 100;</span>

<span class="nc bnc" id="L4035" title="All 2 branches missed.">		for (GroupDetails groupDetails : groupDetailsList) {</span>
<span class="nc" id="L4036">			priority += 10;</span>
<span class="nc" id="L4037">			groupDetails.setSortPriority(priority);</span>
<span class="nc" id="L4038">			GroupsDB.getInstance().setGroup(groupDetails);</span>
<span class="nc" id="L4039">			this.regenerateSortPriority(groupDetails.getGroupId());</span>
<span class="nc" id="L4040">		}</span>
<span class="nc" id="L4041">	}</span>

	/**
	 * Opravi poradie adresarov po presunuti zadaneho adresara cez drag&amp;drop v adresari (precisluje poradie nasledovnych adresarov)
	 * @param group
	 * @param position
	 */
	public void fixGroupSortOrder(GroupDetails group, int position)
	{
		//ziskaj pocet adresarov v tomto adresari, tie musime odpocitat
<span class="nc" id="L4051">		GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="nc" id="L4052">		List&lt;GroupDetails&gt; groupsList = groupsDB.getGroups(group.getParentGroupId());</span>
<span class="nc bnc" id="L4053" title="All 2 branches missed.">		if (position &lt; 0) position = 0;</span>

		//v adresari nic nie je, nemusime menit sort priority
<span class="nc bnc" id="L4056" title="All 2 branches missed.">		if (groupsList.size()==0) return;</span>

<span class="nc" id="L4058">		StringBuilder updateSortOrderList = null;</span>
<span class="nc" id="L4059">		int maxSortPriority = 0;</span>
<span class="nc bnc" id="L4060" title="All 2 branches missed.">		for (GroupDetails g : groupsList)</span>
		{
<span class="nc" id="L4062">			maxSortPriority = g.getSortPriority();</span>

<span class="nc bnc" id="L4064" title="All 2 branches missed.">			if (g.getGroupId() == group.getGroupId())</span>
			{
				//netreba nic menit
<span class="nc" id="L4067">				Logger.debug(GroupsDB.class, &quot;fixGroupSortOrder, ZHODA groupID, position=&quot;+position);</span>
<span class="nc bnc" id="L4068" title="All 2 branches missed.">				if (position == 0) return;</span>
				continue;
			}

<span class="nc" id="L4072">			position--;</span>

<span class="nc" id="L4074">			Logger.debug(GroupsDB.class, &quot;fixGroupSortOrder, group=&quot;+g.getGroupName()+&quot; &quot;+g.getGroupId()+&quot; position=&quot;+position);</span>

<span class="nc bnc" id="L4076" title="All 2 branches missed.">			if (position == -1)</span>
			{
<span class="nc" id="L4078">				Logger.debug(GroupsDB.class, &quot;fixGroupSortOrder, position==-1, setting priority: &quot;+g.getSortPriority());</span>
<span class="nc" id="L4079">				group.setSortPriority(g.getSortPriority());</span>
			}
<span class="nc bnc" id="L4081" title="All 2 branches missed.">			if (position &lt; 0)</span>
			{
<span class="nc bnc" id="L4083" title="All 2 branches missed.">				if (updateSortOrderList == null) updateSortOrderList = new StringBuilder(String.valueOf(g.getGroupId()));</span>
<span class="nc" id="L4084">				else updateSortOrderList.append(&quot;,&quot;).append(String.valueOf(g.getGroupId()));</span>

				//update cache hodnoty
<span class="nc" id="L4087">				g.setSortPriority(g.getSortPriority() + 10);</span>
<span class="nc" id="L4088">				setGroup(g);</span>
			}

<span class="nc" id="L4091">			Logger.debug(GroupsDB.class, &quot;fixGroupSortOrder, toUpdate=&quot;+updateSortOrderList);</span>
<span class="nc" id="L4092">		}</span>

<span class="nc bnc" id="L4094" title="All 2 branches missed.">		if (updateSortOrderList == null)</span>
		{
<span class="nc" id="L4096">			Logger.debug(GroupsDB.class, &quot;updateSortOrderList, updatujem self, maxSortPriority=&quot;+maxSortPriority);</span>
<span class="nc" id="L4097">			group.setSortPriority(maxSortPriority + 10);</span>
		}
<span class="nc" id="L4099">	}</span>

	/**
	 * Cached list of parentGroups
	 *
	 * @param groupId
	 * @return
	 */
	public static List&lt;GroupDetails&gt; getParentGroupsCached(int groupId)
	{
<span class="fc" id="L4109">		final String CACHE_KEY =  &quot;GroupsDB.getListParentGroups(&quot;+groupId+&quot;)&quot;;</span>
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L4111">		List&lt;GroupDetails&gt; listParentGroups = (List&lt;GroupDetails&gt;) Cache.getInstance().getObject(CACHE_KEY);</span>
<span class="fc bfc" id="L4112" title="All 2 branches covered.">		if(listParentGroups == null)</span>
		{
<span class="fc" id="L4114">			listParentGroups = GroupsDB.getInstance().getParentGroups(groupId);</span>
<span class="fc" id="L4115">			Cache.getInstance().setObject(CACHE_KEY, listParentGroups, Constants.getInt(&quot;GroupsDB.parentGroupsCacheMinutes&quot;, 10));</span>
		}
<span class="fc" id="L4117">		return listParentGroups;</span>
	}

	/**
	 * Returns GroupDetails of /System/Trash folder, for multidomain returns domain specific Trash folder
	 * @return
	 */
	public GroupDetails getTrashGroup() {
		//tu sa vytvara adresar podla default jazyka, nie podla prihlaseneho pouzivatela!
<span class="fc" id="L4126">		Prop propSystem = Prop.getInstance(Constants.getString(&quot;defaultLanguage&quot;));</span>
<span class="fc" id="L4127">		String trashDirName = propSystem.getText(&quot;config.trash_dir&quot;);</span>
<span class="fc" id="L4128">		GroupDetails trashGroupDetails = getCreateGroup(trashDirName);</span>
<span class="fc" id="L4129">		return trashGroupDetails;</span>
	}

	/**
	 * Check if group is in trash
	 * @param groupId
	 * @return
	 */
	public boolean isInTrash(int groupId) {
<span class="fc" id="L4138">		String path = getPath(groupId);</span>
<span class="fc" id="L4139">		GroupDetails group = getGroup(groupId);</span>
<span class="pc bpc" id="L4140" title="1 of 2 branches missed.">		if (group == null) return true;</span>

		//do not use getTrashGroup() here because it needs Request/Request bean to create missing trash group in domain folder
<span class="fc" id="L4143">		Prop propSystem = Prop.getInstance(Constants.getString(&quot;defaultLanguage&quot;));</span>
<span class="fc" id="L4144">		String trashDirName = propSystem.getText(&quot;config.trash_dir&quot;);</span>

<span class="fc" id="L4146">		boolean isInTrash =</span>
<span class="fc" id="L4147">			DB.internationalToEnglish(path).toLowerCase().startsWith(DB.internationalToEnglish(trashDirName).toLowerCase());</span>

<span class="fc" id="L4149">		return isInTrash;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>